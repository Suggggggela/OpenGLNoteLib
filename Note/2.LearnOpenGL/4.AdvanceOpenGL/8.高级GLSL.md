
这节我们讲解一些glsl的进阶用法

## 1.GLSL内建变量
GLSL中有很多内建的变量，比如之前我们用到过下边这些
- gl_Posotopm：VS的ClipSpace输出位置变量
- gl_FragCoord：x，y为当前Fragment的ScreenSpace坐标， z为当前Fragment的深度（0~1）


接下来我们说一些没见过的
## 2.VS变量
### gl_PointSize
`GL_POINTS`是我们可以选用的一个图元（primitive），使用它的话每个Vertex都是一个primitive，都会被渲染为一个点
`glPointSize`函数可以设置渲染出来的点的大小，这个功能默认是关闭的，我们需要先开启再修改

```cpp
glEnable(GL_PROGRAM_POINT_SIZE);

//VS
void main() 
{ 
    gl_Position = projection * view * model * vec4(aPos, 1.0); 
    gl_PointSize = gl_Position.z; //离点越远他就越大
}
```
![485x362](assets/8.高级GLSL_image_1.png)

### gl_VertexID
`gl_VertexID`是一个输入变量，顾名思义它存储了当前绘制的Vertex的ID
当使用DrawElements时，它存储的是Vertex的Index
当使用DrawArrays时，它存储的是从DrawCall开始的已处理顶点数量

## 3.FS变量
### gl_FragCoord
- x，y分量：是ScreenSpace的坐标，原点为窗口左下角
- z分量：片元的深度值

我们可以通过简单的效果看：比如左半屏幕的物体为红色，右半屏幕的物体颜色为绿色：

```cpp
void main() 
{ 
if(gl_FragCoord.x < SCR_WIDTH) 
    FragColor = vec4(1.0, 0.0, 0.0, 1.0); 
else 
    FragColor = vec4(0.0, 1.0, 0.0, 1.0); 
}
```
![398x298](assets/8.高级GLSL_image_2.png)

### gl_FrontFacing
gl_FrontFacing代表着当前片元是面向(true)我们还是背对(false)我们的
当然是用这个的前提是不开启面剔除FaceCulling，如果开启就不存在背对着我们的面了

### gl_FragDepth
gl_FragDepth允许我们修改当前片元的深度值，（gl_FragCoord是只读的，无法修改）
如果我们没有使用gl_FragDepth进行深度手动设置，那么这个值就会自动取用gl_FragCoord的z值

但是使用gl_FragDepth修改片元的深度是有代价的：当你使用它时，所有的Early-Z提前深度测试都将失效

不过在OpenGL4.2之后，我们可以调和这些，它允许我们在FS顶部使用Depth Condition声明gl_FragDetph的范围
condition有以下值：

|条件|描述|
|---|---|
|`any`|默认值。提前深度测试是禁用的，你会损失很多性能|
|`greater`|你只能让深度值比`gl_FragCoord.z`更大|
|`less`|你只能让深度值比`gl_FragCoord.z`更小|
|`unchanged`|如果你要写入`gl_FragDepth`，你将只能写入`gl_FragCoord.z`的值|
```cpp
#version 420 core // 注意GLSL的版本！ 
out vec4 FragColor; 
layout (depth_greater) 
out float gl_FragDepth; 
void main() { FragColor = vec4(1.0); gl_FragDepth = gl_FragCoord.z + 0.1; }

```


## 4.Interface blocks 接口块
目前为止我们从VS向FS发送数据，都是一个一个发送的
如果你写过Unity的Shader，你就会有疑问：顶点和片元的结构体去哪了？
这就是Interface blocks，它允许我们将Uniforms打包到结构体从VS发送给FS
我们同样使用`in`和`out`关键字来声明

```cpp
//VS
#version 330 core
layout(location = 0) in vec3 aPos;
layout(location = 1) in vec2 aTexCoords;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

out VS_OUT
{
    vec2 TexCoords;
} vs_out;

void main()
{
    gl_Position = projection * view * model * vec4(aPos, 1.0);
    vs_out.TexCoords = aTexCoords;
}

//FS
#version 330 core
out vec4 FragColor;

in VS_OUT
{
    vec2 TexCoords;
} fs_in;

uniform sampler2D texture;

void main()
{
    FragColor = texture(texture, fs_in.TexCoords);
}
```

## 5.Uniform Buffer Object 
既然VS向FS发送数据可以打包成结构体，那么我们一个一个设置的Uniform可以吗？
当然可以，并且实际渲染时，肯定不止有一个shader在使用，每个shader都要一个个设置Uniform雀氏是反人类的

OpenGL提供了Uniform Buffer Object来支持我们这样做，它允许我们定义一系列可以在多个shader中相同全局Uniform变量
它同样是个Buffer，所以我们可以通过glGenBuffers创建它，并bind到`GL_UNIFROM_BUFFER`

我们先看看怎么使用

```cpp
#version 330 core
layout(location = 0) in vec3 aPos;

//uniform可以直接通过name在main函数获取
layout(std140) uniform Matrices
{
    mat4 projection;
    mat4 view;
};

uniform mat4 model;

void main()
{
    gl_Position = projection * view * model * vec4(aPos, 1.0);
}
```
你看了之后可能会疑惑，这个std140是啥？
接下来我们就说说如何将uniforms填充到Buffer中

## 6.Uniform block Layout
UniformBlock的内容是存在Unifrom Buffer Object中的，它实际上也是块预留的内存
这块数据不会保存具体数据是什么类型的，所以我们还需要像VertexAttribute一样告诉Layout，告诉它哪一部分内存对应着Shader中的哪一个Uniform

假设我们有以下的Uniform Block
```cpp
layout(std140) uniform ExampleBlock
{
    float value;
    vec3  vector;
    mat4  matrix;
    float values[3];
    bool  boolean;
    int   integer;
};
```
我们需要以下东西来顺序的将它们放入Buffer中
- 每个变量的大小（byte）
- 每个变量的offset（从block起始位置算起）

其中：
    变量的大小都在OpenGL中有清楚的声明，直接对应C++的数据类型
    OpenGL没有声明这些变量的间距(spacing)，这允许硬件在它认为合适的位置存放变量。例如：有些硬件支持把vec3放在float边上，既先给vec3填充到4个float的数组中，剩下一个变量给float用（想想unity声明shader属性的Vector，是不是第四个分量很少用）


### 共享布局-Shared Layout
默认情况下，OpenGL会使用一个叫做共享布局的Uniform内存布局，因为硬件一旦定义了偏移量，多个program之间就会一直共享这些偏移量
在共享布局中，只要变量顺序不变，glsl可以变动Uniform变量的位置来优化
因为我们无法知道每个Uniform的offset，也就不知道如何精准的在Buffer中填充了
不过可以通过glGetUniformIndices查询，这里先按下不表

###  std140
虽然共享布局能优化，但是要查询每个Unifrom的offset会产生很多工作量。通常是不使用共享布局而是使用std140布局，这也是上边代码中std140的意义
std140布局声明了每个变量的offset都是由一系列规则决定的，这样一来就显式的声明了每个变量类型的内存布局，我们就可以手动计算出每个变量的offset
其中：
- 每个变量都有**基准对齐值(Base Alignment)**，它等于每个变量在Uniform Block中所占的空间(包括填充量padding)，这个基准对齐值是使用std140布局的规则计算出来的
- 对于每个变量，计算它的**对齐偏移量(Alignment Offset)**，它是一个变量从Block起始位置的字节偏移量
- 一个变量的对齐偏移量必须是基准对齐值的倍数

布局规则的原文可以在这里找到： https://registry.khronos.org/OpenGL/extensions/ARB/ARB_uniform_buffer_object.txt
我们列举一些常见的：
比如：GLSL中的每个变量，比如int，float，bool都被定义为4byte，每4个byte将会用一个N来表示

|类型|布局规则|
|---|---|
|标量，比如int和bool|每个标量的基准对齐量为N。|
|向量|2N或者4N。这意味着vec3的基准对齐量为4N。|
|标量或向量的数组|每个元素的基准对齐量与vec4的相同。|
|矩阵|储存为列向量的数组，每个向量的基准对齐量与vec4的相同。|
|结构体|等于所有元素根据规则计算后的大小，但会填充到vec4大小的倍数。|

以上边例子中的ExampleBlock为例：

```cpp
layout(std140) uniform ExampleBlock
{
                       // 基准对齐量        // 对齐偏移量
    float value;       // 4               // 0 
    vec3 vector;       // 16              // 16  (必须是16的倍数，所以 4->16)
    mat4 matrix;       // 16              // 32  (列 0)
                       // 16              // 48  (列 1)
                       // 16              // 64  (列 2)
                       // 16              // 80  (列 3)
    float values[3];   // 16              // 96  (values[0])
                       // 16              // 112 (values[1])
                       // 16              // 128 (values[2])
    bool boolean;      // 4               // 144
    int integer;       // 4               // 148
};
```
通过上边手动计算出的offset，我们就可以是glBufferSubData对UniformBuffer进行数据填充了

### 紧凑packed布局
和共享布局一样，packed布局也需要填充数据之前先查询每个变量的offset
packed布局不能保证这个布局在每个program中都保持不变（意思就是不能保证共享），因为它允许编译器将uniform变量从UniformBlock中优化掉，这样就可能会导致每个program中不一样了

## 7.使用UniformBuffer
讨论完如何创建UniformBlock，如何设置Layout，现在我们看看如何使用

### 创建UniformBufferBuffer
首先创建一个UniformBuffer
```cpp
unsigned int uboExampleBlock;
glGenBuffers(1, &uboExampleBlock);
glBindBuffer(GL_UNIFORM_BUFFER, uboExampleBlock);
glBufferData(GL_UNIFORM_BUFFER, 152, NULL, GL_STATIC_DRAW); // 分配152字节的内存
glBindBuffer(GL_UNIFORM_BUFFER, 0);
```

### 绑定UniformBuffer和Shader-UniformBlock
接下来是填充或者更新数据到Buffer
我们绑定到uboExampleBlock，然后使用glBufferSubData填充数据到Buffer，这样更新一次UniformBuffer，所有使用这个Buffer的Shader中的Uniforms数据就都更新了
那么问题来了，OpenGL如何知道哪个UniformBuffer对应着哪个UniformBlock呢？
OpenGL的contex中，定义了一些`BindingPoint绑定点`
我们可以将UnifromBuffer和UniformBlock链接到同一绑定点，这样对应关系就清楚了![528x329](assets/8.高级GLSL_image_3.png)
通过上图，你也可以发现，我们可以将不同的UniformBuffer绑定到不同绑定点，同时这个绑定点链接这不止一个Shader，这其实就是我们上边说的**共享**，这些shader的UniformBlock共享相同的Uniform数据（前提是这些shader都定义了下相同的UniformBlock）

**绑定UniformBlock到绑定点**的方法是`glUniformBlockBinding`（每个shader都需要进行下边的Bind）
```cpp
unsigned int lights_index = glGetUniformBlockIndex(shaderA.ID, "Lights"); 
glUniformBlockBinding(shaderA.ID, lights_index, 2);
//Parameter：GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding

```
在OpenGL4.2之后，我们可以在VS添加一个布局标识符将UniformBlock的绑定点显式的存在shader中
```cpp
layout(std140, binding = 2) uniform Lights { ... };
```


**绑定UniformBuffer到绑定点**的方法是`glBindBufferBase`和`glBindBufferRange`
```cpp
//方法1
glBindBufferBase(GL_UNIFORM_BUFFER, 2, uboExampleBlock); 
//方法2 
glBindBufferRange(GL_UNIFORM_BUFFER, 2, uboExampleBlock, 0, 152);
```
glBindBufferBase的参数是：BufferTarget，BindPointIndex，UniformBufferObject
glBindBufferRange的参数是：BufferTarget，BindPointIndex，UniformBufferObject，offset，size
两者的区别是Base是绑定整个UniformBuffer，Range可以将UniformBuffer的特定部分绑定

### 填充UniformBuffer
一切都绑定好之后，我们就可以填充数据了
```cpp
glBindBuffer(GL_UNIFORM_BUFFER, uboExampleBlock);
int b = true; // GLSL中的bool是4字节的，所以我们将它存为一个integer
glBufferSubData(GL_UNIFORM_BUFFER, 144, 4, &b);
glBindBuffer(GL_UNIFORM_BUFFER, 0);

```

## 使用单个Uniform和UniformBuffer的区别
- 使用ubo设置是一次性设置的会快很多
- 修改Uniform时也是方便（对于多个shader这种情况）
- 最重要的是，使用ubo可以设置的Uniform更多。 最大的Uniform数量可以通过GL_MAX_VERTEX_UNIFORM_COMPONENTS获取


## 例子
例子中我们使用4个不同颜色的shader绘制4个cube
我们将使用UniformBuffer一次性设置这4个shader的vp矩阵

shader:
```cpp
//VS
#version 330 core
layout (location = 0) in vec3 aPos;

layout (std140) uniform Matrices
{
    mat4 projection;
    mat4 view;
};
uniform mat4 model;

void main()
{
    gl_Position = projection * view * model * vec4(aPos, 1.0);
}  

//FS
#version 330 core
out vec4 FragColor;

void main()
{
    FragColor = vec4(0.0, 0.0, 1.0, 1.0);
}
```

UniformBuffer：

```cpp
//------UniformBuffer
//Get UniformBlockIndex
unsigned int uniformBlockIndexRed = glGetUniformBlockIndex(shaderRed.ID, "Matrices");
unsigned int uniformBlockIndexGreen = glGetUniformBlockIndex(shaderGreen.ID, "Matrices");
unsigned int uniformBlockIndexBlue = glGetUniformBlockIndex(shaderBlue.ID, "Matrices");
unsigned int uniformBlockIndexYellow = glGetUniformBlockIndex(shaderYellow.ID, "Matrices");
//Bind UnformBlock to bindingPoint0
glUniformBlockBinding(shaderRed.ID, uniformBlockIndexRed, 0);
glUniformBlockBinding(shaderGreen.ID, uniformBlockIndexGreen, 0);
glUniformBlockBinding(shaderBlue.ID, uniformBlockIndexBlue, 0);
glUniformBlockBinding(shaderYellow.ID, uniformBlockIndexYellow, 0);
//Create UniformBufferObject
unsigned int uboMatrices;
glGenBuffers(1, &uboMatrices);
glBindBuffer(GL_UNIFORM_BUFFER, uboMatrices);
glBufferData(GL_UNIFORM_BUFFER, 2 * sizeof(glm::mat4), NULL, GL_STATIC_DRAW);
glBindBuffer(GL_UNIFORM_BUFFER, 0);
//Bind UniformBuffer to bindingPoint0
glBindBufferRange(GL_UNIFORM_BUFFER, 0, uboMatrices, 0, 2 * sizeof(glm::mat4));

// store the projection matrix (we only do this once now) (note: we're not using zoom anymore by changing the FoV)
glm::mat4 projection = glm::perspective(45.0f, (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f);
glBindBuffer(GL_UNIFORM_BUFFER, uboMatrices);
glBufferSubData(GL_UNIFORM_BUFFER, 0, sizeof(glm::mat4), glm::value_ptr(projection));
glBindBuffer(GL_UNIFORM_BUFFER, 0);
```

Draw:

```cpp
while (!glfwWindowShouldClose(window))
{
    float currentFrame = static_cast<float>(glfwGetTime());
    deltaTime = currentFrame - lastFrame;
    lastFrame = currentFrame;

    processInput(window);

    glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);


    // set the view and projection matrix in the uniform block - we only have to do this once per loop iteration.
    glm::mat4 view = camera.GetViewMatrix();
    glBindBuffer(GL_UNIFORM_BUFFER, uboMatrices);
    glBufferSubData(GL_UNIFORM_BUFFER, sizeof(glm::mat4), sizeof(glm::mat4), glm::value_ptr(view));
    glBindBuffer(GL_UNIFORM_BUFFER, 0);

    // draw 4 cubes 
    // RED
    glBindVertexArray(cubeVAO);
    shaderRed.use();
    glm::mat4 model = glm::mat4(1.0f);
    model = glm::translate(model, glm::vec3(-0.75f, 0.75f, 0.0f)); // move top-left
    shaderRed.setMat4("model", model);
    glDrawArrays(GL_TRIANGLES, 0, 36);
    // GREEN
    shaderGreen.use();
    model = glm::mat4(1.0f);
    model = glm::translate(model, glm::vec3(0.75f, 0.75f, 0.0f)); // move top-right
    shaderGreen.setMat4("model", model);
    glDrawArrays(GL_TRIANGLES, 0, 36);
    // YELLOW
    shaderYellow.use();
    model = glm::mat4(1.0f);
    model = glm::translate(model, glm::vec3(-0.75f, -0.75f, 0.0f)); // move bottom-left
    shaderYellow.setMat4("model", model);
    glDrawArrays(GL_TRIANGLES, 0, 36);
    // BLUE
    shaderBlue.use();
    model = glm::mat4(1.0f);
    model = glm::translate(model, glm::vec3(0.75f, -0.75f, 0.0f)); // move bottom-right
    shaderBlue.setMat4("model", model);
    glDrawArrays(GL_TRIANGLES, 0, 36);




    // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)
    // -------------------------------------------------------------------------------
    glfwSwapBuffers(window);
    glfwPollEvents();
}
```
