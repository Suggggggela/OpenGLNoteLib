这节我们来了解一下几何着色器

## 1.GeometryShader
几何着色器位于VS到FS之间，它的作用是根据输入图元primitive的顶点生成片元
- 输入：一组primitive的顶点
- 作用：对这组顶点进行变换，可以变换为完全不同的图元；还可以生成比原来更多的顶点

一个示例GS：
- ref1.points声明从VS输入的图元类型
- ref2. triangle_strip 声明输出图元类型， max_vertices声明输出的最大顶点数
- ref3. gs_in
- ref4.

其中
**输入图元类型**可以从下边的类型中选择：
- `points`：绘制GL_POINTS图元时。
- `lines`：绘制GL_LINES或GL_LINE_STRIP时
- `lines_adjacency`：GL_LINES_ADJACENCY或GL_LINE_STRIP_ADJACENCY
- `triangles`：GL_TRIANGLES、GL_TRIANGLE_STRIP或GL_TRIANGLE_FAN
- `triangles_adjacency`：GL_TRIANGLES_ADJACENCY或GL_TRIANGLE_STRIP_ADJACENCY

**输出图元类型**可以从下边的类型中选择：
- `points`
- `line_strip`
- `triangle_strip`


**EmitVertex**
每次我们调用EmitVertex时，gl_Position中的向量会被添加到图元中来
当EndPrimitive被调用时，所有发射出的(Emitted)顶点都会合成为指定的输出渲染图元。在一个或多个EmitVertex调用之后重复调用EndPrimitive能够生成多个图元
```cpp
#version 330 core
layout (points) in; //ref1
layout (triangle_strip, max_vertices = 5) out;//ref2

//ref3
in VS_OUT {
    vec3 color;
} gs_in[];

out vec3 fColor;

void build_house(vec4 position)
{    
    fColor = gs_in[0].color; // gs_in[0] since there's only one input vertex
    gl_Position = position + vec4(-0.2, -0.2, 0.0, 0.0); // 1:bottom-left   
    EmitVertex();   
    gl_Position = position + vec4( 0.2, -0.2, 0.0, 0.0); // 2:bottom-right
    EmitVertex();
    gl_Position = position + vec4(-0.2,  0.2, 0.0, 0.0); // 3:top-left
    EmitVertex();
    gl_Position = position + vec4( 0.2,  0.2, 0.0, 0.0); // 4:top-right
    EmitVertex();
    gl_Position = position + vec4( 0.0,  0.4, 0.0, 0.0); // 5:top
    fColor = vec3(1.0, 1.0, 1.0);
    EmitVertex();
    EndPrimitive();
}

void main() {    
    build_house(gl_in[0].gl_Position);//ref4
}
```

## 2.Test1：house

### Shader.h
首先我们扩充一下shader类，以支持我们加载几何着色器
```cpp
//Header
Shader(const char* vertexPath, const char* fragmentPath, const char* geometryPath = nullptr);

//CppFile，只包括增加的GS相关的代码
	std::ifstream gShaderFile;
	gShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);
if (geometryPath)
{
	gShaderFile.open(geometryPath);
	std::stringstream gShaderStream;
	gShaderStream << gShaderFile.rdbuf();
	gShaderFile.close();
	geometryCode = gShaderStream.str();
}
unsigned int geometry;
if (geometryPath != nullptr)
{
	const char* gShaderCode = geometryCode.c_str();
	geometry = glCreateShader(GL_GEOMETRY_SHADER);
	glShaderSource(geometry, 1, &gShaderCode, NULL);
	glCompileShader(geometry);
	checkCompileErrors(geometry, "GEOMETRY");
}
if(geometryPath != nullptr)
	glAttachShader(ID, geometry);
	if(geometryPath != nullptr)
	glDeleteShader(geometry);
```

### GS_House
接下来是我们会在GS中接受4个顶点，对每个顶点进行处理生成一个房子
![412x408](assets/9.GeometryShader_image_1.png)
```cpp
#version 330 core
layout (points) in;
layout (triangle_strip, max_vertices = 5) out;

in VS_OUT
{
	vec3 color;
} gs_in[];

out vec3 fColor;

void build_house(vec4 position)
{
	fColor = gs_in[0].color; //gs_in[0], sincethese's only one input vertex

	gl_Position = position + vec4(-0.2, -0.2, 0.0, 0.0);  //bottomLeft
	EmitVertex();
	gl_Position = position + vec4( 0.2, -0.2, 0.0, 0.0);  //bootomRight
	EmitVertex();
	gl_Position = position + vec4(-0.2,  0.2, 0.0, 0.0);  //topLeft
	EmitVertex();
	gl_Position = position + vec4( 0.2,  0.2, 0.0, 0.0);  //topRight
	EmitVertex();
	gl_Position = position + vec4( 0.0,  0.4, 0.0, 0.0);  //top
	fColor = vec3(1.0, 1.0, 1.0);
	EmitVertex();

	EndPrimitive();
}

void main()
{
	build_house(gl_in[0].gl_Position);
}

```

### 测试
最后我们测试一下：

```cpp
 Shader shader("shaders/GS_House.vs", "shaders/GS_House.fs","shaders/GS_House.gs");

//用于生成房子的4个顶点
 float points[] = {
     -0.5f,  0.5f, 1.0f, 0.0f, 0.0f, // top-left
      0.5f,  0.5f, 0.0f, 1.0f, 0.0f, // top-right
      0.5f, -0.5f, 0.0f, 0.0f, 1.0f, // bottom-right
     -0.5f, -0.5f, 1.0f, 1.0f, 0.0f  // bottom-left
 };
 unsigned int VBO, VAO;
glGenBuffers(1, &VBO);
glGenVertexArrays(1, &VAO);
glBindVertexArray(VAO);
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(points), &points, GL_STATIC_DRAW);
glEnableVertexAttribArray(0);
glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), 0);
glEnableVertexAttribArray(1);
glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(2 * sizeof(float)));
glBindVertexArray(0);

while (!glfwWindowShouldClose(window))
{
    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
    glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    shader.use();
    glBindVertexArray(VAO);
    glDrawArrays(GL_POINTS, 0, 4);

    // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)
    // -------------------------------------------------------------------------------
    glfwSwapBuffers(window);
    glfwPollEvents();
}

```
![353x265](assets/9.GeometryShader_image_2.png)
线框模式下如下：
![405x304](assets/9.GeometryShader_image_3.png)


## 2.Test2：Model Explode
这个例子我们做个类似模型爆炸的效果，让模型的每个primitive都向四周法向爆炸

### GS_House
我们想要沿着三角形的法向量位移每个顶点，并且要计算的是垂直于primitive面的向量
思路如下：
- 已知primitive的三个顶点，通过两两点组成的两个不平行向量，进行叉乘获取
```cpp
vec3 GetNormal()
{
    vec3 a = vec3(gl_in[0].gl_Position) - vec3(gl_in[1].gl_Position);
    vec3 b = vec3(gl_in[2].gl_Position) - vec3(gl_in[1].gl_Position);
    return normalize(cross(a, b));
}
```

获得primitive面的法向之后，我们就可以编写对Position的Explode函数了
```cpp
vec4 explode(vec4 position, vec3 normal)
{
    float magnitude = 2.0;
    vec3 direction = normal * ((sin(time) + 1.0) / 2.0) * magnitude; 
    return position + vec4(direction, 0.0);
}
```

完整的GS代码为下：
```cpp
#version 330 core
layout (triangles) in;
layout (triangle_strip, max_vertices = 3) out;

in VS_OUT {
    vec2 texCoords;
} gs_in[];

out vec2 TexCoords; 

uniform float time;

vec4 explode(vec4 position, vec3 normal)
{
    float magnitude = 2.0;
    vec3 direction = normal * ((sin(time) + 1.0) / 2.0) * magnitude; 
    return position + vec4(direction, 0.0);
}

vec3 GetNormal()
{
    vec3 a = vec3(gl_in[0].gl_Position) - vec3(gl_in[1].gl_Position);
    vec3 b = vec3(gl_in[2].gl_Position) - vec3(gl_in[1].gl_Position);
    return normalize(cross(a, b));
}

void main() {    
    vec3 normal = GetNormal();

    gl_Position = explode(gl_in[0].gl_Position, normal);
    TexCoords = gs_in[0].texCoords;
    EmitVertex();
    gl_Position = explode(gl_in[1].gl_Position, normal);
    TexCoords = gs_in[1].texCoords;
    EmitVertex();
    gl_Position = explode(gl_in[2].gl_Position, normal);
    TexCoords = gs_in[2].texCoords;
    EmitVertex();
    EndPrimitive();
}
```

![451x303](assets/9.GeometryShader_image_4.png)


## 3.Test3：法线可视化
这个例子我们将使用一个单独的shader绘制法线朝向，使用GS生成法线方向的线

我们先在VS中将顶点法线转换到ViewSpace，输出给GS
VS：
```cpp
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;

out VS_OUT {
    vec3 normal;
} vs_out;

uniform mat4 view;
uniform mat4 model;

void main()
{
    mat3 normalMatrix = mat3(transpose(inverse(view * model)));
    vs_out.normal = vec3(vec4(normalMatrix * aNormal, 0.0));
    gl_Position = view * model * vec4(aPos, 1.0); 
}
```

GS中，将输出primitive设置为line，接受VS输入进来的顶点位置和ViewSpace法线
我们对于每个顶点在法线方向生成一条线，然后再统一用ProjectionMatrix转换到ClipSpace
GS:
```cpp
#version 330 core
layout (triangles) in;
layout (line_strip, max_vertices = 6) out;

in VS_OUT {
    vec3 normal;
} gs_in[];

const float MAGNITUDE = 0.2;

uniform mat4 projection;

void GenerateLine(int index)
{
    gl_Position = projection * gl_in[index].gl_Position;
    EmitVertex();
    gl_Position = projection * (gl_in[index].gl_Position + vec4(gs_in[index].normal, 0.0) * MAGNITUDE);
    EmitVertex();
    EndPrimitive();
}

void main()
{
    GenerateLine(0); // first vertex normal
    GenerateLine(1); // second vertex normal
    GenerateLine(2); // third vertex normal
}
```

FS中只是简单的输出一个颜色即可

在CPU端，我们用以下的逻辑进行绘制
```cpp
//ModelDraw
...
 testModel.Draw(model_loadShader);
 
 //NormalVisualize
 normalShader.use();
 normalShader.setMat4("projection", projection);
 normalShader.setMat4("view", view);
 normalShader.setMat4("model", model);

 testModel.Draw(normalShader);
```
![401x459](assets/9.GeometryShader_image_5.png)