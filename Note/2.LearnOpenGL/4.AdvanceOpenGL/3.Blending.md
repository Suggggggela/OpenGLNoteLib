
## 1.透明度
现实是有半透明的物体的，比如玻璃，CG中模拟半透使用的是第四个通道A，也就是Alpha来实现
透明度也是0~1的值，对于这个值，我们可以采取两种做法：判断丢弃还是保留、进行混合

## 2.AlphaClip
AlphaClip是通过透明度判断片元是否保留的做法，常用在草等物体上
操作也很简单，采样具有A通道的贴图，根据Alpha进行discard(丢弃)

```cpp
vec4 texColor = texture(texture1, TexCoords); 
if(texColor.a < 0.1) 
    discard; 
FragColor = texColor;
```

在使用AlphaClip时，如果贴图的warp设置为Repeat可能会出现溢色的情况，建议设置为ClampToEdge

## 3.AlphaBlend
AlphaClip并不能实现半透的效果，要想实现这种效果，我们就需要用到混合技术

**混合方程BlendFunction**描述了如何进行混合操作
![544x176](assets/3.Blending_image_1.png)
其中：
- C = Color，颜色
- F = Factor， 乘数因子，用来确定颜色的占比，两个F加起来=1
- SourceColor为贴图的颜色，源颜色
- DestinationColor为目标颜色，当前ColorBuffer中的颜色

所以我们要做的就是指定混合的两个因子，对贴图和ColorBuffer的颜色进行混合
比如我们要将一个Alpha为0.6绿色方块和已经存在的红色方块混合，那么就是下边这样：
![342x114](assets/3.Blending_image_2.png)
![205x169](assets/3.Blending_image_3.png)

在OpenGL中，指定混合方式的函数为`glBlendFunc(srcFac, DesFac)`
两个参数分别为源颜色和目标颜色的乘数因子，它们是枚举类型，可以有以下选择：

|选项|值|
|---|---|
|`GL_ZERO`|因子等于0|
|`GL_ONE`|因子等于1|
|`GL_SRC_COLOR`|因子等于源颜色向量C¯source|
|`GL_ONE_MINUS_SRC_COLOR`|因子等于1−C¯source|
|`GL_DST_COLOR`|因子等于目标颜色向量C¯destination|
|`GL_ONE_MINUS_DST_COLOR`|因子等于1−C¯destination|
|`GL_SRC_ALPHA`|因子等于C¯source的alpha分量|
|`GL_ONE_MINUS_SRC_ALPHA`|因子等于1− C¯source的alpha分量|
|`GL_DST_ALPHA`|因子等于C¯destination的alpha分量|
|`GL_ONE_MINUS_DST_ALPHA`|因子等于1− C¯destination的alpha分量|
|`GL_CONSTANT_COLOR`|因子等于常数颜色向量C¯constant|
|`GL_ONE_MINUS_CONSTANT_COLOR`|因子等于1−C¯constant|
|`GL_CONSTANT_ALPHA`|因子等于C¯constant的alpha分量|
|`GL_ONE_MINUS_CONSTANT_ALPHA`|因子等于1− C¯constant的alpha分量|
我们上边的例子就是：
```cpp
glEnable(GL_BLEND);
glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);//0.6， 1-0.6
```


另外，OpenGL还支持我们自定义混合的算法，我们不止可以使用加算，还可以自定义以下内容：
- glBlendFuncSeparate允许分别设置源和目标的颜色与 alpha 通道的混合方式
- glBlendEquation 指定运算法

**glBlendFuncSeparate(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);**
- sfactorRGB: 用于源颜色的混合因子（源的颜色部分）
    
- dfactorRGB: 用于目标颜色的混合因子（目标的颜色部分）
    
- sfactorAlpha: 用于源 alpha 的混合因子（源的透明度部分）
    
- dfactorAlpha: 用于目标 alpha 的混合因子（目标的透明度部分）


**glBlendEquation(GLenum mode)**
- GL_FUNC_ADD：默认选项，将两个分量相加：C¯result=Src+Dst。
- GL_FUNC_SUBTRACT：将两个分量相减： C¯result=Src−Dst。
- GL_FUNC_REVERSE_SUBTRACT：将两个分量相减，但顺序相反：C¯result=Dst−Src。
- GL_MIN：取两个分量中的最小值：C¯result=min(Dst,Src)。
- GL_MAX：取两个分量中的最大值：C¯result=max(Dst,Src)。

## 4.渲染排序
涉及到半透明渲染，就要说下渲染顺序了
顺序如下：
- 对于不透明物体，由近到远
- 对于半透明物体，由远到近
- 对于半透和不透物体，先绘制不透明物体再绘制半透明物体

对于物体的远近，我们可用通过和相机的距离进行排序
```cpp
std::map<float, glm::vec3> sorted;
for (unsigned int i = 0; i < windows.size(); i++)
{
    float distance = glm::length(camera.Position - windows[i]);
    sorted[distance] = windows[i];
}

```

在绘制时，根据之前的排序进行绘制
```cpp
for (std::map<float, glm::vec3>::reverse_iterator it = sorted.rbegin(); it != sorted.rend(); ++it)
{
    model = glm::mat4(1.0f);
    model = glm::translate(model, it->second);
    abShader.setMat4("model", model);
    glDrawArrays(GL_TRIANGLES, 0, 6);
}
```

## 测试
我们测试一下AlphaClip和AlphaBlend的效果

```cpp
//渲染前配置
glEnable(GL_DEPTH_TEST);
glEnable(GL_BLEND);
glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);//AlphaBlend

//sort
...
//渲染
...
```

![495x355](assets/3.Blending_image_4.png)
