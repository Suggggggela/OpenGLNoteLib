
## 1.Stencil 模板值
模板测试位于深度测试之后，深度测试之后保留的Fragment会进行模板测试
模板和深度差不多，每个Fragment也有模板值，它一般是8位的，也就是0~256


## 2.Stencil Test 模板测试
### 模板测试
进行模板测试时，当某个Fragment有某个模板值时，我们就能知道了，然后你就可以决定它是保留还是丢弃
![[assets/2.Stencil Test_image_1.png|474x171]]

进行模板测试的大体流程如下：
- 开启模板测试
- 渲染，更新Stencil Buffer
- 禁用深度测试
- 渲染其他物体，根据StencilBuffer中的内容决定当前Fragment的情况

当然，模板值默认会被clear为0, 第一次渲染你可以根据默认值决定

```cpp
glEnable(GL_STENCIL_TEST);
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
```



### 模板测试函数

#### glStencilMask
它允许设置一个位掩码（bitMask），然后根据要写入的模板值进行AND运算
默认情况下设置biMask的所有位都是1，不影响输出
如果设置为0x00，那么所有写入的模板值都会变成0
```cpp
glStencilMask(0xFF); // 每一位写入模板缓冲时都保持原样 
glStencilMask(0x00); // 每一位在写入模板缓冲时都会变成0（禁用写入）

```

我们也可以通过上边的函数决定Fragment的去留，共有两个函数来配置
#### glStencilFunc(GLenum func, GLint ref, GLuint mask)
这个函数描述**应该对StencilBuffer的内容做什么**
- func 模板测试实际运算，它会应用到已经存在的模板值和ref值上
    - GL_NEVER、GL_LESS、GL_LEQUAL、GL_GREATER、GL_GEQUAL、GL_EQUAL、GL_NOTEQUAL和GL_ALWAYS
- ref 模板测试参考值，测试时会和这个值进行比较
- mask 设置的bitMask， 它会对已存的模板值和ref进行AND运算，默认为每一位都是1

简单的例子如下：
```cpp
glStencilFunc(GL_EQUAL, 1, 0xFF)
//如果Fragment的模板值=1，就会绘制，否则丢弃
```

#### glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)
这个函数描述**如何更新StencilBuffer**
- sfail：模板测试失败时如何做
- dpfail：模板测试通过，深度测试失败时如何做
- dppass：深度和模板测试都通过时如何做

默认情况下为(GL_KEEP, GL_KEEP, GL_KEEP)，既无论测试结果如何都保留，不更新模板Buffer

|行为|描述|
|---|---|
|GL_KEEP|保持当前储存的模板值|
|GL_ZERO|将模板值设置为0|
|GL_REPLACE|将模板值设置为glStencilFunc函数设置的`ref`值|
|GL_INCR|如果模板值小于最大值则将模板值加1|
|GL_INCR_WRAP|与GL_INCR一样，但如果模板值超过了最大值则归零|
|GL_DECR|如果模板值大于最小值则将模板值减1|
|GL_DECR_WRAP|与GL_DECR一样，但如果模板值小于0则将其设置为最大值|
|GL_INVERT|按位翻转当前的模板缓冲值|

## 例子：通过模板绘制描边
我们可以使用模板测试绘制物体的描边，思路大致如下：
- 开启模板写入，函数设置为always，绘制物体，这时物体的模板缓冲会更新为1
- 关闭模板写入，关闭深度测试，放大物体，再次绘制物体(fs为纯色)，模板函数设置为模板≠1时保留



```cpp
//绘制前配置
glEnable(GL_DEPTH_TEST);
glDepthFunc(GL_LESS);
glEnable(GL_STENCIL_TEST);
glStencilFunc(GL_NOTEQUAL, 1, 0xFF);//如果不等于1，则通过
glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);//如果深度和模板测试都通过，则将模板值设置为ref1

//绘制
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);

glStencilMask(0x00); //绘制地面不更新模板
normalShader.use();
DrawFloor()

glStencilFunc(GL_ALWAYS, 1, 0xFF);//绘制物体，更新模板为1
glStencilMask(0xFF);
DrawTwoContainers();

glStencilFunc(GL_NOTEQUAL, 1, 0xFF);//模板值不为1时绘制放大后的物体，形成描边
glStencilMask(0x00);
glDisable(GL_DEPTH_TEST);
shaderSingleColor.use();
DrawTwoScaledUpContainers();

glStencilMask(0xFF);
glEnable(GL_DEPTH_TEST);

```



![[assets/2.Stencil Test_image_2.png]]