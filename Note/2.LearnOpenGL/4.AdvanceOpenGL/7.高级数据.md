这几节下来我们已经接触了很多OpenGL的数据概率，这节我们做一下梳理

## 1.Buffer
### Buffer 和 BufferTarget
OpenGL中的Buffer本质上就是管理一块内存的对象
当我们将Buffer绑定到各种BufferTarget上时，就赋予了它意义，比如GL_ARRAY_BUFFER、GL_ELEMENT_BUFFER
OpenGL内部会为每个Target存储一个Buffer，根据Target种类的不同，处理Buffer的方式也有用区别

### 填充Buffer
#### glBufferData
前边的内容我们使用`glBufferData`来填充Buffer，它会分配给Buffer一段内存并填充data，当然我们可以先给data参数填null来先分配内存

#### glBufferSubData
除了上述的方法，我们也可以使用`glBufferSubData`来填充**Buffer的特定区域**，它可以指定一个offset来确认从何处开始填充
```cpp
glBufferSubData(GL_ARRAY_BUFFER, 24, sizeof(data), &data); // 范围： [24, 24 + sizeof(data)]
//parameter:BufferTarget, offset, datasize, dataPointer
```

#### glMapBuffer
我们还可以通过请求Buffer内存Pointer的方法将数据直接复制到Buffer中
调用glMapBuffer会返回指定BufferTarget绑定Buffer的pointer
```cpp
float data[] = { 0.5f, 1.0f, -0.35f ... }; 
glBindBuffer(GL_ARRAY_BUFFER, buffer); 
void *ptr = glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY); // 获取指针 
memcpy(ptr, data, sizeof(data)); // 复制数据到内存 

glUnmapBuffer(GL_ARRAY_BUFFER);
// 记得告诉OpenGL我们不再需要这个指针了 
//如果成功的将data映射到buffer中，这个函数会返回GL_TRUE
```

## 2. Batching vertex attributes
之前我们通过`glBufferData`填充Buffer数据后，再通过`glVertexAttribPointer`指定VertexBufferLayout
实际上是将VertexBuffer中的Attribute进行了**交错处理**
具像点说，就是Position1|Normal1|UV1|Position2|Normal2|UV2这样的

现在知道了`glBufferSubData`后，我们就可以用另一种方式组织：采用分批的方式
类似Positon1|Positon2|Normal1|Normal2|UV1|UV2这样

```cpp
float positions[] = { ... }; 
float normals[] = { ... }; 
float tex[] = { ... }; 

//--填充缓冲 
glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(positions), &positions); 
glBufferSubData(GL_ARRAY_BUFFER, sizeof(positions), sizeof(normals), &normals); 
glBufferSubData(GL_ARRAY_BUFFER, sizeof(positions) + sizeof(normals), sizeof(tex), &tex);
//Parameter:BufferTarget,offset,sizeofData, dataPointer


//--指定VBLayout
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), 0); 
glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)(sizeof(positions))); 
glVertexAttribPointer( 2, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)(sizeof(positions) + sizeof(normals)));
```

当然这只是另一种指定VertexAttribute的方法，实际中，我们还是推荐使用交错处理的方法
因为这样一来，VS运行所需要的VertexAttribute在内存中时紧密对齐的

## 3、CopyBuffer

当我们想要复制Buffer中的数据到另一个Buffer中时，`glCopyBufferSubData`就上场了

```cpp
void glCopyBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size);
//比如，我们可以将VERTEX_ARRAY_BUFFER的数据复制到VERTEX_ELEMENT_ARRAY_BUFFER中
glCopyBufferSubData(VERTEX_ARRAY_BUFFER, VERTEX_ELEMENT_ARRAY_BUFFER, 0, 0, sizeof(vertexData));
```

但是Buffer不是唯一的，比如我们想将VAO1复制到VAO2中怎么办呢？
这其实就和刚学程序的时候如何将B的数据复制给A一样，需要第三个变量来存储中间数据
OpenGL提供的中间数据存放对象是`GL_COPY_READ_BUFFER`个`GL_COPY_WRITE_BUFFER`

我们直接看例子
```cpp
glBindBuffer(GL_COPY_READ_BUFFER, vao1); 
glBindBuffer(GL_COPY_WRITE_BUFFER, vao2); 
glCopyBufferSubData(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, 0, 0, sizeof(vertexData));
```

当然你也可以直接只使用一个中间Buffer，直接把VAO2绑定到WRITEBUFFER写入到VAO1
```cpp
glBindBuffer(GL_ARRAY_BUFFER, vao1); 
glBindBuffer(GL_COPY_WRITE_BUFFER, vao2); 
glCopyBufferSubData(GL_ARRAY_BUFFER, GL_COPY_WRITE_BUFFER, 0, 0, sizeof(vertexData));
```
