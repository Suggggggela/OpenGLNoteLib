
早期的游戏没有抗锯齿技术，具体的表现就是麻麻赖赖的，有各种锯齿
这节我们整理一些抗锯齿的内容

## 0.为什么会有锯齿
锯齿是在**光栅化**阶段产生的，光栅化处于Pipeline得到屏幕空间顶点信息之后，它会将这些点最终转化为屏幕上显示的像素
关于光栅化，一般可以认为有3个阶段：
- Primitive Assembly，图元组装，这个阶段会将顶点组装为一个个三角形
- Triangle Traversal，三角形遍历，通过采样点确定哪些像素被三角形覆盖（如果被覆盖，就应该被渲染）
- Fragment Shader，对确定要渲染的像素进行着色

我们可以看这个视频
![](assets/11.Anti%20Aliasing_video_1.mp4)

正常情况下1个像素只有1个采样点，采样点用来决定这个它所在像素上是否被顶点组成的三角形覆盖
这时就会出现这样的情况：某个像素是在一个三角形的边缘，但是它的采样点并没有被三角形覆盖
类似下边这样：
![[assets/11.Anti Aliasing_image_1.png|548x275]]

因为上边这样情况，锯齿就产生了

## 1.SSAA - Super Sample AA
SSAA是比较早期的抗锯齿方式，全名为超采样抗锯齿
顾名思义，它会使用比正常分辨率更高的分辨率来渲染，当输出到FrameBuffer时再降采样到正常分辨率
但是这样做的缺点也很简单，性能太不友好了


## 2.MSAA - MultipleSample AA
接下来是MSAA，它是现代比较常用的抗锯齿方法，全名为多重采样抗锯齿
多重采样指的是**每个像素采用4个采样点**，而非传统的像素中心1个采样点（多说一句，采样点可以是任意的）
![[assets/11.Anti Aliasing_image_2.png|441x170]]

上述是三角形遍历的工作，接下来我们会根据上述的结果进行着色
着色逻辑如下：
            1.以单个像素为单位，无论三角形覆盖了多少个采样点，都只运行一次片元着色
            2.使用插值的方式进行着色
            3.使用更大的Depth/StencilBuffer确定子采样点的覆盖率（这两个按各自采样点存储，并且也会被插值。子采样点越多，需要的Buffer越大）
            4.被覆盖的子采样点数量决定了着色对FrameBuffer的影响程度（比如2个采样点，那么应该有一半颜色和FrameBuffer进行混合）
![[assets/11.Anti Aliasing_image_3.png|519x258]]


## 3.OpenGL中的MSAA
### 1.使用自带MSAA

```cpp
glfwWindowHint(GLFW_SAMPLES, 4);

glEnable(GL_MULTISAMPLE);// enabled by default on some drivers, but not all so always enable to make sure

```

![[assets/11.Anti Aliasing_image_4.png|678x281]]


### 2.自定义off-screen MASS
我们可以自己进行MSAA，然后对FrameBuffer内容进行后期测试

#### FrameBuffer
和FrameBuffer那节相同，我们可以使用TextureAttachment或者FrameBufferObject
```cpp
//-------TextureAttachment------------
glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, tex); 
glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, samples, GL_RGB, width, height, GL_TRUE); 
glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, 0);


//-------FrameBufferObject-----------
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, tex, 0);
```

#### Render to MultipleSample FrameBuffer
当我们将多重采样的FrameBufferObject绑定时，任何绘制的操作就都应用了，但是这个这时的FrameBuffer比较特殊，无法直接使用进行其他操作，比如shader中采样
多重次采样的image包含的信息比普通多，因此我们需要对image进行缩放或者解析
解析一般用`glBlitFrameBuffer`  [ref](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlitFramebuffer.xhtml)，Blit指的是是图像数据传输
它可以将一个区域从一个FrameBuffer复制到另一个FrameBuffer，同时解析多重采样的buffer
glBlitFrameBuffer会将一个由4个ScreenSpace坐标定义的源区域(src)复制到同样定义的目标(dst)区域中
```cpp
//glad中的源码
void (APIENTRYP PFNGLBLITFRAMEBUFFERPROC)(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
```

当我们绑定GL_FRAMEBUFFER时，意味着同时绑定着READ和DRAW两个BUFFER
我们可以将FrameBuffer分开绑定到上边两个BUFFER，glBlitFrameBuffer会根据这两个Target决定哪个是src哪个是dst
```cpp
glBindFramebuffer(GL_READ_FRAMEBUFFER, multisampledFBO); 
glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0); 
glBlitFramebuffer(0, 0, width, height, 0, 0, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST);
```

#### PostProcess for MultipleSample Texture
上边我们说过，多重采样的FrameBuffer比较特殊，无法进行shader采样
如果我们想对多重采样的FrameBuffer做后处理怎么办呢？
        -Answer：可以将这个FrameBuffer Blit到一个没有多重采样的FrameBufferObject上，然后进行后期处理
        这样就相当于多生成了一个FBO，伪代码如下：
```cpp
unsigned int msFBO = CreateFBOWithMultiSampledAttachments(); 
// 使用普通的纹理颜色附件创建一个新的FBO 
... 
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, screenTexture, 0); 
... 
while(!glfwWindowShouldClose(window)) 
{ 
    ... 
    glBindFramebuffer(msFBO); 
    ClearFrameBuffer(); 
    DrawScene(); 
    
    // 将多重采样缓冲还原到中介FBO上 
    glBindFramebuffer(GL_READ_FRAMEBUFFER, msFBO); 
    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, intermediateFBO); 
    glBlitFramebuffer(0, 0, width, height, 0, 0, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST); 
    
    // 现在场景是一个2D纹理缓冲，可以将这个图像用来后期处理 
    glBindFramebuffer(GL_FRAMEBUFFER, 0); 
    ClearFramebuffer(); 
    glBindTexture(GL_TEXTURE_2D, screenTexture); 
    DrawPostProcessingQuad(); 
    ... 
}
```

#### custom AA
经过多重采样的image不进行解析直接传入shader中其实也是可以的，这样你就可以进行自定义的抗锯齿了
GLSL提供了这样的选项，来支持对image的每个子样本进行采样
获取子样本的颜色可以使用以下这样：

```cpp
uniform sampler2DMS screenTextuerMS;

vec4 colorSample = texelFetch(screenTextureMS, TexCoords, 3); // 第4个子样本
```


## 4.测试
我们使用自定义后期的方式测试MSAA
shader没什么特别的，物体就是flatcolor，后期就是转为灰度

主要看CPU端设置
```cpp
glEnable(GL_DEPTH_TEST);

Shader shader("shaders/MSAA.vs", "shaders/MSAA.fs");
Shader screenShader("shaders/MSAA_POST.vs", "shaders/MSAA_POST.fs");

//Cube and ScreenQuad RenderData
...

//-------------MSAA framebuffer-----------------------
unsigned int framebuffer;
glGenFramebuffers(1, &framebuffer);
glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);

//multisample color attachment texture
unsigned int textureColorBufferMultiSampled;
glGenTextures(1, &textureColorBufferMultiSampled);
glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, textureColorBufferMultiSampled);//注意traget
glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, 4, GL_RGB, SCR_WIDTH, SCR_HEIGHT, GL_TRUE);//parameter2: samples
glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, 0);
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, textureColorBufferMultiSampled, 0); //注意tex类型

//create depth stencil renderbuffer object
unsigned int rbo;
glGenRenderbuffers(1, &rbo);
glBindRenderbuffer(GL_RENDERBUFFER, rbo);
glRenderbufferStorageMultisample(GL_RENDERBUFFER, 4, GL_DEPTH24_STENCIL8, SCR_WIDTH, SCR_HEIGHT);
glBindRenderbuffer(GL_RENDERBUFFER, 0);
glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo);

if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
    std::cout << "ERROR::FRAMEBUFFER:: Framebuffer is not complete!" << std::endl;
glBindFramebuffer(GL_FRAMEBUFFER, 0);

//-------------Post-processing framebuffer-----------------------
unsigned int intermediateFBO;
glGenFramebuffers(1, &intermediateFBO);
glBindFramebuffer(GL_FRAMEBUFFER, intermediateFBO);
unsigned int screenTexture;
glGenTextures(1, &screenTexture);
glBindTexture(GL_TEXTURE_2D, screenTexture);
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, screenTexture, 0);

if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
    std::cout << "ERROR::FRAMEBUFFER:: Intermediate framebuffer is not complete!" << std::endl;
glBindFramebuffer(GL_FRAMEBUFFER, 0);

screenShader.use();
screenShader.setInt("screenTexture", 0);

while(rendering)
{
    glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

//draw sceme in multisample framebuffer
glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);
glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
glEnable(GL_DEPTH_TEST);

shader.use();
glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 1000.0f);
shader.setMat4("projection", projection);
shader.setMat4("view", camera.GetViewMatrix());
shader.setMat4("model", glm::mat4(1.0f));
glBindVertexArray(cubeVAO);
glDrawArrays(GL_TRIANGLES, 0, 36);

//blit multisample color buffer to normal color buffer
glBindFramebuffer(GL_READ_FRAMEBUFFER, framebuffer);
glBindFramebuffer(GL_DRAW_FRAMEBUFFER, intermediateFBO);
glBlitFramebuffer(0, 0, SCR_WIDTH, SCR_HEIGHT, 0, 0, SCR_WIDTH, SCR_HEIGHT, GL_COLOR_BUFFER_BIT, GL_NEAREST);

//render post quad
glBindFramebuffer(GL_FRAMEBUFFER, 0);
glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
glClear(GL_COLOR_BUFFER_BIT);
glDisable(GL_DEPTH_TEST);
screenShader.use();
glBindVertexArray(quadVAO);
glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_2D, screenTexture); // use the now resolved color attachment as the quad's texture
glDrawArrays(GL_TRIANGLES, 0, 6);
}
```
