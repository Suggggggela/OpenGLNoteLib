CubeMap常用于环境映射，天空盒等等
这节我们看看如何使用


## 1.CubeMap
CubeMap是包含了6个2DTexture的纹理，这六个Texture代表立方体的6个面
有一张这样的纹理，我们就可以通过一个方向向量进行索引和采样，类似下边这样：
![[assets/6.CubeMap_image_1.png|276x237]]

### 创建CubeMap
首先用一个数据结构存放CubeMap的六个面贴图

```cpp
vector<std::string> faces
{
    "resources/textures/skybox/right.jpg",
    "resources/textures/skybox/left.jpg",
    "resources/textures/skybox/top.jpg",
    "resources/textures/skybox/bottom.jpg",
    "resources/textures/skybox/front.jpg",
    "resources/textures/skybox/back.jpg",
};

```

创建CubeMap
```cpp
unsigned int textureID;
    glGenTextures(1, &textureID);
    glBindTexture(GL_TEXTURE_CUBE_MAP, textureID);

```

遍历6个面
我们使用glTexImage2D将数据存放进去
GL_TEXTURE_CUBE_MAP_POSITIVE_X是枚举类型，它代表有右方向的面，其它枚举如下：

|纹理目标|方位|
|---|---|
|`GL_TEXTURE_CUBE_MAP_POSITIVE_X`|右|
|`GL_TEXTURE_CUBE_MAP_NEGATIVE_X`|左|
|`GL_TEXTURE_CUBE_MAP_POSITIVE_Y`|上|
|`GL_TEXTURE_CUBE_MAP_NEGATIVE_Y`|下|
|`GL_TEXTURE_CUBE_MAP_POSITIVE_Z`|后|
|`GL_TEXTURE_CUBE_MAP_NEGATIVE_Z`|前|

```cpp
    int width, height, nrComponents;
    //遍历6个面
    for (unsigned int i = 0; i < faces.size(); i++)
    {
        unsigned char* data = stbi_load(faces[i].c_str(), &width, &height, &nrComponents, 0);
        if (data)
        {
            //GL_TEXTURE_CUBE_MAP_POSITIVE_X是枚举类型
            glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);
            stbi_image_free(data);
        }
        else
        {
            std::cout << "Cubemap texture failed to load at path: " << faces[i] << std::endl;
            stbi_image_free(data);
        }
    }
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);

```

### 采样CubeMap
将数据在CPU端读取完毕后，我们就可以通过uniform发送给GPU然后在shader中进行采样了

```cpp
in vec3 textureDir;
uniform samplerCube cubemap;

void main() { FragColor = texture(cubemap, textureDir); }
```

## 2.SkyBox
### 加载CubeMap
在上边部分我们已经解决了如何加载CubeMap，现在可以将它封装成一个函数
```cpp
// loads a cubemap texture from 6 individual texture faces
// order:
// +X (right)
// -X (left)
// +Y (top)
// -Y (bottom)
// +Z (front) 
// -Z (back)
// -------------------------------------------------------
unsigned int loadCubemap(vector<std::string> faces)
{
    unsigned int textureID;
    glGenTextures(1, &textureID);
    glBindTexture(GL_TEXTURE_CUBE_MAP, textureID);

    int width, height, nrComponents;
    for (unsigned int i = 0; i < faces.size(); i++)
    {
        unsigned char *data = stbi_load(faces[i].c_str(), &width, &height, &nrComponents, 0);
        if (data)
        {
            glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);
            stbi_image_free(data);
        }
        else
        {
            std::cout << "Cubemap texture failed to load at path: " << faces[i] << std::endl;
            stbi_image_free(data);
        }
    }
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);

    return textureID;
}

```


```cpp
vector<std::string> faces
{
    "textures/skybox/skybox1/right.jpg",
    "textures/skybox/skybox1/left.jpg",
    "textures/skybox/skybox1/top.jpg",
    "textures/skybox/skybox1/bottom.jpg",
    "textures/skybox/skybox1/front.jpg",
    "textures/skybox/skybox1/back.jpg"
};
unsigned int cubemapTexture = loadCubemap(faces);

```

### 显示 Skybox
我们将CubeMap映射到一个单位为1的立方体上
首先写一下它的Vertex数据
```cpp
float skyboxVertices[] = {
    // positions          
    -1.0f,  1.0f, -1.0f,
    -1.0f, -1.0f, -1.0f,
     1.0f, -1.0f, -1.0f,
     1.0f, -1.0f, -1.0f,
     1.0f,  1.0f, -1.0f,
    -1.0f,  1.0f, -1.0f,

    -1.0f, -1.0f,  1.0f,
    -1.0f, -1.0f, -1.0f,
    -1.0f,  1.0f, -1.0f,
    -1.0f,  1.0f, -1.0f,
    -1.0f,  1.0f,  1.0f,
    -1.0f, -1.0f,  1.0f,

     1.0f, -1.0f, -1.0f,
     1.0f, -1.0f,  1.0f,
     1.0f,  1.0f,  1.0f,
     1.0f,  1.0f,  1.0f,
     1.0f,  1.0f, -1.0f,
     1.0f, -1.0f, -1.0f,

    -1.0f, -1.0f,  1.0f,
    -1.0f,  1.0f,  1.0f,
     1.0f,  1.0f,  1.0f,
     1.0f,  1.0f,  1.0f,
     1.0f, -1.0f,  1.0f,
    -1.0f, -1.0f,  1.0f,

    -1.0f,  1.0f, -1.0f,
     1.0f,  1.0f, -1.0f,
     1.0f,  1.0f,  1.0f,
     1.0f,  1.0f,  1.0f,
    -1.0f,  1.0f,  1.0f,
    -1.0f,  1.0f, -1.0f,

    -1.0f, -1.0f, -1.0f,
    -1.0f, -1.0f,  1.0f,
     1.0f, -1.0f, -1.0f,
     1.0f, -1.0f, -1.0f,
    -1.0f, -1.0f,  1.0f,
     1.0f, -1.0f,  1.0f
};

```

接下来我们使用立方体的Position当做uv采样CubeMap
```cpp
//vs
#version 330 core
layout (location = 0) in vec2 aPos;
layout (location = 1) in vec2 aTexCoords;

out vec2 TexCoords;

void main()
{
    TexCoords = aTexCoords;
    gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0); 
}  

//fs
#version 330 core
out vec4 FragColor;

in vec3 TexCoords;

uniform samplerCube skybox;

void main()
{    
    FragColor = texture(skybox, TexCoords);
}
```

接下来我们在CPU端绘制
这时又到了老生常谈的绘制顺序问题，我们另起一小节进行讲解

### 优化Skybox绘制
首先我们考虑一下在什么时候绘制skybox
直觉的想法是最先绘制，因为skybox应该在所有物体的后面
但是上边的做法性能不太好，就像我们绘制不透明物体时，应该从前往后绘制，这样能避免overdraw

这里我们选择最后绘制skybox，通过一些办法完成：
- 正常绘制场景，这时DepthBuffer中有场景的Depth信息
- 在skybox的vs修改FragmentPosition的z分量为w，这样在NDC空间经过透视除法后，它的z将一直为1，也就是它的深度一直是1（最远）
- 绘制Skybox前调整DepthTestFunc为LessEqual，渲染那些深度小于或等于当前像素深度的片元，确保Skybox总是绘制在场景的最远处，并且不会覆盖其他物体

```cpp
//VS
vec4 pos = projection * view * vec4(aPos, 1.0); 
gl_Position = pos.xyww; //修改z为w，以保持NDCSpace z = 1


//CPU端记得在绘制skybox前将DepthTestFunc改为LessEq
glDepthFunc(GL_LEQUAL);
```

```cpp
cubeMapShader.use();
cubeMapShader.setInt("skybox", 0);

skyboxShader.use();
skyboxShader.setInt("skybox", 0);

while (!glfwWindowShouldClose(window))
{
    //Draw Scene
    ...

    //Draw Skybox
    //------------skybox----------------
    glDepthFunc(GL_LEQUAL);
    skyboxShader.use();
    //只取ViewMatrix的3x3部分，丢弃平移部分，这样sky就不会随着相机位置移动
    view = glm::mat4(glm::mat3(camera.GetViewMatrix()));
    skyboxShader.setMat4("view", view);
    skyboxShader.setMat4("projection", projection);
    glBindVertexArray(skyboxVAO);
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_CUBE_MAP, cubemapTexture);
    glDrawArrays(GL_TRIANGLES, 0, 36);
    glBindVertexArray(0);
    glDepthFunc(GL_LESS);
}
```



## 3.环境映射 EnvironmentMapping
在说完cubemap常用的Skybox之后，说说环境映射
既然我们已经拥有了“天空”，那么对于反射和折射的物体，是不是可以表现出这个环境呢？
答案是当然

### 反射
反射是光照向物体，物体反射到观察者方向的表现
我们之前Blinn-Phong的高光项就使用了这一原理
- I = ViewDir
- N = NormalDir
- R  = ReflectDir
![[assets/6.CubeMap_image_2.png|334x298]]
我们将计算出的R向量作为index去采样cubemap，得到的结果就是skybox的反射结果
```cpp
//VS
layout (location = 0) in vec3 aPos; 
layout (location = 1) in vec3 aNormal; 
out vec3 Normal; 
out vec3 Position; 
uniform mat4 model; 
uniform mat4 view; 
uniform mat4 projection; 
void main() 
{ 
    Normal = mat3(transpose(inverse(model))) * aNormal; //Use Normal Matrix transform Normal to WorldSpace
    Position = vec3(model * vec4(aPos, 1.0));  //WorldSpacePostion
    gl_Position = projection * view * model * vec4(aPos, 1.0); 
}

//FS
in vec3 Normal;
in vec3 Position;

uniform vec3 cameraPos;
uniform samplerCube skybox;

void main()
{    
    vec3 I = normalize(Position - cameraPos);
    vec3 R = reflect(I, normalize(Normal));
    FragColor = vec4(texture(skybox, R).rgb, 1.0);
}
```


### 折射
折射是光线在传播的过程中由于介质的改变而产生了方向的变化，经过不同的介质后，光线不再是比直的传播而是弯曲了一点
这种现象最常见的是水
折射的实现原理是通过Snell定律描述的：
- I = ViewDir
- N = NormalDir
- R = RefractDir
![[assets/6.CubeMap_image_3.png|390x296]]
```cpp
//Refract
float ratio = 1.00 / 1.52;
vec3 Refract = refract(I, normalize(Normal), ratio);
vec3 refractColor = texture(skybox, Refract).rgb;
```


### Fresnel
菲涅尔是dot(n，v)的结果，常用于边缘光的计算
我们也可以用Fresnel作为Alpha对反射和折射进行混合
```cpp
//fresnel
float fresnel = clamp(pow(1.0 - dot(normalize(Normal), I), 5.0),0,1);
vec3 result = mix(refractColor, reflectColor, fresnel);
```

![[assets/6.CubeMap_image_4.png|481x442]]

## 4.动态环境贴图
当前我们采样skybox cubemap作为环境贴图的情况都是静态的，也就是说cubemap中不包括动态物体

如果通过FrameBuffer创建6个不同朝向的场景纹理，并且在renderloop中更新它，就可以做出动态的环境贴图
但是这样的性能消耗实在是太大了
