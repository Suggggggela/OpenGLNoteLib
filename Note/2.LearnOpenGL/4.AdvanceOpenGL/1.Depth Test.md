
## 1.Depth Buffer
### DepthBuffer
- Depth，深度值
- DepthBuff 深度缓存

深度是我们渲染时区分物体前后关系的依据，深度缓冲区存着屏幕中每个Fragment的深度
一般DepthBuffer中包含着以下信息：
- Depth 每个片段的深度值，一般以24f位float存储（可以16、 24、 32）
- 宽度和高度，和ColorBuffer相同，都是屏幕的

## 2.Depth testing
### DepthTest
深度测试是位于FragmentShader之后，在计算出屏幕的像素后，我们需要确定像素之间的关系，比如深度测试就是觉得像素之前的前后遮挡关系。
它会根据DepthBuffer中存的Z值进行测试，测试可以是不同的比较方式，对应这DepthTesting的不同TestFunction
OpenGL默认是不开启深度测试，我们需要通过以下命令开启深度测试
```cpp
glEnable(GL_DEPTH_TEST);
//启用之后，每次渲染之前记得Clear DepthBuffer，否则使用的就是上一次Draw的了
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

//如果启用并且不想更新DepthBuffer，设置DepthMask为False即可(深度掩码，只读)
glDepthMask(GL_FALSE);
```

### Depth Test Function
启用深度测试之后，我们需要指定一种测试的方式，也就是配置DepthFunction
```cpp
glDepthFunc(GL_LESS); //默认
```
函数有以下几种：

|函数|描述|
|---|---|
|GL_ALWAYS|永远通过深度测试|
|GL_NEVER|永远不通过深度测试|
|GL_LESS|在片段深度值小于缓冲的深度值时通过测试|
|GL_EQUAL|在片段深度值等于缓冲区的深度值时通过测试|
|GL_LEQUAL|在片段深度值小于等于缓冲区的深度值时通过测试|
|GL_GREATER|在片段深度值大于缓冲区的深度值时通过测试|
|GL_NOTEQUAL|在片段深度值不等于缓冲区的深度值时通过测试|
|GL_GEQUAL|在片段深度值大于等于缓冲区的深度值时通过测试|

## 3.Depth Value
### Depth精度
DepthBuffer中的Depth是0~1的，在进行DepthTest时，比较的是：DepthBuffer和ViewSpace的深度
但是ViewSpace的深度的范围取决于平头截体的近平面和远平面，也就是nearPlane~farPlane
所以我们需要一种方法把ViewSpace的Depth映射到0~1

**线性映射**
线性映射是最直观的想法![426x256](assets/1.Depth%20Test_image_1.png)
实际上我们几乎不会使用这种映射，因为这种映射中斜率的变化为0，也就是映射是均匀的
但是我们渲染时，画面的远近重要性是不均匀，想想看，是不是近景要求的精度更重要一些？
所以就有了下边的非线性映射方法

**非线性映射**
![416x243](assets/1.Depth%20Test_image_2.png)
上边的曲线是我们实际会应用的映射，可以看到离视线近处的精度更高
非线性方程与 1/z 成正比
在1.0和2.0之间的z值将会变换至1.0到0.5之间的深度值
这就是一个float提供给我们的一半精度了，这在z值很小的情况下提供了非常大的精度
在50.0和100.0之间的z值将会只占2%的float精度
### DepthBuffer可视化
fs中，gl_FragCoord的z值就是深度值
如果我们直接把它输出的话，就是上边第二中非线性映射的结果![430x323](assets/1.Depth%20Test_image_3.png)
实际可视化时我们还是想查看线性的深度值，这时候就需要翻转深度值的投影变换
步骤如下：
- 将Z从0~1重新映射到-1~1的NDC坐标
- 应用非线性映射的逆变换
- 除以far，映射回0~1
```cpp
float ndc = depth * 2.0 - 1.0;
float linearDepth = (2.0 * near * far) / (far + near - ndc * (far - near));
float depth = LinearizeDepth(gl_FragCoord.z) / far;
```

![491x368](assets/1.Depth%20Test_image_4.png)

### Z-Fightting
Z-Fightting是深度冲突的意思，如果两个Fragment离得太近了，就会出现不知道谁在前边的情况
具体表现就是抖动
举例来说，笔者项目的模型在做扇子的时候，把一个长方形复制摆形成了扇子，但是他没有调整每个扇叶的z值，在引擎中扇叶就会疯狂抖动

要解决Z-Fightting的方法有以下几种：
- 别摆太近
- farPlane设置的远一点，这样Z的精度也会提高
- 直接提高Z的精度