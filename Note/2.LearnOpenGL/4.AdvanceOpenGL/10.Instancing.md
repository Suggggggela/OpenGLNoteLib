当前我们绘制物体的时候都是CPU将数据设置好，然后发送到GPU进行渲染，有多少个物体就要设置多少次
当我们想要大量绘制物体的时候，这就有点难搞了，一是繁琐，更重要的是CPU-GPU发送数据的性能也是比较奢侈的

这节我们来了解实例化Instancing的用法，看看如何一次性绘制大规模的物体

## 1.Instancing
实例化绘制对应的函数是`glDrawArraysInstanced`, `glDrawElementsInstanced`

通过instancing绘制时，VS中会有一个`gl_InstanceID`的东西给我们作为索引使用
类似下边这样
```cpp
uniform vec2 offsets[100]; //传进来的顶点偏移量
void main() 
{ 
    vec2 offset = offsets[gl_InstanceID];//通过gl_InstancID索引偏移量
    gl_Position = vec4(aPos + offset, 0.0, 1.0); 
    fColor = aColor; 
}
```

CPU端使用的流程可以参考以下伪代码：
```cpp
//render data
float quadVertices[] = {...}

glm::vec2 translations[100]; 
int index = 0; 
float offset = 0.1f; 
for(int y = -10; y < 10; y += 2)
{ 
    for(int x = -10; x < 10; x += 2) 
        { 
        glm::vec2 translation; 
        translation.x = (float)x / 10.0f + offset; 
        translation.y = (float)y / 10.0f + offset; 
        translations[index++] = translation; 
        } 
}

//render
shader.use(); 
for(unsigned int i = 0; i < 100; i++) 
{ 
    shader.setVec2(("offsets[" + std::to_string(i) + "]"), translations[i]); 
}
glBindVertexArray(quadVAO); 
glDrawArraysInstanced(GL_TRIANGLES, 0, 6, 100);//最后一个参数是实例数量

```

## 2.Instaced Array
通过实例绘制大数量的物体，级数超过100是很常见的，这样会出现超过可使用Uniform数量上限的问题
之前学习UniformBufferObject时就总结过，通过类似的思路，我们可以通过Instaced Array
Instanced Array被定义为一个VertexAttribute，仅在VS渲染一个新实例时才会更新

类比上边的做法，使用Instanced Array的做法如下：
```cpp
layout (location = 2) in vec2 aOffset;
void main() 
{ 
    gl_Position = vec4(aPos + aOffset, 0.0, 1.0); //不使用gl_InstanceID就能获取到offset
}
```

CPU端需要设置对应的VertexAttribute
在指定offset的VertexAttribute时，需要通过`glVertexAttributDivisor`指定更新频率
```cpp
//renderdata
...
//VB Layout
glEnableVertexAttribArray(2); 
glBindBuffer(GL_ARRAY_BUFFER, instanceVBO); 
glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)0); 
glBindBuffer(GL_ARRAY_BUFFER, 0); 
glVertexAttribDivisor(2, 1);
//parameter1: vertex attribute index
//parameter2: Attribute Divisor
    //default = 0, 每个顶点都传递
    	//1, 每个实例传递一次
    	//2, 每两个实例传递一次
```

## 3.测试
### 1.Quad
这个测试我们绘制100个Quad，并且在VS中通过gl_InstanceID让Quad越来越小
VS:
```cpp
#version 330 core
layout (location = 0) in vec2 aPos;
layout (location = 1) in vec3 aColor;
layout (location = 2) in vec2 aOffset;

out vec3 fColor;

void main()
{
    vec2 pos = aPos * (gl_InstanceID / 100.0); //Quad越来越小
    gl_Position = vec4(pos + aOffset, 0.0, 1.0);
    fColor = aColor;
}
```

CPU端
```cpp
Shader shader("shaders/instancing_Quad.vs", "shaders/instancing_Quad.fs");

float quadVertices[] = {
    // positions     // colors
    -0.05f,  0.05f,  1.0f, 0.0f, 0.0f,
     0.05f, -0.05f,  0.0f, 1.0f, 0.0f,
    -0.05f, -0.05f,  0.0f, 0.0f, 1.0f,

    -0.05f,  0.05f,  1.0f, 0.0f, 0.0f,
     0.05f, -0.05f,  0.0f, 1.0f, 0.0f,
     0.05f,  0.05f,  0.0f, 1.0f, 1.0f
};

glm::vec2 translations[100];
int index = 0;
float offset = 0.1f;
for (int y = -10; y < 10; y += 2)
{
    for (int x = -10; x < 10; x += 2)
    {
        glm::vec2 translation;
        translation.x = (float)x / 10.0f + offset;
        translation.y = (float)y / 10.0f + offset;
        translations[index++] = translation;
    }
}
//instance VBO
unsigned int instanceVBO;
glGenBuffers(1, &instanceVBO);
glBindBuffer(GL_ARRAY_BUFFER, instanceVBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(glm::vec2) * 100, &translations[0], GL_STATIC_DRAW);
glBindBuffer(GL_ARRAY_BUFFER, 0);
//quad VAOVBO
unsigned int quadVAO, quadVBO;
glGenVertexArrays(1, &quadVAO);
glGenBuffers(1, &quadVBO);
glBindVertexArray(quadVAO);
glBindBuffer(GL_ARRAY_BUFFER, quadVBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(quadVertices), quadVertices, GL_STATIC_DRAW);
glEnableVertexAttribArray(0);
glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0);
glEnableVertexAttribArray(1);
glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(2 * sizeof(float)));

//instacnce attribute
glEnableVertexAttribArray(2);
glBindBuffer(GL_ARRAY_BUFFER, instanceVBO); // this attribute comes from a different vertex buffer
glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)0);
glBindBuffer(GL_ARRAY_BUFFER, 0);
glVertexAttribDivisor(2, 1);
//parameter1: vertex attribute index
//parameter2: Attribute Divisor
    //default = 0, 每个顶点都传递
	//1, 每个实例传递一次
	//2, 每两个实例传递一次
    //...


while(rendering)
{
    shader.use();
    glBindVertexArray(quadVAO);
    glDrawArraysInstanced(GL_TRIANGLES, 0, 6, 100); //mode, first, verticesCount, instanceCount
    glBindVertexArray(0);
}
```
![[assets/10.Instancing_image_1.png|377x283]]
### 2.Planet
这个测试我们现在中间绘制一个行星，然后在它的周围通过InstanceArray绘制一圈行星石头

中间行星的shader就是普通的采样贴图，不多赘述
石头的VS中，我们通过VertexAttribute传递每个实例的Transform
```cpp
//Instanced_Rock.vs
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 2) in vec2 aTexCoords;
layout (location = 3) in mat4 aInstanceMatrix;//InstancedTransform

out vec2 TexCoords;

uniform mat4 projection;
uniform mat4 view;

void main()
{
    TexCoords = aTexCoords;
    gl_Position = projection * view * aInstanceMatrix * vec4(aPos, 1.0f); 
}

```

CPU端如下：

```cpp
Shader asteroidShader("shaders/instancing_PlanetRock.vs","shaders/instancing_Planet.fs");
Shader planetShader("shaders/instancing_Planet.vs", "shaders/instancing_Planet.fs");

Model rock("objects/Rock/rock.obj");
Model planet("objects/Planet/planet.obj");

//Generate rock transform
unsigned int amount = 100000;
glm::mat4* modelMatrices = new glm::mat4[amount];
srand(static_cast<unsigned int>(glfwGetTime()));
float radius = 150.0;
float offset = 25.0f;
for (unsigned int i = 0; i < amount; i++)
{
    glm::mat4 model = glm::mat4(1.0f);
    // 1. translation: displace along circle with 'radius' in range [-offset, offset]
    float angle = (float)i / (float)amount * 360.0f;
    float displacement = (rand() % (int)(2 * offset * 100)) / 100.0f - offset;
    float x = sin(angle) * radius + displacement;
    displacement = (rand() % (int)(2 * offset * 100)) / 100.0f - offset;
    float y = displacement * 0.4f; // keep height of asteroid field smaller compared to width of x and z
    displacement = (rand() % (int)(2 * offset * 100)) / 100.0f - offset;
    float z = cos(angle) * radius + displacement;
    model = glm::translate(model, glm::vec3(x, y, z));

    // 2. scale: Scale between 0.05 and 0.25f
    float scale = static_cast<float>((rand() % 20) / 100.0 + 0.05);
    model = glm::scale(model, glm::vec3(scale));

    // 3. rotation: add random rotation around a (semi)randomly picked rotation axis vector
    float rotAngle = static_cast<float>((rand() % 360));
    model = glm::rotate(model, rotAngle, glm::vec3(0.4f, 0.6f, 0.8f));

    // 4. now add to list of matrices
    modelMatrices[i] = model;
}
//rock VAO
unsigned int buffer;
glGenBuffers(1, &buffer);
glBindBuffer(GL_ARRAY_BUFFER, buffer);
glBufferData(GL_ARRAY_BUFFER, amount * sizeof(glm::mat4), &modelMatrices[0], GL_STATIC_DRAW);

//set rock instanced array
//vertex attribute most data size is vec4
//we use 4 vec4 to store a mat4
for (unsigned int i = 0; i < rock.meshes.size(); i++)
{
    unsigned int VAO = rock.meshes[i].VAO;
    glBindVertexArray(VAO);
    // set attribute pointers for matrix (4 times vec4)
    glEnableVertexAttribArray(3);
    glVertexAttribPointer(3, 4, GL_FLOAT, GL_FALSE, sizeof(glm::mat4), (void*)0);
    glEnableVertexAttribArray(4);
    glVertexAttribPointer(4, 4, GL_FLOAT, GL_FALSE, sizeof(glm::mat4), (void*)(sizeof(glm::vec4)));
    glEnableVertexAttribArray(5);
    glVertexAttribPointer(5, 4, GL_FLOAT, GL_FALSE, sizeof(glm::mat4), (void*)(2 * sizeof(glm::vec4)));
    glEnableVertexAttribArray(6);
    glVertexAttribPointer(6, 4, GL_FLOAT, GL_FALSE, sizeof(glm::mat4), (void*)(3 * sizeof(glm::vec4)));

    glVertexAttribDivisor(3, 1);
    glVertexAttribDivisor(4, 1);
    glVertexAttribDivisor(5, 1);
    glVertexAttribDivisor(6, 1);

    glBindVertexArray(0);
}

```


```cpp
//draw
// configure transformation matrices
glm::mat4 projection = glm::perspective(glm::radians(45.0f), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 1000.0f);
glm::mat4 view = camera.GetViewMatrix();
asteroidShader.use();
asteroidShader.setMat4("projection", projection);
asteroidShader.setMat4("view", view);
planetShader.use();
planetShader.setMat4("projection", projection);
planetShader.setMat4("view", view);

//------planet------------------------------
glm::mat4 model = glm::mat4(1.0f);
model = glm::translate(model, glm::vec3(0.0f, -3.0f, 0.0f));
model = glm::scale(model, glm::vec3(4.0f, 4.0f, 4.0f));
planetShader.setMat4("model", model);
planet.Draw(planetShader);

//-------rocks------------------------------
asteroidShader.use();
asteroidShader.setInt("texture_diffuse1", 0);
glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_2D, rock.textures_loaded[0].id); // note: we also made the textures_loaded vector public (instead of private) from the model class.
for (unsigned int i = 0; i < rock.meshes.size(); i++)
{
    glBindVertexArray(rock.meshes[i].VAO);
    glDrawElementsInstanced(GL_TRIANGLES, static_cast<unsigned int>(rock.meshes[i].indices.size()), GL_UNSIGNED_INT, 0, amount);
	//index = 0，代表从第一个element开始绘制
    glBindVertexArray(0);
}

```

![[assets/10.Instancing_image_2.png|355x266]]