阴影是游戏中重要的一环，没有阴影我们无法轻易的感知到物体的位置和空间关系
这节我们看看渲染中阴影是怎么实现的

## 1.ShadowMapping
阴影映射的原理很简单：以光源的位置为视角进行渲染，能看到的东西证明被照亮，看不到的东西就是在阴影中了
![[assets/3.ShadowMapping_image_1.png|472x219]]
上图蓝色代表接收光照的表面，黑色代表阴影部分

但是如何从光源方向进行渲染呢，或者说，如何从光的方向看场景呢？
            直觉是直接Raycasting，直接从光源的方向向场景发射ray，就知道
以上是比较理想的方法，可以称得上是力大砖飞，成千上万的光线遍历也是比较低效，基本上很难走通

我们可以回顾以下DepthTest那节的深度测试，场景的深度Buffer或者说深度图是当前Camera视角下场景的深度值的总和，它的范围是0~1的
可以使用深度取巧，阴影映射的具体思路如下：
- 从光源角度看向场景，获取当前的深度信息，得到深度图，这张图我们称为shadowmap
- 从相机的角度看向场景，获取场景正常的深度信息
- 对于一个像素P，对比两者的深度，如果相机下深度大于shadowmap的深度，那么说明我们看到了，光没看到，那么它就处于阴影之中了

具体可以看这张图（点P为我们想知道的像素，在相机视角Z=0.9，在Light视角Z=0.4，那么这个点就在阴影中）
![[assets/3.ShadowMapping_image_2.png|376x291]]


## 2.ShadowMap
接下来我们看看如何实际操作
### 创建ShadowMap
我们需要在光源的角度渲染场景的深度
- 使用FrameBufferObject的TextureAttachment
- 创建depthMap
- 将depthMap指定为FBO的Attachment
```cpp
// configure depth map FBO
unsigned int depthMapFBO;
glGenFramebuffers(1, &depthMapFBO);

// create depth texture
const unsigned int SHADOW_WIDTH = 1024, SHADOW_HEIGHT = 1024;
unsigned int depthMap;
glGenTextures(1, &depthMap);
glBindTexture(GL_TEXTURE_2D, depthMap);
glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, SHADOW_WIDTH, SHADOW_HEIGHT, 0, GL_DEPTH_COMPONENT, GL_FLOAT, NULL);//我们只关心深度，格式为GL_DEPTH_COMPONENT
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);

// attach depth texture as FBO's depth buffer
glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, depthMap, 0);
glDrawBuffer(GL_NONE);
glReadBuffer(GL_NONE);
glBindFramebuffer(GL_FRAMEBUFFER, 0);
```

### LightSpace Transform
接下来解决如何从光源方向渲染深度图
我们已经知道OpenGL其实没有Camera这个概念，所有的东西都是通过Transform实现的
- 对于渲染场景，我们正常设置MVP矩阵
- 对于渲染ShadowMap，我们使用一个变换矩阵将场景的物体变换到LightSpace中，获取场景深度信息，就是要的ShadowMap

因为这里计算的是方向光(平行光)的阴影，我们使用一个正交投影矩阵
```cpp
float near_plane = 1.0f, far_plane = 7.5f;
glm::mat4 lightProjection = glm::ortho(-10.0f, 10.0f, -10.0f, 10.0f, near_plane, far_plane);
```
然后使用glm::lookAt函数从光源的位置看向场景中央
```cpp
glm::mat4 lightView = glm::lookAt(lightPos, glm::vec3(0.0f), glm::vec3(0.0, 1.0, 0.0));
```
结合以上两个部分，就是转换到LightSpace的变换矩阵
```cpp
glm::mat4 lightSpaceMatrix = lightProjection * lightView;
```

### Render ShadowMap
接下来对于场景的物体，使用LightSpaceMatrix+物体的M矩阵，进行渲染，就可以得到光源角度下场景的深度信息，即ShadowMap了

Shader部分
```cpp
//VS
#version 330 core layout (location = 0) in 
vec3 aPos; 
uniform mat4 lightSpaceMatrix; 
uniform mat4 model; 
void main() 
{ gl_Position = lightSpaceMatrix * model * vec4(aPos, 1.0); } 

//FS
//我们只考虑深度，所以FS Do Nothing
#version 330 core 
void main() 
{}
```

CPU端
```cpp
// render scene from light's point of view
simpleDepthShader.use();
simpleDepthShader.setMat4("lightSpaceMatrix", lightSpaceMatrix);
//记得设置ViewPort为ShadowMap的分辨率
glViewport(0, 0, SHADOW_WIDTH, SHADOW_HEIGHT);
glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);
    glClear(GL_DEPTH_BUFFER_BIT);
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, woodTexture);
    renderScene(simpleDepthShader);
glBindFramebuffer(GL_FRAMEBUFFER, 0);

// reset viewport
glViewport(0, 0, SCR_WIDTH, SCR_HEIGHT);
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
```

### Debug ShadowMap
我们可以直接用一个Quad将渲染的ShadowMap显示出来查看
```cpp
    //---------CPU---------------------------------
    //plane render data
    float planeVertices[] = { ... };
    // plane VAO...

    debugDepthQuad.use();
    debugDepthQuad.setInt("depthMap", 0);

    while(rendering)
    {
        //render shadow map
        ...
        //reset viewport
        glViewport(0, 0, SCR_WIDTH, SCR_HEIGHT);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        //show debug quad
        debugDepthQuad.use();
        debugDepthQuad.setFloat("near_plane", near_plane);
        debugDepthQuad.setFloat("far_plane", far_plane);
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, depthMap);
        renderQuad();
    }


//---------GPU-----------------------------------
//VS
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec2 aTexCoords;

out vec2 TexCoords;

void main()
{
    TexCoords = aTexCoords;
    gl_Position = vec4(aPos, 1.0);
}

//FS
#version 330 core
out vec4 FragColor;

in vec2 TexCoords;

uniform sampler2D depthMap;
uniform float near_plane;
uniform float far_plane;

// required when using a perspective projection matrix
float LinearizeDepth(float depth)
{
    float z = depth * 2.0 - 1.0; // Back to NDC 
    return (2.0 * near_plane * far_plane) / (far_plane + near_plane - z * (far_plane - near_plane));	
}

void main()
{
    //sample ShadowMap
    float depthValue = texture(depthMap, TexCoords).r;

    //Output
    //FragColor = vec4(vec3(LinearizeDepth(depthValue) / far_plane), 1.0); // perspective
    FragColor = vec4(vec3(depthValue), 1.0); // orthographic
}
```
![[assets/3.ShadowMapping_image_3.png|418x314]]
## 3.Render Shadow
完成ShadowMap的渲染后，接下来就是使用ShadowMap进行阴影计算

VS中需要的是：
- WorldSpacePos
- LightSpacePos
- 其他常规需要的
```cpp
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;

out vec2 TexCoords;

out VS_OUT {
    vec3 FragPos;//WSPos
    vec3 Normal;
    vec2 TexCoords;
    vec4 FragPosLightSpace;//LightSpacePos
} vs_out;

uniform mat4 projection;
uniform mat4 view;
uniform mat4 model;
uniform mat4 lightSpaceMatrix;//LightViewMatrix * LightProjectionMatrix

void main()
{
    vs_out.FragPos = vec3(model * vec4(aPos, 1.0));
    vs_out.Normal = transpose(inverse(mat3(model))) * aNormal;
    vs_out.TexCoords = aTexCoords;
    vs_out.FragPosLightSpace = lightSpaceMatrix * vec4(vs_out.FragPos, 1.0);
    gl_Position = projection * view * model * vec4(aPos, 1.0);
}
```

FS中，我们使用简单的光照模型
```cpp
#version 330 core
out vec4 FragColor;

in VS_OUT {
    vec3 FragPos;
    vec3 Normal;
    vec2 TexCoords;
    vec4 FragPosLightSpace;
} fs_in;

uniform sampler2D diffuseTexture;
uniform sampler2D shadowMap;

uniform vec3 lightPos;
uniform vec3 viewPos;

void main()
{           
    vec3 color = texture(diffuseTexture, fs_in.TexCoords).rgb;
    vec3 normal = normalize(fs_in.Normal);
    vec3 lightColor = vec3(0.3);
    // ambient
    vec3 ambient = 0.3 * lightColor;
    // diffuse
    vec3 lightDir = normalize(lightPos - fs_in.FragPos);
    float diff = max(dot(lightDir, normal), 0.0);
    vec3 diffuse = diff * lightColor;
    // specular
    vec3 viewDir = normalize(viewPos - fs_in.FragPos);
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = 0.0;
    vec3 halfwayDir = normalize(lightDir + viewDir);  
    spec = pow(max(dot(normal, halfwayDir), 0.0), 64.0);
    vec3 specular = spec * lightColor;    
    // calculate shadow
    float shadow = ShadowCalculation(fs_in.FragPosLightSpace);//通过VS传过来的LightSpacePos计算阴影                      
    vec3 lighting = (ambient + (1.0 - shadow) * (diffuse + specular)) * color;    
    //给阴影环境光，其他部分不参与阴影
    
    FragColor = vec4(lighting, 1.0);
}
```

计算阴影的方法如下：
```cpp
float ShadowCalculation(vec4 fragPosLightSpace)
{
    //通过gl_Position传过来的顶点会自动执行透视除法
    //但是LightSpace传过来的没有,所以我们要自己进行透视除法
    //对于正交投影这么做可能没作用，但是考虑适配所有投影类型，还是要进行
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    
    //执行透视除法之后的范围为[-1,1],我们要映射到[0,1]和场景常规深度进行比较
    projCoords = projCoords * 0.5 + 0.5;
    
    //当前像素在ShadowMap的深度
    float closestDepth = texture(shadowMap, projCoords.xy).r; 
    //当前像素在相机视角的深度
    float currentDepth = projCoords.z;
    //比较深度，如果当前深度>ShadowMap的深度，说明Camera可以看到光看不到->在阴影中
    float shadow = currentDepth > closestDepth  ? 1.0 : 0.0;

    return shadow;
}

```

CPU端设置如下：
```cpp
//shader...
//scene render data...

//config shadowmap FBO
const unsigned int SHADOW_WIDTH = 1024, SHADOW_HEIGHT = 1024;
unsigned int depthMapFBO;
glGenFramebuffers(1, &depthMapFBO);
//create FBO texture
unsigned int depthMap;
glGenTextures(1, &depthMap);
glBindTexture(GL_TEXTURE_2D, depthMap);
glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, SHADOW_WIDTH, SHADOW_HEIGHT, 0, GL_DEPTH_COMPONENT, GL_FLOAT, NULL);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
// attach depth texture as FBO's depth buffer
glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, depthMap, 0);
glDrawBuffer(GL_NONE);
glReadBuffer(GL_NONE);
glBindFramebuffer(GL_FRAMEBUFFER, 0);

//light
glm::vec3 lightPos(-2.0f, 4.0f, -1.0f);

shader.use();
shader.setInt("diffuseTexture", 0);
shader.setInt("shadowMap", 1);

while(rendering)
{
    //-----pass1: render shadowmap-----
glm::mat4 lightProjection, lightView;
glm::mat4 lightSpaceMatrix;
float near_plane = 1.0f, far_plane = 7.5f;
lightProjection = glm::ortho(-10.0f, 10.0f, -10.0f, 10.0f, near_plane, far_plane);
lightView = glm::lookAt(lightPos, glm::vec3(0.0f), glm::vec3(0.0, 1.0, 0.0));
lightSpaceMatrix = lightProjection * lightView;
// render scene from light's point of view
simpleDepthShader.use();
simpleDepthShader.setMat4("lightSpaceMatrix", lightSpaceMatrix);
glViewport(0, 0, SHADOW_WIDTH, SHADOW_HEIGHT);
glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);
glClear(GL_DEPTH_BUFFER_BIT);
glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_2D, woodTexture);
renderScene(simpleDepthShader);
glBindFramebuffer(GL_FRAMEBUFFER, 0);

//reset viewport 
glViewport(0, 0, SCR_WIDTH, SCR_HEIGHT);
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

//----pass2: render scene-----------
shader.use();
glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f);
glm::mat4 view = camera.GetViewMatrix();
shader.setMat4("projection", projection);
shader.setMat4("view", view);
// set light uniforms
shader.setVec3("viewPos", camera.Position);
shader.setVec3("lightPos", lightPos);
shader.setMat4("lightSpaceMatrix", lightSpaceMatrix);
glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_2D, woodTexture);
glActiveTexture(GL_TEXTURE1);
glBindTexture(GL_TEXTURE_2D, depthMap);
renderScene(shader);
}
```


![[assets/3.ShadowMapping_image_4.png|809x606]]

可以看到我们成功的将阴影渲染出来了，但是瑕疵非常明显，整个场景充斥着摩尔纹


## 4.改进ShadowMapping

### 阴影失真 Shadow acne
阴影失真又称阴影粉刺，上阶段渲染出阴影的漫场景摩尔纹就是典型的表现
造成阴影失真的原因是因为ShadowMap分辨率的影响，有些像素在采样ShadowMap时取到的深度值是一样的，这些像素在表面上有的被判定为表面上和表面下，造成的结果就是很均匀的间隔着的亮暗条纹
当夕阳西下，阴影拉的很长的时候，情况会更加糟糕
我们可以通过下边的图理解：
            图中黄色斜坡表示可能被多个像素采样到的同一深度值，上半段在表面上边，下半段在表面下边
![[assets/3.ShadowMapping_image_5.png|589x187]]

为了解决这个问题，我们可以给采样ShadowMap的深度一个**bias**偏移值
这个偏移值最好是根据表面朝法线的角度更改偏移量，这样和光的角度越垂直，给到的bias就越小
```cpp
vec3 normal = normalize(fs_in.Normal);
vec3 lightDir = normalize(lightPos - fs_in.FragPos);
float bias = max(0.05 * (1.0 - dot(normal, lightDir)), 0.005);

float shadow = currentDepth - bias > closestDepth ? 1.0 : 0.0;
```

示例中通过对bias添加了一个乘数因子作为debug使用
![](assets/3.ShadowMapping_video_1.mp4)

### 阴影悬浮/漂移 Peter Panning
peter panning 的由来是一个动画人物，他的特点人物和影子分离
阴影悬浮是因为Bais开太大了，阴影明显的偏离了实际物体，可以参考上边debug时bais拉的足够大之后cube的影子，已经不是连着的了
![[assets/3.ShadowMapping_image_6.png|242x398]]


解决这个问题我们可以在渲染ShadowMap时将场景物体开启正面剔除
![[assets/3.ShadowMapping_image_7.png|481x209]]

### 过采样
![[assets/3.ShadowMapping_image_8.png|411x308]]
图中红圈部分即时不在光源的视锥范围，也会进行阴影判断，被判断为阴影之中
造成这样的原因是当投影坐标超出光源的视锥范围，值会比1.0大，此时采样的ShadowMap就会超出它的默认范围（0~1）
超出之后的效果会根据ShadowMap的WRAP模式不同，但是肯定不是对的（图上的原因是设置为REPEAT了）
因为实际上并没有超过1的深度，我们可以将Wrap Mode设置为borader，然后自己设置一个bodercolor
```cpp
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER); 
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER); 
float borderColor[] = { 1.0, 1.0, 1.0, 1.0 }; 
glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);
```

对于超出光源视锥体的部分，我们可以直接对投影坐标超过1的部分钳制为0，表示它不在阴影中
```cpp
//over farPlane set to not in shadow
if(projCoords.z > 1.0)
    shadow = 0.0;
```

![[assets/3.ShadowMapping_image_9.png|424x318]]

### 阴影锯齿
![[assets/3.ShadowMapping_image_10.png|256x201]]
到此为止阴影没有大的问题了，但是边缘还是和狗啃一样
阴影锯齿的原因是ShadowMap分辨率固定，一个深度值可能覆盖了多个Fragment，它们采样同一深度值得到了相同的阴影判定结果，就导致了锯齿
想解决锯齿可以增加ShadowMap分辨率，尽可能的让光的视锥体贴合场景
不过我们常用的还是对它进行模糊，或者说进行滤波操作

### PCF
PCF全名Percentage-closer Filtering，百分比渐进滤波
PCF涵盖了多种滤波函数，可以生成柔和的阴影，减少锯齿
核心思想： 多次采样ShadowMap，每次采样的texel coord稍有不同，独立判断每个采样点的阴影结果后，对子结果取平均进行混合（注意是PCF在判断Shadow结果时做的）
```cpp
float shadow = 0.0; 
vec2 texelSize = 1.0 / textureSize(shadowMap, 0); 
for(int x = -1; x <= 1; ++x) 
{ 
    for(int y = -1; y <= 1; ++y) 
    { 
    float pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r; 
    shadow += currentDepth - bias > pcfDepth ? 1.0 : 0.0; 
    } 
} 
shadow /= 9.0;
```

![[assets/3.ShadowMapping_image_11.png|607x449]]

PCF还包含了更多模糊阴影边缘的方案，后续有时间笔者会扩展
- [ ] Todo：More PCF Shadow Method


## 5.正交/透视投影 阴影

因为这里我们考虑的是平行光，默认光的方形是一个个平行过来的，所以我们使用了正交投影
对于透视投影，我们可以通过下图看到区别
![[assets/3.ShadowMapping_image_12.png|648x199]]

透视投影用于点光源和聚光灯，后续我们会涉及

透视投影ShadowMap的可视化，我们需要将深度从非线性转换为线性，这个注意点我们在深度测试章节已经说过，否则你可能会看到一大片白色（精度大部分给到nearPlane附近了）
```cpp
// required when using a perspective projection matrix
float LinearizeDepth(float depth)
{
    float z = depth * 2.0 - 1.0; // Back to NDC 
    return (2.0 * near_plane * far_plane) / (far_plane + near_plane - z * (far_plane - near_plane));	
}

void main()
{             
    float depthValue = texture(depthMap, TexCoords).r;
    // FragColor = vec4(vec3(LinearizeDepth(depthValue) / far_plane), 1.0); // perspective
    FragColor = vec4(vec3(depthValue), 1.0); // orthographic
}
```



## 6.PointLight Shaodw
点阴影的思路和方向光没有本质区别，因为点光源的方向是四面八方的，所以对于ShadowMap，我们需要一个**万向阴影贴图(omnidirectional shadow map)**
之前写反射的时候对于多个方向的贴图我们已经见过了，没错就是个cubemap
![[assets/3.ShadowMapping_image_13.png|388x216]]

### 生成depth cubemap
理论上要获得六个方向的ShadowMap，我们需要渲染场景6遍
但是GeometryShader支持我们通过一次渲染创建这个cubemap

首先创建ShadowMap需要的数据
```cpp
// configure depth map FBO
const unsigned int SHADOW_WIDTH = 1024, SHADOW_HEIGHT = 1024;
unsigned int depthMapFBO;
glGenFramebuffers(1, &depthMapFBO);
// create depth cubemap texture
unsigned int depthCubemap;
glGenTextures(1, &depthCubemap);
glBindTexture(GL_TEXTURE_CUBE_MAP, depthCubemap);
//6 face 
for (unsigned int i = 0; i < 6; ++i)
    glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_DEPTH_COMPONENT, SHADOW_WIDTH, SHADOW_HEIGHT, 0, GL_DEPTH_COMPONENT, GL_FLOAT, NULL);
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);

// attach depth texture as FBO's depth buffer
glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);
glFramebufferTexture(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, depthCubemap, 0);
glDrawBuffer(GL_NONE);
glReadBuffer(GL_NONE);
glBindFramebuffer(GL_FRAMEBUFFER, 0);
```

Shader中
```cpp
//VS
    //简单的进行Model变换
    gl_Position = model * vec4(aPos, 1.0);
//GS
    //
    #version 330 core
    layout (triangles) in;
    layout (triangle_strip, max_vertices=18) out;// 18 = 3tri * 6face
    
    uniform mat4 shadowMatrices[6];//CPU端传入6个ProjectionMatrix
    
    out vec4 FragPos; // FragPos from GS (output per emitvertex)
    
    void main()
    {
        for(int face = 0; face < 6; ++face)
        {
            //gl_Layer指定发散出基本图形送到立方体贴图的哪个面
            //只有FrameBufferAttachment为Cubemap时才生效
            gl_Layer = face; // built-in variable that specifies to which face we render.
            for(int i = 0; i < 3; ++i) // for each triangle's vertices
            {
                FragPos = gl_in[i].gl_Position;
                gl_Position = shadowMatrices[face] * FragPos;
                EmitVertex();
            }    
            EndPrimitive();
        }
    } 
//FS
    //通过GS中传过来的LightSpace的顶点计算深度
    //把fragment和光源之间的距离，映射到0到1的范围，把它写入为fragment的深度值
    in vec4 FragPos; 
    uniform vec3 lightPos; 
    uniform float far_plane;

    void main() 
    { 
        // get distance between fragment and light source 
        float lightDistance = length(FragPos.xyz - lightPos); 
        // map to [0;1] range by dividing by far_plane 
        lightDistance = lightDistance / far_plane; 
        // write this as modified depth into gl_FragDepth
        gl_FragDepth = lightDistance; 
    }

```

CPU端
```cpp
//-----pass0:generate 6 perspective transform matrix-----
float near_plane = 1.0f;
float far_plane = 25.0f;
glm::mat4 shadowProj = glm::perspective(glm::radians(90.0f), (float)SHADOW_WIDTH / (float)SHADOW_HEIGHT, near_plane, far_plane);
std::vector<glm::mat4> shadowTransforms;
shadowTransforms.push_back(shadowProj * glm::lookAt(lightPos, lightPos + glm::vec3(1.0f, 0.0f, 0.0f), glm::vec3(0.0f, -1.0f, 0.0f)));
shadowTransforms.push_back(shadowProj * glm::lookAt(lightPos, lightPos + glm::vec3(-1.0f, 0.0f, 0.0f), glm::vec3(0.0f, -1.0f, 0.0f)));
shadowTransforms.push_back(shadowProj * glm::lookAt(lightPos, lightPos + glm::vec3(0.0f, 1.0f, 0.0f), glm::vec3(0.0f, 0.0f, 1.0f)));
shadowTransforms.push_back(shadowProj * glm::lookAt(lightPos, lightPos + glm::vec3(0.0f, -1.0f, 0.0f), glm::vec3(0.0f, 0.0f, -1.0f)));
shadowTransforms.push_back(shadowProj * glm::lookAt(lightPos, lightPos + glm::vec3(0.0f, 0.0f, 1.0f), glm::vec3(0.0f, -1.0f, 0.0f)));
shadowTransforms.push_back(shadowProj * glm::lookAt(lightPos, lightPos + glm::vec3(0.0f, 0.0f, -1.0f), glm::vec3(0.0f, -1.0f, 0.0f)));

//-----pass1: render shadowcubemap-----
glViewport(0, 0, SHADOW_WIDTH, SHADOW_HEIGHT);
glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);
glClear(GL_DEPTH_BUFFER_BIT);
simpleDepthShader.use();
for (unsigned int i = 0; i < 6; ++i)
    simpleDepthShader.setMat4("shadowMatrices[" + std::to_string(i) + "]", shadowTransforms[i]);
simpleDepthShader.setFloat("far_plane", far_plane);
simpleDepthShader.setVec3("lightPos", lightPos);
renderScene(simpleDepthShader);
glBindFramebuffer(GL_FRAMEBUFFER, 0);

//reset viewport 
glViewport(0, 0, SCR_WIDTH, SCR_HEIGHT);
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);


```


Debug
```cpp
FragColor = vec4(vec3(closestDepth / far_plane), 1.0);
```
![[assets/3.ShadowMapping_image_14.png|533x382]]



### 绘制点光源阴影
接下来我们需要采样ShadowCubeMap

```cpp
//VS
    //不再需要LightSpacePosition
    gl_Position = projection * view * model * vec4(position, 1.0f); 
    vs_out.FragPos = vec3(model * vec4(position, 1.0)); 
    vs_out.Normal = transpose(inverse(mat3(model))) * normal; 
    vs_out.TexCoords = texCoords;

//FS
    in VS_OUT 
    { 
    vec3 FragPos; 
    vec3 Normal; 
    vec2 TexCoords; 
    } fs_in; 
    uniform sampler2D diffuseTexture; 
    uniform samplerCube depthMap; 
    uniform vec3 lightPos; 
    uniform vec3 viewPos; 
    uniform float far_plane;

    //CalculateShadow, use fragmentPos
    float ShadowCalculation(vec3 fragPos)
{
    //获取像素到光源的vector
    vec3 fragToLight = fragPos - lightPos;
    //通过这个vector采样ShadowMap中的深度 
    float closestDepth = texture(depthMap, fragToLight).r;
    // it is currently in linear range between [0,1], let's re-transform it back to original depth value
    closestDepth *= far_plane;
    // now get current linear depth as the length between the fragment and light position
    float currentDepth = length(fragToLight);
    // test for shadows
    float bias = 0.05; // we use a much larger bias since depth is now in [near_plane, far_plane] range
    float shadow = currentDepth -  bias > closestDepth ? 1.0 : 0.0;        
    // display closestDepth as debug (to visualize depth cubemap)
    // FragColor = vec4(vec3(closestDepth / far_plane), 1.0);    
        
    return shadow;
}

void main()
{           
    //render
    vec3 color = texture(diffuseTexture, fs_in.TexCoords).rgb;
    vec3 normal = normalize(fs_in.Normal);
    vec3 lightColor = vec3(0.3);
    // ambient
    vec3 ambient = 0.3 * lightColor;
    // diffuse
    vec3 lightDir = normalize(lightPos - fs_in.FragPos);
    float diff = max(dot(lightDir, normal), 0.0);
    vec3 diffuse = diff * lightColor;
    // specular
    vec3 viewDir = normalize(viewPos - fs_in.FragPos);
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = 0.0;
    vec3 halfwayDir = normalize(lightDir + viewDir);  
    spec = pow(max(dot(normal, halfwayDir), 0.0), 64.0);
    vec3 specular = spec * lightColor;    
    // calculate shadow
    float shadow = shadows ? ShadowCalculation(fs_in.FragPos) : 0.0;                      
    vec3 lighting = (ambient + (1.0 - shadow) * (diffuse + specular)) * color;    
    
    FragColor = vec4(lighting, 1.0);


    //debug
    //vec3 fragToLight = fs_in.FragPos - lightPos;
    //float closestDepth = texture(depthMap, fragToLight).r;
    //closestDepth *= far_plane;
    //FragColor = vec4(vec3(closestDepth / far_plane), 1.0);
}
```
![[assets/3.ShadowMapping_image_15.png|583x437]]

### 点光源PCF

如果按照之前的pcf思路扩展出第三个维度的代码类似下边这样
```cpp
float shadow = 0.0; 
float bias = 0.05; 
float samples = 4.0; 
float offset = 0.1; 
for(float x = -offset; x < offset; x += offset / (samples * 0.5)) 
{ 
    for(float y = -offset; y < offset; y += offset / (samples * 0.5)) 
    { 
        for(float z = -offset; z < offset; z += offset / (samples * 0.5)) 
        { 
            float closestDepth = texture(depthMap, fragToLight + vec3(x, y, z)).r; 
            closestDepth *= far_plane; 
            // Undo mapping [0;1] 
            if(currentDepth - bias > closestDepth) shadow += 1.0; 
        } 
    } 
} 
shadow /= (samples * samples * samples);

```
以上的做法有中sample设置为4，那么每个Fragment会得到4x4x4 = 64个样本，这实在有点太费了

我们可以简化一下，思路如下：
- 64个样本中大部分采样是多余的，预期在原始方向向量附近采样，不如改为在采样方向的垂直方向进行采样
- 使用一个sampleOffsetDirections方向数组，里边的元素每个都指向完全不同的方向
- 把pcf算法与从上边的sampleOffsetDirections得到的样本数量进行适配，使用它们从shadow cubemap采样

以上的结果就是需要的样本数量变少了
```cpp
// array of offset direction for sampling
vec3 gridSamplingDisk[20] = vec3[]
(
   vec3(1, 1,  1), vec3( 1, -1,  1), vec3(-1, -1,  1), vec3(-1, 1,  1), 
   vec3(1, 1, -1), vec3( 1, -1, -1), vec3(-1, -1, -1), vec3(-1, 1, -1),
   vec3(1, 1,  0), vec3( 1, -1,  0), vec3(-1, -1,  0), vec3(-1, 1,  0),
   vec3(1, 0,  1), vec3(-1,  0,  1), vec3( 1,  0, -1), vec3(-1, 0, -1),
   vec3(0, 1,  1), vec3( 0, -1,  1), vec3( 0, -1, -1), vec3( 0, 1, -1)
);

float ShadowCalculation(vec3 fragPos)
{
    // get vector between fragment position and light position
    vec3 fragToLight = fragPos - lightPos;
    // use the fragment to light vector to sample from the depth map    
    // float closestDepth = texture(depthMap, fragToLight).r;
    // it is currently in linear range between [0,1], let's re-transform it back to original depth value
    // closestDepth *= far_plane;
    // now get current linear depth as the length between the fragment and light position
    float currentDepth = length(fragToLight);
    // test for shadows
    // float bias = 0.05; // we use a much larger bias since depth is now in [near_plane, far_plane] range
    // float shadow = currentDepth -  bias > closestDepth ? 1.0 : 0.0;
    // PCF
    // float shadow = 0.0;
    // float bias = 0.05; 
    // float samples = 4.0;
    // float offset = 0.1;
    // for(float x = -offset; x < offset; x += offset / (samples * 0.5))
    // {
        // for(float y = -offset; y < offset; y += offset / (samples * 0.5))
        // {
            // for(float z = -offset; z < offset; z += offset / (samples * 0.5))
            // {
                // float closestDepth = texture(depthMap, fragToLight + vec3(x, y, z)).r; // use lightdir to lookup cubemap
                // closestDepth *= far_plane;   // Undo mapping [0;1]
                // if(currentDepth - bias > closestDepth)
                    // shadow += 1.0;
            // }
        // }
    // }
    // shadow /= (samples * samples * samples);
    float shadow = 0.0;
    float bias = 0.15;
    int samples = 20;
    float viewDistance = length(viewPos - fragPos);
    float diskRadius = (1.0 + (viewDistance / far_plane)) / 25.0;
    for(int i = 0; i < samples; ++i)
    {
        float closestDepth = texture(depthMap, fragToLight + gridSamplingDisk[i] * diskRadius).r;
        closestDepth *= far_plane;   // undo mapping [0;1]
        if(currentDepth - bias > closestDepth)
            shadow += 1.0;
    }
    shadow /= float(samples);
        
    return shadow;
}
```

![[assets/3.ShadowMapping_image_16.png]]