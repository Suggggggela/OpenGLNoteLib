
这节我们正式高级光照的内容

## 1.Phong氏模型的问题
前边我们已经学习过个Phong光照模型，但是在ReflectionDir和ViewDir夹角大于90°时，高光会出现明显的问题，具体表现为一大片高光
![405x316](assets/1.Blinn-Phong_image_1.png)

出现这个问题的原因是：当View和Reflection方向夹角超过90°，我们计算高光时使用的是`dot(vDir,rDir)`，也就是说在夹角超过90°时dot的结果为负数，以至于高光分量为0.0
对于漫反射来说，这不是什么问题，如果nDir和lDir夹角超过90°的话，那么证明光在所照表面的下方，分量为0没问题
对于高光来说，vDir和rDir超过90°的话，并且刚好反光度较小时，这时高光就会产生比较大的影响了（反光度小，pow的结果越离散，高光的半径大，产生的问题就是上边地板表现出来的情况）
我们可以通过下边这两张图理解，它表示了ViewDir与LightDir在不到和超过90°的不同情况：
![673x242](assets/1.Blinn-Phong_image_2.png)


## 2.Blinn-Phong模型
Blinn-Phong模型可以很好的解决上述Phong模型的问题
它对Phong的高光计算方式进行了改良，不使用view和Reflection进行dot，而是使用**HalfVector半程向量**和法线方向进行dot
半程向量是LightDir和ViewDir夹角一半角度方向的单位向量
它的计算方式是：![109x63](assets/1.Blinn-Phong_image_3.png)
![457x323](assets/1.Blinn-Phong_image_4.png)

那么Blinn-Phong计算高光的方式就改成了下边这样：
```cpp
vec3 lightDir = normalize(lightPos - FragPos); 
vec3 viewDir = normalize(viewPos - FragPos); 
vec3 halfwayDir = normalize(lightDir + viewDir);
float spec = pow(max(dot(normal, halfwayDir), 0.0), shininess); 
vec3 specular = lightColor * spec;
```

Blinn-Phong的高光计算结果就能避免高光断层的问题了：
![583x222](assets/1.Blinn-Phong_image_5.png)


除此之外，半程向量和法向的夹角通常会小于v和r的夹角，同等高光度下会比Phong的高光散很多，你可以在使用Blinn-Phong时设置Phong时的2-4倍的glossy

下面是Phong的glossy=8，Blinn-Phong的glossy=32时的对比：
![681x255](assets/1.Blinn-Phong_image_6.png)