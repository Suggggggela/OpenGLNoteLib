
## 1.视差映射 - ParallaxMapping
### 视差贴图
![[assets/5.ParallaxMapping_image_1.png|171x170]]
视差贴图利用的视错觉的原理，对于有深度差的效果能表达的更加
它属于位移贴图（Displacement Mapping）技术中的一种
对于这项技术，大致可以分为两种：
- 不对顶点做真实移动，利用其他方法做出效果，比如视差贴图
- 真实的移动了顶点的位置，比如置换贴图，对顶点数量的要求很高


视差贴图的思想是修改uv，使得当前Fragment的表面看起来比实际的高度更高或者更低
修改根据的是viewDir和高度图
为了方便理解我们可以看下边的示意图：
![[assets/5.ParallaxMapping_image_2.png|683x235]]
- 红线 = 假设进行位移后的物体表面
- 黑线 = 实际的物体表面
- 橙色向量 = ViewDir
- B点 = 如果进行位移后，物体表面应该在ViewDir看到的位置(Fragment)
- A点 = 实际情况下，物体表面在ViewDir实际看到的位置(Fragment)

视差想做的就是：**在实际表面的A点使用假设位移后表面的B点的uv进行采样，这样ViewDir看过来的时候，看到的就像是在B点一样了**

那么如何从A点获取B点的uv呢？
我们可以通过下边的示意图理解：
![[assets/5.ParallaxMapping_image_3.png|566x271]]
- 我们从高度图获取A点的高度H(A)
- 以H(A)作为**缩放值**，对ViewDir进行缩放，得到向量P
- 向量P与uv对齐的值(以图中黑线为u方向，那么就是P的u值)，就是A到B的uv offset值


理解之后你就会发现其实这个B点的uv是比较粗略的估算出来的
这在一般情况下或者高度变化率不大的时候比较准确
但问题是当表面变化比较快的时候，B点所在的高度和H(P)相差的就比较大了：![[assets/5.ParallaxMapping_image_4.png|598x238]]

视差贴图的另一个问题是：当表面被任意旋转以后，很难指出从P向量获取哪一个坐标作为offset值
利用之前法线在切线空间计算的思路，我们可以在一个P向量的分量总是和uv对齐的空间中计算
在切线空间中，P向量的x，y分量将于表面的tangent和bitangent对齐
我们可以直接把法线那节的图搬过来看![[assets/5.ParallaxMapping_image_5.png|334x244]]
因为在这个空间中T和B和uv方向对齐，那么对于P向量x，y分量也就和uv对齐了，这样就不用考虑表面的方向了

### 视差映射
接下来我们看看如何实际进行视差映射
首先我们准备一张高度图![[assets/5.ParallaxMapping_image_6.jpg|198x198]]
这个高度图和开始时展示的高度图是反相的，这是因为模拟**深度**实际上比模拟**高度**更容易，所以这样的贴图也被称为深度贴图
我们可以反过来看示意图：![[assets/5.ParallaxMapping_image_7.png|525x329]]
- 用向量V减去A点的uv得到向量P


接下来看看如何在shader中进行视差映射，我们直接上代码
```cpp
//VS
    //Calculate TBN Matrix
    //Transform other vectors to tangent space
    ...
    
//FS 
#version 330 core
out vec4 FragColor;

in VS_OUT {
    vec3 FragPos;
    vec2 TexCoords;
    vec3 TangentLightPos;
    vec3 TangentViewPos;
    vec3 TangentFragPos;
} fs_in;

uniform sampler2D diffuseMap;
uniform sampler2D normalMap;
uniform sampler2D depthMap;

uniform float height_scale;

vec2 ParallaxMapping(vec2 texCoords, vec3 viewDir) 
{
    //sample current fragment height = H(A)
    float height = texture(depthMap, texCoords).r; 
    
    //use H(A) scale viewDir = P
    //xy/z是normalize的操作，当带有角度的看平面时scale会更大，增加真实度
    //normalize的操作不是必须的,不进行归一化的叫做Parallax Mapping with Offset Limiting
        //这样在普通角度不尽如人意的视差情况会得到改善
    vec2 p = viewDir.xy / viewDir.z * (height * height_scale);

    //uv - offset，获取最终的uv
    return texCoords - p; 
}

void main()
{           
    //tangent space viewdir
    vec3 viewDir   = normalize(fs_in.TangentViewPos - fs_in.TangentFragPos);
    vec2 texCoords = ParallaxMapping(fs_in.TexCoords,  viewDir);

    //clamp uv
    if(texCoords.x > 1.0 || texCoords.y > 1.0 || texCoords.x < 0.0 || texCoords.y < 0.0) 
    discard;
    
    // then sample textures with new texture coords
    vec3 diffuse = texture(diffuseMap, texCoords);
    vec3 normal  = texture(normalMap, texCoords);
    normal = normalize(normal * 2.0 - 1.0);
    // Calculate Light
    ...    
}

```

![](assets/5.ParallaxMapping_video_1.mp4)


## 2.陡峭视差映射 - Steep Parallax Mapping
我们看上边视差映射的视频中，特殊的角度下还是失真的
问题的原因是我们还是大致估算的结果

陡峭视差映射是普通视差映射的拓展，它的原理不变，但是使用多个样本来确定向量P到B
它的基本思路如下：
- 将总深度划分为数层，每层变化率一样（层数越多越准确）
- 从每一层中沿着P向量方向移动uv采样深度图，直到找到一个低于当前层的深度值

![[assets/5.ParallaxMapping_image_8.png|558x301]]
- 图中红色线 = 深度图采样到的深度
- T2，这一层是第二层，Layer的深度为0.4，采样深度图的深度约为0.73，深度图深度>Layer深度，所以继续
- T3，这一层是第三层，Layer深度为0.6，采样深度图的深度约为0.37，深度图深度<Layer深度，那么说明这一点可以作为物体表面的位移几何信息

```cpp
vec2 SteepParallaxMapping(vec2 texCoords, vec3 viewDir)
{ 
    //Layer
    //这里使用ViewDir计算出垂直于表面的方向来减少垂直方向的采样样本
    //（0，0,1）Z轴方向是切线空间中法线的朝向
    const float minLayers = 8;
    const float maxLayers = 32;
    float numLayers = mix(maxLayers, minLayers, abs(dot(vec3(0.0, 0.0, 1.0), viewDir)));  
    //计算Layer层数
    float layerDepth = 1.0 / numLayers;
    
    float currentLayerDepth = 0.0;
    
    //根据P向量计算uv移动量
    vec2 P = viewDir.xy / viewDir.z * heightScale; 
    vec2 deltaTexCoords = P / numLayers;
  
    vec2  currentTexCoords     = texCoords;
    float currentDepthMapValue = texture(depthMap, currentTexCoords).r;
    
    //如果深度图深度>当前Layer深度，就继续  
    while(currentLayerDepth < currentDepthMapValue)
    {
        //根据P向量方向移动tv
        currentTexCoords -= deltaTexCoords;
        //采样深度贴图的深度
        currentDepthMapValue = texture(depthMap, currentTexCoords).r;  
        //get depth of next layer
        currentLayerDepth += layerDepth;  
    }
    
    return currentTexCoords;
}

```
![](assets/5.ParallaxMapping_video_2.mp4)

可以看到特定角度下的情况已经好很多了，但是如果heightscale给太大的话，有一层层的断层
这种情况可以通过增加样本数减少，但是这个性能本来就不咋地了，加了之后更差

有些旨在修复这个问题的方法，比较流行的有Relief Parallax Mapping（浮雕视差映射），Parallax Occlusion Mapping（视差遮蔽/闭塞映射）


## 3.视差遮蔽映射-Parallax Occlusion Mapping
POM的原则和陡峭视差映射相同，但是不用计算出可用的那一层uv
而是**使用相交前后Layer的高度贴图采样值与两层Layer的高度差(距离)作为的权重，对这两层的uv做一个Lerp，作为uv使用**
![[assets/5.ParallaxMapping_image_9.png]]
- H(T3)点处蓝线 = 0.6这一层Layer深度值和这一层Layer在深度图采样的深度的高度差
- H(T2)点处蓝线 = 0.4这一层Layer深度值和这一层在深度贴图深度的高度差
- 这两条蓝线和这两个点相连的黄色线、这两点所在Layer处紫色点相连的紫色线，组成了一组相似三角形
- 这样就可以得到紫线之间的比例，进而对应到uv偏移的结果，使得结果更准确

```cpp
vec2 ParallaxOcclusionMapping(vec2 texCoords, vec3 viewDir)
{
    const float minLayers = 8;
    const float maxLayers = 32;
    float numLayers = mix(maxLayers, minLayers, abs(dot(vec3(0.0, 0.0, 1.0), viewDir)));  
    float layerDepth = 1.0 / numLayers;
    float currentLayerDepth = 0.0;

    vec2 P = viewDir.xy / viewDir.z * heightScale; 
    vec2 deltaTexCoords = P / numLayers;

    vec2  currentTexCoords     = texCoords;
    float currentDepthMapValue = texture(depthMap, currentTexCoords).r;
      
    while(currentLayerDepth < currentDepthMapValue)
    {
        currentTexCoords -= deltaTexCoords;
        currentDepthMapValue = texture(depthMap, currentTexCoords).r;  
        currentLayerDepth += layerDepth;  
    }
    //以上都和陡峭视差一样


    //相交前的uv
    vec2 prevTexCoords = currentTexCoords + deltaTexCoords;

    //相交前后的深度
    float afterDepth  = currentDepthMapValue - currentLayerDepth;
    float beforeDepth = texture(depthMap, prevTexCoords).r - currentLayerDepth + layerDepth;
 
    // interpolation of texture coordinates
    float weight = afterDepth / (afterDepth - beforeDepth);
    //以下和lerp一样，只不过用公式写出来了
    vec2 finalTexCoords = prevTexCoords * weight + currentTexCoords * (1.0 - weight);
    

    return finalTexCoords;
}
```

![](assets/5.ParallaxMapping_image_10.png)
## 4.浮雕视差映射-Relief Parallax Mapping
浮雕映射的核心思路是不像steep那样进行分层，而是在P向量方向通过二分法在深度范围内进行查找合适的点
这个点想要满足的条件是：**在该点处采样深度贴图得到的深度尽可能接近该点所处Layer的深度**
类似这样![[assets/5.ParallaxMapping_image_11.png|444x330]]
- 在点A和B之间取中间点，得到点1，以此类推直到得到点3

但是这样做在一些表面会出现错误，比如：
![[assets/5.ParallaxMapping_image_12.png|428x313]]
- 使用二分法会先得到点1，然后是点2，点3，但是此时的3实际上已经被遮挡了，正确的应该是A点附近和高度相交的蓝点

为了避免这个问题，我们可以先利用steep得到RayMarching的结果，找到低于高度图深度的第一个Layer，然后再和点A连线进行二分查找
![[assets/5.ParallaxMapping_image_13.png|430x318]]

```cpp
vec2 ReliefParallaxMapping(vec2 texCoords, vec3 viewDir)
{
    const float minLayers = 8;
    const float maxLayers = 32;
    float numLayers = mix(maxLayers, minLayers, abs(dot(vec3(0.0, 0.0, 1.0), viewDir)));  
    float layerDepth = 1.0 / numLayers;
    float currentLayerDepth = 0.0;

    vec2 P = viewDir.xy / viewDir.z * heightScale; 
    vec2 deltaTexCoords = P / numLayers;

    vec2  currentTexCoords     = texCoords;
    float currentDepthMapValue = texture(depthMap, currentTexCoords).r;
      
    while(currentLayerDepth < currentDepthMapValue)
    {
        currentTexCoords -= deltaTexCoords;
        currentDepthMapValue = texture(depthMap, currentTexCoords).r;
        currentLayerDepth += layerDepth;  
    }
    //以上都和陡峭视差一样


    //得到Steep的结果后，开始二分查找
    //我们希望当前Layer的深度和DepthMap深度足够接近
    vec2 halfDeltaTexCoords = deltaTexCoords / 2;
    float halfLayerDepth = layerDepth / 2;
    //往中点偏移
    currentTexCoords += halfDeltaTexCoords;
    currentLayerDepth += halfLayerDepth;
    
    
    int numSearches = 5;//可以自己拿imgui传进来看看多少次合适
    for(int i = 0; i < numSearches; i++)
    {
        //二分
        halfDeltaTexCoords = halfDeltaTexCoords / 2;
        halfLayerDepth = halfLayerDepth / 2;
        //采样深度贴图的深度
        currentDepthMapValue = texture(depthMap, currentTexCoords).r;
        
        //当前Layer深度和采样到的深度做比较
        if(currentDepthMapValue > currentLayerDepth)
        {
            //如果深度图深度>当前Layer深度，那么当前uv太浅了，需要往深处移动
            currentTexCoords -= halfDeltaTexCoords;
            //更新Layer深度，增加，让它更接近DepthMap深度
            currentLayerDepth += halfLayerDepth;
        }
        else
        {
            //如果深度图深度<当前Layer深度，那么当前uv太深了，需要往浅出移动
            currentTexCoords += halfDeltaTexCoords;
            //更新Layer深度，减少，让它更接近DepthMap深度
            currentLayerDepth -= halfLayerDepth;
        }
    }

    return currentTexCoords;
}
```

![](assets/5.ParallaxMapping_video_3.mp4)



## 5.Parallax Shadow
视差可以通过视差的结果，反过来从光源的方向进行查找，如果有遮挡的话那么就说明这个点在阴影中
![[assets/5.ParallaxMapping_image_14.png|432x279]]


//TODO
这部分写的有问题，后续有时间再看看是为啥
视差位置的阴影全是黑的
```cpp
//利用POM的结果反过来向上查找相交点，如果有那么意味着被遮挡了 = 阴影
//阴影的强度可以根据相交点数量决定
//并且做了软阴影
float ParallaxShadow(vec3 lightDir, vec2 texCoords)
{
    float shadowMultiplier = 1.0; //默认乘1 = 没有阴影
    const float minLayers = 8;
    const float maxLayers = 32;
    if(dot(vec3(0.0, 0.0, 1.0), lightDir) > 0 )
    {
        float numLayers = mix(maxLayers, minLayers, abs(dot(vec3(0.0, 0.0, 1.0), lightDir)));
        //float layerHeight = 1.0 / numLayers;
        float layerHeight = texture(depthMap, texCoords).r / numLayers;
        vec2 texStep = lightDir.xy / lightDir.z * heightScale / numLayers;
    
        //向上查找是否有相交点
        //初始化
        vec2 currentTexCoords = texCoords;
        float currentDepthMapValue = texture(depthMap, currentTexCoords).r;
        float currentLayerHeight = currentDepthMapValue;
    
        int stepIndex = 1;//向上查找的步数
        float numSamplesUnderSurface = 0; //统计被遮挡的层数
        
        while(currentLayerHeight > 0)
        {   
            //如果深度贴图采样的深度小于当前Layer深度，那么说明有遮挡
            if(currentDepthMapValue <= currentLayerHeight)
            {    
                numSamplesUnderSurface += 1;
                //阴影衰减，越浅的地方阴影越弱
                float atten = (1 - stepIndex / numLayers);
                //阴影强度
                float newShadowMultiplier = (currentLayerHeight - currentDepthMapValue) * atten;
                shadowMultiplier = max(shadowMultiplier, newShadowMultiplier);
            }
            
            stepIndex += 1;
            currentTexCoords += texStep;
            currentLayerHeight -= layerHeight;
            currentDepthMapValue = texture(depthMap, currentTexCoords).r;
        }
    
        if(numSamplesUnderSurface < 1)//如果向上没找到交点，那么说明没有遮挡 = 没有阴影
            shadowMultiplier = 1.0;
        else
            shadowMultiplier = 1.0 - shadowMultiplier;
    
    }

    return shadowMultiplier;
}

```

![[assets/5.ParallaxMapping_image_15.png|727x545]]