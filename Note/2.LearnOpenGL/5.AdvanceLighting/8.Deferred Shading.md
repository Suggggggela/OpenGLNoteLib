
## 1.渲染路径
### Forward Rendering 
目前为止我们一直在使用的是ForwardRendering，前向渲染
前向渲染是指场景中的所有物体，每个光源都需要遍历一遍来计算光照，这样渲染的思路是比较直觉的，但是当光源数量多起来的时候，整个场景的计算量就会很高
![377x203](assets/8.Deferred%20Shading_image_1.png)



### Deferred Rendering
还有一种渲染的思路成为Deferred Rendering，延迟渲染
延迟渲染的延迟是指将光照计算延迟（defer，或者叫做postpone），先获取场景的信息，最后再进行统一的光照计算，既将几何信息和光照计算分开来进行
![|370x266](assets/8.Deferred%20Shading_image_2.png)

上述的Forward和Deferred都叫做渲染路径，其实就是描述渲染是如何进行的

延迟渲染包含连个步骤或者说pass：
- Geometry Pass：先渲染场景一次，获取场景的几何信息，存储到一个G-Buffer中
- 利用G-Buffer中的数据进行光照计算


本篇的重点是延迟渲染，接下来我们分部分完成一个延迟渲染的例子

## 2.Deferred Rendering
### Geometry Buffer Pass

一个GBuffer类似下图这样：
![453x336](assets/8.Deferred%20Shading_image_3.png)
或者你可以直接打开UE，一个场景的G-Buffer类似下边这样：
![528x306](assets/8.Deferred%20Shading_image_4.png)

G-Buffer中存储着所有用来计算光照的数据
回顾之前的代码，我们在计算一个光照模型时，需要以下的数据：
- Position
- Albedo，或者说漫反射
- Normal
- Specular
- Light Data
- Camera/Player Data


我们这里的G-Buffer包含前四个部分，对于Position和Normal我们给16位的精度，其他两个给8位精度
因为GPU更倾向于四个分量格式，我们都给RGBA格式，否则可能会因为某些驱动出现问题
```cpp
//CPU端配置使用MRT特性的G-buffer FrameBuffer
 unsigned int gBuffer;
 glGenFramebuffers(1, &gBuffer);
 glBindFramebuffer(GL_FRAMEBUFFER, gBuffer);
 unsigned int gPosition, gNormal, gAlbedoSpec;//对应GBuffer的数量
 // position color buffer
 glGenTextures(1, &gPosition);
 glBindTexture(GL_TEXTURE_2D, gPosition);
 glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGBA, GL_FLOAT, NULL);
 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
 glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, gPosition, 0);
 // normal color buffer
 glGenTextures(1, &gNormal);
 glBindTexture(GL_TEXTURE_2D, gNormal);
 glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGBA, GL_FLOAT, NULL);
 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
 glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D, gNormal, 0);
 // RGB = color , A = specular color buffer
 glGenTextures(1, &gAlbedoSpec);
 glBindTexture(GL_TEXTURE_2D, gAlbedoSpec);
 glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
 glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT2, GL_TEXTURE_2D, gAlbedoSpec, 0);
 //显式的告诉OpenGL MRT数量 
 unsigned int attachments[3] = { GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1, GL_COLOR_ATTACHMENT2 };
 glDrawBuffers(3, attachments);
 
 // create and attach depth buffer (renderbuffer)
 unsigned int rboDepth;
 glGenRenderbuffers(1, &rboDepth);
 glBindRenderbuffer(GL_RENDERBUFFER, rboDepth);
 glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT, SCR_WIDTH, SCR_HEIGHT);
 glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, rboDepth);
 
 // finally check if framebuffer is complete
 if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
     std::cout << "Framebuffer not complete!" << std::endl;
 glBindFramebuffer(GL_FRAMEBUFFER, 0);

While(Rendering)
{
    //-----Pass0：几何处理阶段：渲染所有的几何/颜色数据到G缓冲----- 
    glBindFramebuffer(GL_FRAMEBUFFER, gBuffer); 
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); 
    gBufferShader.Use(); 
    for(Object obj : Objects) 
    { 
        ConfigureShaderTransformsAndUniforms(); 
        obj.Draw(); 
    }
}


```

在Shader中，我们利用现代GPU的MRT特性，一次输出多个target作为G-Buffer使用
因为后边我们会在其他shader中使用这些数据计算光照，所以这些数据要是一个空间的
```cpp
//FS
#version 330 core
//G-Buffers
layout (location = 0) out vec3 gPosition;
layout (location = 1) out vec3 gNormal;
layout (location = 2) out vec4 gAlbedoSpec;

in vec2 TexCoords;
in vec3 FragPos;
in vec3 Normal;

uniform sampler2D texture_diffuse1;
uniform sampler2D texture_specular1;

void main()
{    
    // store the fragment position vector in the first gbuffer texture
    gPosition = FragPos;
    // also store the per-fragment normals into the gbuffer
    gNormal = normalize(Normal);
    // and the diffuse per-fragment color
    gAlbedoSpec.rgb = texture(texture_diffuse1, TexCoords).rgb;
    // store specular intensity in gAlbedoSpec's alpha component
    gAlbedoSpec.a = texture(texture_specular1, TexCoords).r;
}
```


### Deferred Lightting Pass
第一个Pass已经将场景中的几何数据存储到G-Buffer中
如果将G-Buffer的数据直接采样输出就类似下边这样：
![465x352](assets/8.Deferred%20Shading_image_5.png)
接下来我们使用这些数据进行光照计算

CPU端，绑定这些G-Buffer，然后将灯光数据通过Uniform传到Shader，进行光照计算，然后绘制一个全屏Quad
```cpp
while(Rendering)
{
    //pass0:G-Buffer Pass
    ...
    
    //pass1:Deferred Lightting Pass
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    shaderLightingPass.use();
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, gPosition);
    glActiveTexture(GL_TEXTURE1);
    glBindTexture(GL_TEXTURE_2D, gNormal);
    glActiveTexture(GL_TEXTURE2);
    glBindTexture(GL_TEXTURE_2D, gAlbedoSpec);
    // send light relevant uniforms
    for (unsigned int i = 0; i < lightPositions.size(); i++)
    {
        shaderLightingPass.setVec3("lights[" + std::to_string(i) + "].Position", lightPositions[i]);
        shaderLightingPass.setVec3("lights[" + std::to_string(i) + "].Color", lightColors[i]);
        // update attenuation parameters and calculate radius
        const float linear = 0.7f;
        const float quadratic = 1.8f;
        shaderLightingPass.setFloat("lights[" + std::to_string(i) + "].Linear", linear);
        shaderLightingPass.setFloat("lights[" + std::to_string(i) + "].Quadratic", quadratic);
    }
    shaderLightingPass.setVec3("viewPos", camera.Position);
    // finally render quad
    renderQuad();
}
```

![8.Deferred Shading_image_6](assets/8.Deferred%20Shading_image_6.png)

### 延迟渲染的问题
延迟渲染的情况下，虽然大大的提升了光照计算的效率，但是还是存在一些问题，比如：
- 无法进行Blending（G-Buffer的数据都是逐像素的，但是Blending需要多个像素混合）
- 无法任意修改光照模型（场景所有物体的光照计算是在一个Pass完成的）
- 带宽要求高（G-Buffer需要存的数据比较多）

还有一些问题没有一一列举，但这些已经够咱们喝一壶的了

为了解决这些问题，我们可以使用Deferred 和 Forward 结合的方式进行渲染
还有一些其他的就不多说了，具体可以自行查阅
[渲染路径(Rendering Path)与常见渲染技术 ](https://zhuanlan.zhihu.com/p/381682257)
## 3.Forward和Deferred结合
上边我们已经用Deferred Rendering的方法渲染了一个场景，这个场景有一堆点光源
现在如果我们想用纯色cube来代表灯光，你就可以在后边使用Forward的方式渲染这些cube

### 获取DeferredPass的深度信息
首先我们要获取上个阶段的深度信息，如果没有正确的深度，渲染的灯光cube就只能一直在最前面了

```cpp
while(Rendering)
{
    //deferred rendering pass
    ...
    
    //deferred part depth
    //绑定Read和Draw Buffer
    glBindFramebuffer(GL_READ_FRAMEBUFFER, gBuffer);
    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0); 
    // write to default framebuffer
    // blit to default framebuffer. Note that this may or may not work as the internal formats of both the FBO and default framebuffer have to match.
    // the internal formats are implementation defined. This works on all of my systems, but if it doesn't on yours you'll likely have to write to the 		
    // depth buffer in another shader stage (or somehow see to match the default framebuffer's internal format with the FBO's internal format).
    //将gBuffer的Depth Blit到默认的FrameBuffer
    glBlitFramebuffer(0, 0, SCR_WIDTH, SCR_HEIGHT, 0, 0, SCR_WIDTH, SCR_HEIGHT, GL_DEPTH_BUFFER_BIT, GL_NEAREST);
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
}
```
### 使用前向方式绘制灯光cube
把Deferred阶段的深度信息blit到默认FrameBuffer后，我们就可以使用默认的FrameBuffer绘制灯光cube了
```cpp
 //glClear(GL_DEPTH_BUFFER_BIT);
 //你可以clear一下深度信息，这样相当于没有前边获取DeferredPart的深度
 //绘制出的cube就会在scene所有物体的前边
 
 shaderLightBox.use();
 shaderLightBox.setMat4("projection", projection);
 shaderLightBox.setMat4("view", view);
 for (unsigned int i = 0; i < lightPositions.size(); i++)
 {
     model = glm::mat4(1.0f);
     model = glm::translate(model, lightPositions[i]);
     model = glm::scale(model, glm::vec3(0.125f));
     shaderLightBox.setMat4("model", model);
     shaderLightBox.setVec3("lightColor", lightColors[i]);
     renderCube();
 }
```
![8.Deferred Shading_image_7](assets/8.Deferred%20Shading_image_7.png)

![8.Deferred Shading_image_8](assets/8.Deferred%20Shading_image_8.png)
## 4.更多光源
延迟渲染被称赞的原因大部分来自于他能用可接受的性能渲染大量光源，但是这个光源也是有数量级限制的
它做的优化说到底就是从**场景的每个物体都遍历每个光源->屏幕的每个像素都遍历每个光源**

如果想再进一步优化，我们可以引入一个概念：**Light Volumes 光体积**
上边我说了，Deferred Rendering计算光照时，对于每个像素会计算每个光源的贡献，很显然这里没有考虑光源到这个像素的距离
如果这个光源离这个像素非常远，我们就可以忽略这个光源的影响不进行计算，进而完成优化

Light Volume描述的就是光源的半径，或者体积，也就可以描述光源到片段的距离
有了这个概念，我们在计算光照时，就可以只计算光源范围内的像素，而不是所有像素都遍历了

### 计算一个光源的体积
回想之前计算光源衰减的部分，其实这个衰减就是定义了一个光源的体积
这里我们引入一个比之前衰减更复杂但是更灵活的公司：
![341x58](assets/8.Deferred%20Shading_image_9.png)

其中F_light就是光的亮度，想解出光的体积，那么就是光的亮度=0的解
然而这个公式在0下是没有解的，所以我们会求亮度靠近于0的解，这个时候我们假设光源的亮度还是黑的，也就是对像素不产生影响的

这里我们选择256/5作为亮度来解（除以256是因为默认8位精度的FrameBuffer每个分量只能显示这么多）
这时衰减方程会是这样的：
![168x42](assets/8.Deferred%20Shading_image_10.png)
- I_Max = 光源最亮的颜色分类

我们继续解方程：
![412x236](assets/8.Deferred%20Shading_image_11.png)
到此为止，方程就表示为ax<sup>2</sup>+bx+c = 0 的方式了
求解如下：
![471x79](assets/8.Deferred%20Shading_image_12.png)

代码形式如下：
```cpp
GLfloat constant  = 1.0;//kc
GLfloat linear    = 0.7;//kl
GLfloat quadratic = 1.8;//kq
GLfloat lightMax  = std::fmaxf(std::fmaxf(lightColor.r, lightColor.g), lightColor.b);
GLfloat radius    = 
  (-linear +  std::sqrtf(linear * linear - 4 * quadratic * (constant - (256.0 / 5.0) * lightMax))) 
  / (2 * quadratic); 
```
这样会返回一个大概1~5范围半径的体积，具体数值由光源强度决定

有了Light Volume之后，我们就可以根据每个光源的Volume进行裁剪，只计算每个光源范围内的像素
```cpp
 struct Light {
    ...
    float Radius;
}; 

void main()
{
    ...
    for(int i = 0; i < NR_LIGHTS; ++i)
    {
        // 计算光源和该片段间距离
        float distance = length(lights[i].Position - FragPos);
        if(distance < lights[i].Radius)
        {
            //Calculate lighting
        }
    }   
}
```



### 真正的使用Light Volume
上边的代码只是用来讲解原理，实际中我们可能不希望在shader中做这些根据片元距离的判断（GPU更擅长做并行的内容，不擅长分支）
//关于分支，shader中处理分支的方式是走完所有分支，这也就意味着虽然结果中是没有计算，实际上还是计算了，相当于没优化

如果要真正的使用Light Volume，我们需要做的类似下边的
我们可以根据光源体积真正的渲染一个球体，这个球体的中心是光源的位置
这些球体所在的像素完全匹配的受光源影响的像素，在遍历光源时就只会遍历需要光照的像素了
![642x217](assets/8.Deferred%20Shading_image_13.png)

这样做的问题是需要开启Face Culling，否则球的正反面就会导致计算两次光照
但是开启面剔除时，如果你处于光源体积内部，因为剔除的原因光源就消失了
你可以通过模板缓冲来解决这个问题


## 5.更多渲染路径
除了正向和延迟渲染之外，常见的渲染路径还有：
- Deferred Lighting/ Light Pre-Pass 延迟光照
- Tile-Based Deferred Rendering 分块延迟渲染
- Forward+ / Tile-Based Forward Rendering 分块前向渲染
- Clustered Rendering 群组渲染



## 延伸阅读
[3.4 前向_延迟渲染管线介绍](../../../../../【7.CouseNote】/【TA100】/T/3.4%20前向_延迟渲染管线介绍.md)
[7.渲染管线、后处理、其他](../../../../../【7.CouseNote】/【GraphicCourse】/【GAMES104】/7.渲染管线、后处理、其他.md)
[浅墨RTR3总结-渲染路径](https://github.com/QianMo/Game-Programmer-Study-Notes/tree/master/Content/%E3%80%8AReal-Time%20Rendering%203rd%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Content/BlogPost07)

