
之前在百人计划中整理的笔记可以参考：[2.6伽马（Gamma）校正](../../../../../【7.CouseNote】/【TA100】/T/2.6伽马（Gamma）校正.md)

## 1.Gamma
Gamma又叫灰度系数，每个显示器都有自己的Gamma值
Gamma的公式为： 输出亮度 = 电压<sup>Gamma</sup>

早期CRT显示的物理特性是双倍输入电压并不能产生双倍的亮度，如果用上边的公式的话，这个Gamma约为2.2，所以2.2也是显示器Gamma（也叫**sRGB**颜色空间）
任何设备的Gamma基本都不会等于1， 1基本上是一个理想数值
Gamma2.2的情况下，实际显示出来的会比预期暗一点，而0.45比预期亮，如果将后者叠加到前者上，就是一种**Gamma校正**


## 2.灰度
人眼对暗部的感知是比较敏感的，更倾向于顶部的灰阶
我们正常人眼觉得灰度变化（也就是美术说的灰度）和实际物理的灰度变化是不一样的

以下第一行是美术的灰度，第二行是物理的灰度（均为线性）
![[assets/2.Gamma校正_image_1.png|706x107]]

可以看到人眼觉得的0.5，只是真实物理的0.2左右（物理灰度指的就是光子数量倍数，比如0.2是0.1的二倍）
所以说人眼对亮度或者说灰度的感知，是符合CRT显示器的Gamma的，但是显示器的Gamma2.2**不是线性的**


这个非线性会造成：当我们进行渲染计算时，对于非线性的曲线很挠头
比如：
            在计算时，我们默认在线性情况下，(0.5,0.0,0.0)的颜色翻倍就是(1.0,0.0,0.0)
            但是在显示器的Gamma2.2情况下，这个颜色翻倍应该是(0.28,0.0,0.0)左右
            结果就是：亮度从应该的0.28->1.0 ，翻了将近5倍
            ![[assets/2.Gamma校正_image_2.png|274x278]]

值得注意的是，上图中最低亮度0和最高亮度1，无论是理想的Gamma1.0还是显示器的Gamma2.2都是一样的
这样情况下，不进行Gamma校正出现的情况就是下边这样：（画面的中间灰度将会非常糟糕）
![[assets/2.Gamma校正_image_3.png]]



## 3.Gamma校正
接下来我们看看如何进行Gamma校正
它的思路如下：
            拟合出一条可能抵消Gamma2.2的曲线（参考上一节的虚线），我们在线性空间计算完成后，使用这个拟合的曲线抵消Gamma2.2的变暗，让屏幕显示出理想的颜色


### 方法1：直接OpenGL配置Gamma校正

```cpp
glEnable(GL_FRAMEBUFFER_SRGB);
```
执行这个cmd之后，OpenGL后续的绘制中，每次FS运行后续的帧缓冲都会自动执行Gamma校正

### 方法2：手动Gamma校正
你当然可以自己进行Gamma校正，方法就是在所有线性计算之后，最后输出颜色时进行Pow

```cpp
void main() 
{ 
    // 在线性空间做炫酷的光照效果 
    [...] 
    // 应用伽马矫正 
    float gamma = 2.2; 
    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/gamma)); 
}
```


## 4.sRGB Texture
到此为止我们都明白显示器的Gamma是2.2，也就是说我们看到的东西都是经过Gamma2.2的
这些看到的东西也包括一种东西：Texture
纹理是艺术家们在各种DCC中绘制的，绘制的时候看的是Gamma2.2的情况

但是当我们把这张在Gamma2.2空间中绘制的纹理读取进shader进行计算时，就会出问题了
进行计算时，我们默认是Gamma1.0的线性空间，如果这时直接对纹理的颜色输出，情况如下：
![[assets/2.Gamma校正_image_4.png|672x248]]
如上图，不进行Gamma校正的看起来是正确的，因为进行Gamma校正的右边实际上被进行了两次校正（输出纹理时+输出计算时）

为了解决上边的情况，计算是，我们一般会将**颜色图**进行反向校正，将其转换为线性空间
这也是引擎中导入贴图勾选sRGB所做的事情
```cpp
float gamma = 2.2; 
vec3 diffuseColor = pow(texture(diffuse, texCoords).rgb, vec3(gamma));
```
这样一来，导入的颜色图转换到了线性空间，经过计算后结果再进行Gamma校正，结果就是正确的了


OpenGL中也提供了类似引擎的sRGB选项配置
```cpp
//GL_SRGB代表Texture是Gamma2.2的，OpenGL会自动将其转换到线性空间
//如果Texture有透明通道，那么就是GL_SRGB_ALPHA
glTexImage2D(GL_TEXTURE_2D, 0, GL_SRGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, image);
```

值得注意的是，并不是所有纹理都需要转换到线性空间，上边我们也说了，需要转化的是颜色图，对于粗糙度金属度法线等本来就是线性数据的贴图，不需要进行这一步操作


## 5.光照衰减
之前我们在进行光照衰减计算时，那部分的内容是
- 物理上光的衰减应该和距离的平方成反比`attenuation = 1.0 / (distance * distance);`
- 实际上输出到屏幕发现平方的时候发现衰减效果过于强烈，所以改成了和距离成反比`attenuation = 1.0 / distance;`


回顾这节Gamma校正的内容，我们应该知道为什么了：光照的衰减也被CRT进行了Gamma2.2
也就是说平方反比的情况下实际显示是：(1.0/ distance<sup>2 </sup>)<sup>2.2</sup>
而改为直接反比的实际显示是(1.0/ distance)<sup>2.2</sup>
很显然第二个更符合物理上

