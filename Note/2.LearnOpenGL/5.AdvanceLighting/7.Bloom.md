
## 1.Bloom
bloom就是特效或者美术同学常说的辉光效果，bloom是常见的后处理效果
具体表现就是超过1部分的亮度会更加亮，有光晕的效果
bloom和HDR结合也会对屏幕的画面给到一个很大的提升
![595x170](assets/7.Bloom_image_1.png)

它的核心思想是：提取出图像中亮度超过阈值的范围，进行模糊，然后叠加到原图
![516x224](assets/7.Bloom_image_2.png)

接下来我们看看如何进行bloom

### 提取亮色
这一部分想要的内容说明白点就是：
- 场景
- 场景的亮部

我们可以渲染场景两次来渲染到FrameBuffer中
这里，我们可以使用一个特性叫做MRT（MultipleRenderTarget），既可以在FS中输出多个目标，这样就可以渲染一次场景同时获取原图和亮部了

想使用MRT，必须在FrameBufferObject上附加多个ColorAttachment（回想下，之前给FB添加ColorAttachment时，都是绑定到GL_COLOR_ATTACHMENT0），并且显式的告诉OpenGL现在FrameBuffer有两个ColorAttachment
```cpp
    unsigned int hdrFBO;
    glGenFramebuffers(1, &hdrFBO);
    glBindFramebuffer(GL_FRAMEBUFFER, hdrFBO);
    //创建两个ColorBuffer
    unsigned int colorBuffers[2];
    glGenTextures(2, colorBuffers);
    //把两个ColorBuffer Attach到FBO
    for (unsigned int i = 0; i < 2; i++)
    {
        glBindTexture(GL_TEXTURE_2D, colorBuffers[i]);
        glTexImage2D(
            GL_TEXTURE_2D, 0, GL_RGB16F, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGB, GL_FLOAT, NULL
        );
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
        // attach texture to framebuffer
        // GL_COLOR_ATTACHMENT0 + i
        glFramebufferTexture2D(
            GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + i, GL_TEXTURE_2D, colorBuffers[i], 0
        );
    }
    
    //显式的告诉OpenGL有两个ColorBuffer，否则它只会渲染到第一个colorattachment忽略其他的 
    unsigned int attachments[2] = { GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1 };
    //告诉OpenGL正在通过glDrawBuffers渲染到多个颜色缓冲
    glDrawBuffers(2, attachments);
    
    // finally check if framebuffer is complete
    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
        std::cout << "Framebuffer not complete!" << std::endl;
    glBindFramebuffer(GL_FRAMEBUFFER, 0);

```


接下来就可以在FS中使用location布局修饰符输出多个ColorBuffer
```cpp
    #version 330 core
    layout(location = 0) out vec4 FragColor;
    layout(location = 1) out vec4 BrightColor;

    ...

        void main()
    {
        ...
        
        //原图
        FragColor = vec4(lighting, 1.0f);
        
        //先转换为灰度，然后提取亮部
        float brightness = dot(FragColor.rgb, vec3(0.2126, 0.7152, 0.0722));
        if (brightness > 1.0)
            BrightColor = vec4(FragColor.rgb, 1.0);
    }

```
两个输出的ColorBuffer类似下边这样：
![638x232](assets/7.Bloom_image_3.png)


### 模糊亮部
#### 高斯模糊
提取出亮部之后，接下来我们对亮部进行模糊
这里我们使用的是高斯模糊
高斯模糊会**加权平均**像素周围，提供模糊的效果
高斯模糊的曲线是一个钟形曲线，中间最大两边不断减少，在数学上有不同的形式，通常如下：
![295x203](assets/7.Bloom_image_4.png)
使用这个曲线对像素周围进行平均，并且按照曲线作为权重，就可以做平均模糊
具体在Shader中就是做一个二维权重正方形的Filter，假设是32x32的kernel，那么每个像素就是32 x 32 = 1024次采样
这个数量级看着就很吓人
#### 高斯Kernel优化
幸运的是，我们可以利用二维高斯Kernel的特性进行优化

利用**可分离性**，高斯模糊的二维方程可以分解为两个更小的方程：一个描述水平权重，一个描述垂直权重
这样一来就是32+32次采样了，这样的做法叫做分部(两部)高斯模糊
![604x161](assets/7.Bloom_image_5.png)

如果具体一点，采用下边这个5x5的kernel，就是下边这样：
将每列相加就得到了行的Kernel，将每行相加就得到了列的Kernel
![654x263](assets/7.Bloom_image_6.png)

对于这个具体的kernel，我们可以通过更进一步：这些权重有重复，我们只需要以下三个权重就可以了（0.0545、0.2442、0.4026）

#### 进行模糊
有了上边了理论，我们就可以着手模糊操作了
应用Kernel进行模糊实际在做的就是**卷积**，这里我们不多赘述了，具体可以看看其他笔记和文章
[4.1 Bloom算法](../../../../../【7.CouseNote】/【TA100】/T/4.1%20Bloom算法.md)
[如何通俗易懂地解释卷积]( https://www.zhihu.com/question/22298352/answer/228543288)
![437x290](assets/7.Bloom_image_7.gif)

在CPU端，我们需要创建一对FrameBufferObject，通过一种“乒乓”的操作来回的进行高斯模糊
具体的讲就是：先在第一个FrameBuffer中进行模糊，然后把第一步的结果放到第二个FrameBuffer中进行模糊，然后来回这样直到模糊完成

```cpp
//CPU端

// two ping-pong-framebuffer for blurring
unsigned int pingpongFBO[2];
unsigned int pingpongColorbuffers[2];
glGenFramebuffers(2, pingpongFBO);
glGenTextures(2, pingpongColorbuffers);
for (unsigned int i = 0; i < 2; i++)
{
    glBindFramebuffer(GL_FRAMEBUFFER, pingpongFBO[i]);
    glBindTexture(GL_TEXTURE_2D, pingpongColorbuffers[i]);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGBA, GL_FLOAT, NULL);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); // we clamp to the edge as the blur filter would otherwise sample repeated texture values!
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, pingpongColorbuffers[i], 0);
    // also check if framebuffers are complete (no need for depth buffer)
    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
        std::cout << "Framebuffer not complete!" << std::endl;
}

while(Rendering)
{
    //-----pass0:render scene-------
    ...
    
    //-----pass1:blur---------------
    bool horizontal = true, first_iteration = true;
    unsigned int amount = 10;//blurAmount = 5 horizontal + 5 vertical
    shaderBlur.use();
    
        //第一次迭代：
            //迭代绑定ColorBuffer1，里边存的是提取出来的亮部
            //使用shader对水平进行第一次模糊
            //此时horizontal=1，绑定的FrameBuffer为pingpongFB1，模糊的结果在此FrameBuffer中
        //第二次迭代：
            //那么此时horizontal = 0，绑定的FrameBuffer为pingpongFB0
            //此时绑定pingpongFB1的ColorBuffer(第一次模糊的结果)
            //使用shader进行垂直第一次模糊
            //这一次模糊的结果在pingpongFB0的ColorBuffer中
        //第三次迭代：
            //此时horizontal = 1，绑定的FrameBuffer为pingpongFB1
            //此时绑定pingpongFB0的ColorBuffer(第二次模糊的结果)
            //使用shader进行第二次水平模糊
            //这一次模糊的结果存在pingpongFB1的ColorBuffer中
        //...以此类推直到模糊结束
    for (unsigned int i = 0; i < amount; i++)
    {
        glBindFramebuffer(GL_FRAMEBUFFER, pingpongFBO[horizontal]);//绑定用于blur的FrameBuffer
        shaderBlur.setInt("horizontal", horizontal);
        glBindTexture(GL_TEXTURE_2D, 
        first_iteration ? colorBuffers[1] : pingpongColorbuffers[!horizontal]);
        renderQuad();
        horizontal = !horizontal;
        if (first_iteration)
            first_iteration = false;
    }
    
    //模糊结束后解绑
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
}

```


```cpp
//Shader
#version 330 core
out vec4 FragColor;

in vec2 TexCoords;

uniform sampler2D image;

uniform bool horizontal;
uniform float weight[5] = float[] (0.2270270270, 0.1945945946, 0.1216216216, 0.0540540541, 0.0162162162);

void main()
{    
     //计算纹素，用于偏移uv         
     vec2 tex_offset = 1.0 / textureSize(image, 0); 
     //应用第一个权重
     vec3 result = texture(image, TexCoords).rgb * weight[0];
     //分垂直水平分别应用剩下四个权重
     if(horizontal)
     {
         for(int i = 1; i < 5; ++i)
         {
            //水平的左右两边加权
            result += texture(image, TexCoords + vec2(tex_offset.x * i, 0.0)).rgb * weight[i];
            result += texture(image, TexCoords - vec2(tex_offset.x * i, 0.0)).rgb * weight[i];
         }
     }
     else
     {
         for(int i = 1; i < 5; ++i)
         {
             //垂直的上下两边加权
             result += texture(image, TexCoords + vec2(0.0, tex_offset.y * i)).rgb * weight[i];
             result += texture(image, TexCoords - vec2(0.0, tex_offset.y * i)).rgb * weight[i];
         }
     }
     
     //输出模糊结果
     FragColor = vec4(result, 1.0);
}

```
![578x435](assets/7.Bloom_image_8.png)



### 叠加亮部回原图
最后一步就是将模糊的部分叠加回原图
我们只需要一个单独的shader（pass）进行叠加即可，同时可以搭配ToneMapping进行完善画面

```cpp
#version 330 core
out vec4 FragColor;

in vec2 TexCoords;

uniform sampler2D scene;
uniform sampler2D bloomBlur;
uniform bool bloom;
uniform float exposure;

void main()
{             
    const float gamma = 2.2;
    vec3 hdrColor = texture(scene, TexCoords).rgb;      
    vec3 bloomColor = texture(bloomBlur, TexCoords).rgb;
    if(bloom)
        hdrColor += bloomColor; // additive blending
    // tone mapping
    vec3 result = vec3(1.0) - exp(-hdrColor * exposure);
    // also gamma correct while we're at it       
    result = pow(result, vec3(1.0 / gamma));
    FragColor = vec4(result, 1.0);
}
```



![](assets/7.Bloom_video_1.mp4)