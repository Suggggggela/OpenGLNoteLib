这节我们看看曲面细分着色器

## 1.CPU生成MeshData
首先我们使用CPU生成模型的RenderData进行渲染
我们根据加载进来的高度图去生成mesh的vertices和indices
```cpp
//Load HeightMap
stbi_set_flip_vertically_on_load(true);
int width, height, nrChannels;
unsigned char* data = stbi_load("textures/iceland_heightmap.png", &width, &height, &nrChannels, 0);
if (data)
{
    std::cout << "Loaded heightmap of size " << height << " x " << width << std::endl;
}
else
{
    std::cout << "Failed to load texture" << std::endl;
}

//Calculate terrain vertices
std::vector<float> vertices;
float yScale = 64.0f / 256.0f, yShift = 16.0f;
int rez = 1;
unsigned bytePerPixel = nrChannels;
for (int i = 0; i < height; i++)
{
    for (int j = 0; j < width; j++)
    {
        unsigned char* pixelOffset = data + (j + width * i) * bytePerPixel;
        unsigned char y = pixelOffset[0];

        // vertex
        vertices.push_back(-height / 2.0f + height * i / (float)height);   // vx
        vertices.push_back((int)y * yScale - yShift);   // vy
        vertices.push_back(-width / 2.0f + width * j / (float)width);   // vz
    }
}
std::cout << "Loaded " << vertices.size() / 3 << " vertices" << std::endl;
stbi_image_free(data);
//Calculate terrain indices
std::vector<unsigned> indices;
for (unsigned i = 0; i < height - 1; i += rez)
{
    for (unsigned j = 0; j < width; j += rez)
    {
        for (unsigned k = 0; k < 2; k++)
        {
            indices.push_back(j + width * (i + k * rez));
        }
    }
}
std::cout << "Loaded " << indices.size() << " indices" << std::endl;
//Calculate terrain triangle strips
const int numStrips = (height - 1) / rez;
const int numTrisPerStrip = (width / rez) * 2 - 2;
std::cout << "Created lattice of " << numStrips << " strips with " << numTrisPerStrip << " triangles each" << std::endl;
std::cout << "Created " << numStrips * numTrisPerStrip << " triangles total" << std::endl;

```

然后在Draw部分，我们通过DrawElement绘制每个三角形
```cpp
glm::mat4 model = glm::mat4(1.0f);
glm::mat4 view = camera.GetViewMatrix();
glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f);

//terrain
heightMapShader.use();
model = glm::translate(model, modelTrans);
heightMapShader.setMat4("model", model);
heightMapShader.setMat4("projection", projection);
heightMapShader.setMat4("view", view);
glBindVertexArray(terrainVAO);
       
for (unsigned strip = 0; strip < numStrips; strip++)
{
    glDrawElements(GL_TRIANGLE_STRIP,   // primitive type
        numTrisPerStrip + 2,   // number of indices to render
        GL_UNSIGNED_INT,     // index data type
        (void*)(sizeof(unsigned) * (numTrisPerStrip + 2) * strip)); // offset to starting index
}
```
![561x403](assets/3.TessellationShader_image_1.png)
笔者这里CPU是13900k，默认的绘制密度还达不到CPU瓶颈

通过下边的细分之后，在级数5的时候大约在75帧
```cpp
std::vector<float> vertices;
float yScale = 64.0f / 256.0f, yShift = 16.0f;
int subdiv = 5; // 细分级数，subdiv=1为原始分辨率，subdiv=2为每个像素间插入1个新顶点
unsigned bytePerPixel = nrChannels;

// 新分辨率
int newWidth = (width - 1) * subdiv + 1;
int newHeight = (height - 1) * subdiv + 1;

// 顶点生成（双线性插值）
for (int i = 0; i < newHeight; ++i)
{
    float fy = (float)i / (newHeight - 1) * (height - 1);
    int y0 = (int)fy;
    int y1 = std::min(y0 + 1, height - 1);
    float ty = fy - y0;
    for (int j = 0; j < newWidth; ++j)
    {
        float fx = (float)j / (newWidth - 1) * (width - 1);
        int x0 = (int)fx;
        int x1 = std::min(x0 + 1, width - 1);
        float tx = fx - x0;

        // 双线性插值高度
        unsigned char* p00 = data + (x0 + width * y0) * bytePerPixel;
        unsigned char* p10 = data + (x1 + width * y0) * bytePerPixel;
        unsigned char* p01 = data + (x0 + width * y1) * bytePerPixel;
        unsigned char* p11 = data + (x1 + width * y1) * bytePerPixel;
        float h00 = p00[0];
        float h10 = p10[0];
        float h01 = p01[0];
        float h11 = p11[0];
        float h = (1 - tx) * (1 - ty) * h00 +
            tx * (1 - ty) * h10 +
            (1 - tx) * ty * h01 +
            tx * ty * h11;

        // 顶点坐标
        float vx = -newHeight / 2.0f + newHeight * fy / (float)(height - 1);
        float vy = h * yScale - yShift;
        float vz = -newWidth / 2.0f + newWidth * fx / (float)(width - 1);
        vertices.push_back(vx);
        vertices.push_back(vy);
        vertices.push_back(vz);
    }
}
std::cout << "Loaded " << vertices.size() / 3 << " vertices" << std::endl;
stbi_image_free(data);

// 索引生成（triangle strip）
std::vector<unsigned> indices;
for (int i = 0; i < newHeight - 1; ++i)
{
    for (int j = 0; j < newWidth; ++j)
    {
        indices.push_back(j + newWidth * i);
        indices.push_back(j + newWidth * (i + 1));
    }
}
std::cout << "Loaded " << indices.size() << " indices" << std::endl;

// 统计三角形数量
const int numStrips = newHeight - 1;
const int numTrisPerStrip = newWidth * 2 - 2;
std::cout << "Created lattice of " << numStrips << " strips with " << numTrisPerStrip << " triangles each" << std::endl;
std::cout << "Created " << numStrips * numTrisPerStrip << " triangles total" << std::endl;

```

![587x421](assets/3.TessellationShader_image_2.png)


## 2.Tessellation Shader
### RenderPipeline
首先我们看看曲面细分Shader位于管线的哪个位置
它位于Vertex-Geometry之间
![708x532](assets/3.TessellationShader_image_3.png)

## TessellationShader
使用曲面细分着色器包括下边这些部分
- 指定每组patch的vertex数量（CPU端）
- tessellation control shader(TCS)： 决定要进行多少细分
- tessellation primitive generator(不可编程，GPU自动执行)： 根据规则进行网格划分，生成中间点
- tessellation evaluation shader(TES)： 根据中间点生成新顶点

这三阶段对应在Unity中，就是：Hull，PrimitiveGeneration，Domain
### CPU端
使用曲面细分Shader需要在cpu端指定构成每个Primitive的顶点数
在cpu端指定每个patch的vertex数量类似下边这样：
```cpp
glPatchParameteri(GL_PATCH_VERTICES, 4);
//指定每组patch4个vertex
```

### Patch
Patch是我们处理曲面细分时Primitive的类型，可以理解为曲面细分Shader处理的基本单位，通常用常量GL_PATCHES表示
Patch是一种抽象的Primitive，由一组n个vertex组成，常见的就是三角形和四边形
曲面细分shader的主要工作就是对这些patch进行细分
### TCS
TCS的执行步骤如下：
- 指定每个patch的vertex数量
- 对patch的每个vertex执行变换
- 指定外层和内层的细分级别（控制细分程度）

#### TCS的输入输出
- 输入：原始Patch
- 输出：tessellation factor 细分因子(决定每个patch被细分成多少个更小的Primitive)

control shader将在patch的每个vertex上运行一遍，指定patch顶点数和输入输出：
```cpp
// tessellation control shader
#version 410 core
//指定每个patch的vertex数量，需要和CPU端设置的匹配
layout(vertices = 4) out;

in vec2 TexCoord[];//input from vertex shader
out vec2 TextureCoord[];//output to evaluation shader

```

#### 传递属性、指定内外层细分级别
接下来传递属性，然后指定外层和内层的细分级别

**细分级别是通过两个内置变量指定的：**
- gl_TessLevelOuter：外层细分级别，控制patch的边界被细分为多少段，数值越大细分越多，生成的网格越密集
- gl_TessLevelInner：内层细分级别，控制patch内部的细分级别，数值越大细分越多，生成的曲面越平滑

另外，这两个数组根据Patch的类型会有不同：
- 对于四边形patch（quads），gl_TessLevelOuter有4个元素(四条边)，gl_TessLevelInner有2个元素(uv两方向内部细分)
- 对于三角形patch（triangles），gl_TessLevelOuter有3个元素(三条边)，gl_TessLevelInner有1个元素(内部细分)
```cpp
void main()
{
    // ----------------------------------------------------------------------
    // pass attributes through
    gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;
    TextureCoord[gl_InvocationID] = TexCoord[gl_InvocationID];

    // ----------------------------------------------------------------------
    // invocation zero controls tessellation levels for the entire patch
    if (gl_InvocationID == 0)
    {
        gl_TessLevelOuter[0] = 16;
        gl_TessLevelOuter[1] = 16;
        gl_TessLevelOuter[2] = 16;
        gl_TessLevelOuter[3] = 16;

        gl_TessLevelInner[0] = 16;
        gl_TessLevelInner[1] = 16;
    }
}

```
上边例子上的是四边形，它的每个边都可以独立细分，我们细分16次作为示例

GLSL内置可以指定设置四个不同的边，Outer和Inner代表的可以看下图示意：
![338x338](assets/3.TessellationShader_image_4.png)


### Tessellation Primitive Generator
这阶段是不可编程的而是配置的
输入输出如下：
- 输入：patch、Tessellation factor
- 输出：细分后的patch

**输入和输出部分共同决定了这个阶段会如何细分**：
- control shader输入的patch和细分factor，**决定细分的次数**
- 输出会给到evaluation shader，这个shader可以指定如何在每条边上**设置细分间隔**

指定细分间隔的方法有三种：
- equal_spacing                       大小等边的细分![3.TessellationShader_image_5](assets/3.TessellationShader_image_5.gif)
- fractional_odd_spacing         奇数个间隔，分长短段![3.TessellationShader_image_6](assets/3.TessellationShader_image_6.gif)
- fractional_even_spacing        偶数个间隔，分长短段![3.TessellationShader_image_7](assets/3.TessellationShader_image_7.gif)

具体规则可以参考这里
[3.3 曲面细分与几何着色器---大规模草渲染](../../../../../【7.CouseNote】/【TA100】/T/3.3%20曲面细分与几何着色器---大规模草渲染.md)
https://zhuanlan.zhihu.com/p/1907133091157370512
细分的**步骤如下**：
- 递归细分内部面片
- 细分外部边缘

比如下边不同细分等级的效果：
![444x159](assets/3.TessellationShader_image_8.png)
一但生成内环，外环就是基于每个外部细分级别生成最终的中间点
![216x237](assets/3.TessellationShader_image_9.png)

patch space的范围是0~1，生成的中间点由小数坐标(u，v)表示，和它在patch中的位置对应

### TES
EvaluationShader的工作是确定生成的中间点的xyz坐标，既计算细分后每个顶点的位置
在TCS设置好细分等级并生成了新的细分点后，TES 会根据每个细分点的参数（如 u、v 坐标），结合 patch 的控制点，计算出每个新顶点的具体位置，实现曲面的插值和变形。

前边说过TES的输入（Generation的输出）也决定这细分的规则，所以TES需要通过layout指定细分策略：patch类型、生成Primitive的间距(Spacing)和环绕顺序(winding order)
```cpp
// tessellation evaluation shader
#version 410 core

layout (quads, fractional_odd_spacing, ccw) in;
//后两者为可选，默认的环绕方式为ccw逆时针（cw为顺时针）
```

TES的**输入**有以下这些：
- gl_in ： patch的vertices数组
- the array of varying attributes ，顶点属性数组（前阶段传递过来的，随着顶点细分插值的属性）
- gl_TessCoord：细分后顶点在Patch中的相对坐标，是个2D坐标，表示每个顶点的相对位置，用于各顶点属性的插值

```cpp
// received from Tessellation Control Shader - all texture coordinates for the patch vertices
in vec2 TextureCoord[];

// send to Fragment Shader for coloring
out float Height;
```

我们使用gl_TessCoord的值作为参数，根据需要对patch顶点进行插值
这里使用的是和CPU端相同的四分法，在GPU中我们并行的确定插值纹理坐标和最终顶点的位置
```cpp


void main()
{
    // get patch coordinate
    float u = gl_TessCoord.x;
    float v = gl_TessCoord.y;

    // ----------------------------------------------------------------------
    // retrieve control point texture coordinates
    vec2 t00 = TextureCoord[0];
    vec2 t01 = TextureCoord[1];
    vec2 t10 = TextureCoord[2];
    vec2 t11 = TextureCoord[3];

    // bilinearly interpolate texture coordinate across patch
    vec2 t0 = (t01 - t00) * u + t00;
    vec2 t1 = (t11 - t10) * u + t10;
    vec2 texCoord = (t1 - t0) * v + t0;

    // lookup texel at patch coordinate for height and scale + shift as desired
    Height = texture(heightMap, texCoord).y * 64.0 - 16.0;

    // ----------------------------------------------------------------------
    // retrieve control point position coordinates
    vec4 p00 = gl_in[0].gl_Position;
    vec4 p01 = gl_in[1].gl_Position;
    vec4 p10 = gl_in[2].gl_Position;
    vec4 p11 = gl_in[3].gl_Position;

    // compute patch surface normal
    vec4 uVec = p01 - p00;
    vec4 vVec = p10 - p00;
    vec4 normal = normalize(vec4(cross(vVec.xyz, uVec.xyz), 0));

    // bilinearly interpolate position coordinate across patch
    vec4 p0 = (p01 - p00) * u + p00;
    vec4 p1 = (p11 - p10) * u + p10;
    vec4 p = (p1 - p0) * v + p0;

    // displace point along normal
    p += normal * Height;

    // ----------------------------------------------------------------------
    // output patch point position in clip space
    gl_Position = projection * view * model * p;
}

```


## 3.Dynamic LOD
TessellationShader的一大有点是可以动态计算细分的分辨率，来生成需要的几何图形，这对于动态LOD是非常合适的
这里我们根据距离进行LOD，离得越近分辨率越高，反之越低

曲面细分的control shader阶段控制着patch的细分级别，因为第0个index的顶点设置了整个patch的细分级别，我们在每个patch只需要计算一次即可控制整个patch的细分程度
具体计算思路为：根据patch的深度对细分级别进行西那行插值
步骤如下
1. 定义MIN_TESS_LEVEL和MAX_TESS_LEVEL作为最大最小细分级别，定义MIN_DISTANCE和MAX_DISTANCE作为插值参数
2. 将patch转换到ViewSpace，这时坐标z分量表示相对于Camera的距离
3. 通过Normalizing计算顶点到相机的距离值，并将值映射到0~1，用于对细分等级的插值
4. 插值外层细分级别：根据每个vertex的距离，使用离Camera更近的顶点作为插值参数以获得更高的细分级别。对于每条边，我们由近到远的对细分等级进行由高到低的插值（既近处分辨率高远处分辨率低）
5. 为每个patch设置对应细分级别
6. 计算并设置内部细分级别：内部的细分级别和两个外部的细分级别维度相同，对于内部使用较高的细分级别

具体可以通过代码理解：
```cpp
/ ----------------------------------------------------------------------
// invocation zero controls tessellation levels for the entire patch
if (gl_InvocationID == 0)
{
    // ----------------------------------------------------------------------
    // Step 1: define constants to control tessellation parameters
    // set these as desired for your world scale
    const int MIN_TESS_LEVEL = 4;
    const int MAX_TESS_LEVEL = 64;
    const float MIN_DISTANCE = 20;
    const float MAX_DISTANCE = 800;

    // ----------------------------------------------------------------------
    // Step 2: transform each vertex into eye space
    vec4 eyeSpacePos00 = view * model * gl_in[0].gl_Position;
    vec4 eyeSpacePos01 = view * model * gl_in[1].gl_Position;
    vec4 eyeSpacePos10 = view * model * gl_in[2].gl_Position;
    vec4 eyeSpacePos11 = view * model * gl_in[3].gl_Position;

    // ----------------------------------------------------------------------
    // Step 3: "distance" from camera scaled between 0 and 1
    float distance00 = clamp((abs(eyeSpacePos00.z) - MIN_DISTANCE) / (MAX_DISTANCE - MIN_DISTANCE), 0.0, 1.0);
    float distance01 = clamp((abs(eyeSpacePos01.z) - MIN_DISTANCE) / (MAX_DISTANCE - MIN_DISTANCE), 0.0, 1.0);
    float distance10 = clamp((abs(eyeSpacePos10.z) - MIN_DISTANCE) / (MAX_DISTANCE - MIN_DISTANCE), 0.0, 1.0);
    float distance11 = clamp((abs(eyeSpacePos11.z) - MIN_DISTANCE) / (MAX_DISTANCE - MIN_DISTANCE), 0.0, 1.0);

    // ----------------------------------------------------------------------
    // Step 4: interpolate edge tessellation level based on closer vertex
    float tessLevel0 = mix(MAX_TESS_LEVEL, MIN_TESS_LEVEL, min(distance10, distance00));
    float tessLevel1 = mix(MAX_TESS_LEVEL, MIN_TESS_LEVEL, min(distance00, distance01));
    float tessLevel2 = mix(MAX_TESS_LEVEL, MIN_TESS_LEVEL, min(distance01, distance11));
    float tessLevel3 = mix(MAX_TESS_LEVEL, MIN_TESS_LEVEL, min(distance11, distance10));

    // ----------------------------------------------------------------------
    // Step 5: set the corresponding outer edge tessellation levels
    gl_TessLevelOuter[0] = tessLevel0;
    gl_TessLevelOuter[1] = tessLevel1;
    gl_TessLevelOuter[2] = tessLevel2;
    gl_TessLevelOuter[3] = tessLevel3;

    // ----------------------------------------------------------------------
    // Step 6: set the inner tessellation levels to the max of the two parallel edges
    gl_TessLevelInner[0] = max(tessLevel1, tessLevel3);
    gl_TessLevelInner[1] = max(tessLevel0, tessLevel2);
}
```


## GPU生成mesh
我们根据上边曲线细分着色器和动态LOD的内容测试一下

### Shader
VS：
```cpp
#version 410 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec2 aTex;

out vec2 TexCoord;

void main()
{
    gl_Position = vec4(aPos, 1.0);
    TexCoord = aTex;
}
```

TCS：在control shader中我们使用动态lod指定外层和内层的细分级别
为了查看细分修改的样子，我们这里将四个const变量改成Uniform从CPU端用imgui修改
```cpp
#version 410 core

layout(vertices=4) out;

uniform mat4 model;
uniform mat4 view;
uniform int minTess;
uniform int maxTess;
uniform float minDis;
uniform float maxDis;

in vec2 TexCoord[];
out vec2 TextureCoord[];

void main()
{
    gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;
    TextureCoord[gl_InvocationID] = TexCoord[gl_InvocationID];

    if(gl_InvocationID == 0)
    {
        //const int MIN_TESS_LEVEL = 4;
        //const int MAX_TESS_LEVEL = 64;
        //const float MIN_DISTANCE = 20;
        //const float MAX_DISTANCE = 800;
        int MIN_TESS_LEVEL = minTess;
        int MAX_TESS_LEVEL = maxTess;
        float MIN_DISTANCE = minDis;
        float MAX_DISTANCE = maxDis;

        vec4 eyeSpacePos00 = view * model * gl_in[0].gl_Position;
        vec4 eyeSpacePos01 = view * model * gl_in[1].gl_Position;
        vec4 eyeSpacePos10 = view * model * gl_in[2].gl_Position;
        vec4 eyeSpacePos11 = view * model * gl_in[3].gl_Position;

        // "distance" from camera scaled between 0 and 1
        float distance00 = clamp( (abs(eyeSpacePos00.z) - MIN_DISTANCE) / (MAX_DISTANCE-MIN_DISTANCE), 0.0, 1.0 );
        float distance01 = clamp( (abs(eyeSpacePos01.z) - MIN_DISTANCE) / (MAX_DISTANCE-MIN_DISTANCE), 0.0, 1.0 );
        float distance10 = clamp( (abs(eyeSpacePos10.z) - MIN_DISTANCE) / (MAX_DISTANCE-MIN_DISTANCE), 0.0, 1.0 );
        float distance11 = clamp( (abs(eyeSpacePos11.z) - MIN_DISTANCE) / (MAX_DISTANCE-MIN_DISTANCE), 0.0, 1.0 );

        float tessLevel0 = mix( MAX_TESS_LEVEL, MIN_TESS_LEVEL, min(distance10, distance00) );
        float tessLevel1 = mix( MAX_TESS_LEVEL, MIN_TESS_LEVEL, min(distance00, distance01) );
        float tessLevel2 = mix( MAX_TESS_LEVEL, MIN_TESS_LEVEL, min(distance01, distance11) );
        float tessLevel3 = mix( MAX_TESS_LEVEL, MIN_TESS_LEVEL, min(distance11, distance10) );

        gl_TessLevelOuter[0] = tessLevel0;
        gl_TessLevelOuter[1] = tessLevel1;
        gl_TessLevelOuter[2] = tessLevel2;
        gl_TessLevelOuter[3] = tessLevel3;

        gl_TessLevelInner[0] = max(tessLevel1, tessLevel3);
        gl_TessLevelInner[1] = max(tessLevel0, tessLevel2);
    }
}
```

TES如下：
```cpp
#version 410 core
layout(quads, fractional_odd_spacing, ccw) in;//指定细分策略

uniform sampler2D heightMap;
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

in vec2 TextureCoord[];

out float Height;

void main()
{
    //根据TessellationCoord在四个TextureCoord之间插值计算当前点uv
    float u = gl_TessCoord.x;
    float v = gl_TessCoord.y;

    vec2 t00 = TextureCoord[0];
    vec2 t01 = TextureCoord[1];
    vec2 t10 = TextureCoord[2];
    vec2 t11 = TextureCoord[3];

    vec2 t0 = (t01 - t00) * u + t00;
    vec2 t1 = (t11 - t10) * u + t10;
    vec2 texCoord = (t1 - t0) * v + t0;

    //PositionY为高度
    Height = texture(heightMap, texCoord).y * 64.0 - 16.0;

    vec4 p00 = gl_in[0].gl_Position;
    vec4 p01 = gl_in[1].gl_Position;
    vec4 p10 = gl_in[2].gl_Position;
    vec4 p11 = gl_in[3].gl_Position;

    //计算Normal
    vec4 uVec = p01 - p00;
    vec4 vVec = p10 - p00;
    vec4 normal = normalize( vec4(cross(vVec.xyz, uVec.xyz), 0) );

    //计算细分后顶点的Position
    vec4 p0 = (p01 - p00) * u + p00;
    vec4 p1 = (p11 - p10) * u + p10;
    vec4 p = (p1 - p0) * v + p0 + normal * Height;

    gl_Position = projection * view * model * p;
}
```

### CPU端
在CPU端：
- 设置Patch
- 加载高度图，根据高度图生成Vertices
- 额



```cpp
//TessellationData
const unsigned int NUM_PATCH_PTS = 4;
int minTess = 4;
int maxTess = 64;
float minDis = 20.0f;
float maxDis = 800.0f;

int main()
{
    //记得把OpenGL版本改到4.1以上，以支持Tessellation
    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    GLint maxTessLevel;
    glGetIntegerv(GL_MAX_TESS_GEN_LEVEL, &maxTessLevel);
    std::cout << "Max available tess level: " << maxTessLevel << std::endl;

    Shader tessHeightMapShader("shaders/heightGPU.vs", "shaders/heightGPU.fs", nullptr,
                        "shaders/heightGPU.tcs", "shaders/heightGPU.tes");

    //Create Texture
    unsigned int texture;
    glGenTextures(1, &texture);
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, texture);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    //Load HeightMap
    //stbi_set_flip_vertically_on_load(true);
    int width, height, nrChannels;
    unsigned char* data = stbi_load("textures/iceland_heightmap.png", &width, &height, &nrChannels, 0);
    if (data)
    {
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
        glGenerateMipmap(GL_TEXTURE_2D);
    
        tessHeightMapShader.setInt("heightMap", 0);
        std::cout << "Loaded heightmap of size " << height << " x " << width << std::endl;
    }
    else
    {
        std::cout << "Failed to load texture" << std::endl;
    }
    stbi_image_free(data);
    //Terrain Vertices
    std::vector<float> vertices;
    
    unsigned rez = 20;
    for (unsigned i = 0; i <= rez - 1; i++)
    {
        for (unsigned j = 0; j <= rez - 1; j++)
        {
            vertices.push_back(-width / 2.0f + width * i / (float)rez); // v.x
            vertices.push_back(0.0f); // v.y
            vertices.push_back(-height / 2.0f + height * j / (float)rez); // v.z
            vertices.push_back(i / (float)rez); // u
            vertices.push_back(j / (float)rez); // v
    
            vertices.push_back(-width / 2.0f + width * (i + 1) / (float)rez); // v.x
            vertices.push_back(0.0f); // v.y
            vertices.push_back(-height / 2.0f + height * j / (float)rez); // v.z
            vertices.push_back((i + 1) / (float)rez); // u
            vertices.push_back(j / (float)rez); // v
    
            vertices.push_back(-width / 2.0f + width * i / (float)rez); // v.x
            vertices.push_back(0.0f); // v.y
            vertices.push_back(-height / 2.0f + height * (j + 1) / (float)rez); // v.z
            vertices.push_back(i / (float)rez); // u
            vertices.push_back((j + 1) / (float)rez); // v
    
            vertices.push_back(-width / 2.0f + width * (i + 1) / (float)rez); // v.x
            vertices.push_back(0.0f); // v.y
            vertices.push_back(-height / 2.0f + height * (j + 1) / (float)rez); // v.z
            vertices.push_back((i + 1) / (float)rez); // u
            vertices.push_back((j + 1) / (float)rez); // v
        }
    }
    std::cout << "Loaded " << rez * rez << " patches of 4 control points each" << std::endl;
    std::cout << "Processing " << rez * rez * 4 << " vertices in vertex shader" << std::endl;
    
    //terrain render data
    unsigned int terrainVAO, terrainVBO;
    glGenVertexArrays(1, &terrainVAO);
    glBindVertexArray(terrainVAO);
    glGenBuffers(1, &terrainVBO);
    glBindBuffer(GL_ARRAY_BUFFER, terrainVBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(float)* vertices.size(), &vertices[0], GL_STATIC_DRAW);
    
    //layout
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(sizeof(float) * 3));
    glEnableVertexAttribArray(1);
    
    //Patch
    glPatchParameteri(GL_PATCH_VERTICES, NUM_PATCH_PTS);

    while (!glfwWindowShouldClose(window))
     {
        glm::mat4 model = glm::mat4(1.0f);
        glm::mat4 view = camera.GetViewMatrix();
        glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100000.0f);
        
        
        //------------terrain---------------
        tessHeightMapShader.use();
        tessHeightMapShader.setInt("minTess", minTess);
        tessHeightMapShader.setInt("maxTess", maxTess);
        tessHeightMapShader.setFloat("minDis", minDis);
        tessHeightMapShader.setFloat("maxDis", maxDis);
        tessHeightMapShader.setMat4("projection", projection);
        tessHeightMapShader.setMat4("view", view);
        model = glm::translate(model, modelTrans);
        tessHeightMapShader.setMat4("model", model);
        model = glm::mat4(1.0f);
        
        glBindVertexArray(terrainVAO);
        glDrawArrays(GL_PATCHES, 0, NUM_PATCH_PTS * rez * rez);

        //imgui
        ImGui_ImplGlfwGL3_NewFrame();
        ImGui::Begin("ImGui");
        ImGui::Text("Application average %.3f ms/frame (%.1f FPS)",
            1000.0f / ImGui::GetIO().Framerate, ImGui::GetIO().Framerate);
        ImGui::Text("Hello !");
        ImGui::SliderFloat3("m_ModelTransform", &modelTrans.x, -50.0f, 50.0f);
        ImGui::Checkbox("Wireframe Mode", &useWireframe);
        ImGui::SliderInt("Min Tessellation Level", &minTess, 1, 256);
        ImGui::SliderInt("Max Tessellation Level", &maxTess, 24, 1024);
        ImGui::SliderFloat("Min Distance", &minDis, 0.0f, 800.0f);
        ImGui::SliderFloat("Max Distance", &maxDis, 100.0f, 5000.0f);
        ImGui::End();
     }

    //destory....
}

```

![](assets/tessTerrain.mp4)