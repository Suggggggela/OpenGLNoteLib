## 一、什么是shader
shader是运行在gpu上的程序，具有以下特征：
- 早期不可被编程，只能被配置；现代gpu允许编程
- 接收输入，然后输出
- 不同shader之间不能通信，只能通过输入输出进行传递数据

## 二、Shader
### 1.典型的shader代码
shader有很多语言，cg，glsl，hlsl
以glsl为例，一个典型的shader结构如下：

```cpp
#version version_number in type in_variable_name; 
in type in_variable_name; //输入
out type out_variable_name; //输出
uniform type uniform_name; //uniform是CPU和GPU通信的方式
void main() 
{ 
    // 处理输入并进行一些图形操作 
    ... 
    
    // 输出处理过的结果到输出变量 
    out_variable_name = weird_stuff_we_processed; 
}
```

### 2.顶点属性
当我们谈论顶点shader时，每个输入变量都是一种**顶点属性**
不同硬件的顶点属性的可用数量不同，我们可以用过以下方式查询：
```cpp
int nrAttributes;
glGetIntegerv(GL_MAX_VERTEX_ATTRIS, &nrAttributes);
```

### 3.数据类型
|类型|含义|
|---|---|
|`vecn`|包含`n`个float分量的默认向量|
|`bvecn`|包含`n`个bool分量的向量|
|`ivecn`|包含`n`个int分量的向量|
|`uvecn`|包含`n`个unsigned int分量的向量|
|`dvecn`|包含`n`个double分量的向量|
shader中，我们可以通过xyzw访问分量，并且可以将分量**重组**(Swizzling)
```cpp
vec2 someVec; 
vec4 differentVec = someVec.xyxx; 
vec3 anotherVec = differentVec.zyw; 
vec4 otherVec = someVec.xxxx + anotherVec.yxzy;
```

### 4.输入 输出
正如上边说的，shader之间不能互相通信，那么他们作为独立的程序之间沟通就只能通过输入和输出进行了
输入输出的关键字为：**in out**
例如：
```cpp
in vec4 VertexColor;
out vec4 FragmentColor
```

#### vertex shader
对于vertex shader，直接从顶点属性接收输入。为了定义顶点属性的管理，使用了location指定输入变量
例如：
```cpp
layout(location = 0) in vec3 aPos; 
//layout为GLSL中的布局限定符，一般用来用于控制内存布局、绑定位置或输入/输出接口，比如uniform，vertexAttribute，in out
//layout(location = 0) 指定顶点属性的索引为0
//in vec3 aPos 将这个属性绑定到变量aPos，作为顶点shader的输入
```
我们可以简单的将顶点色作为out变量传出，再在fragment中输入
```cpp
#version 330 core
layout(location = 0) in vec3 aPos;
out vec4 VertexColor;

void main()
{
    gl_Position = vec4(aPos, 1.0);
    VertexColor = (0.5,0.0,0.0,1.0);
}
```


#### fragment shader
对于fragment shader，需要一个vec4的颜色作为输出的片元颜色
```cpp
#version 330 core
out vec4 FragColor;
in vec4 VertexColor;//vertex shader 的out，作为fragment的 in

void main()
{
    FragColor = VertexColor;//将顶点色作为片元颜色输出
}
```

### 5.Uniform
uniform是CPU传输数据到GPU的方式
- uniform是全局变量，这意味着每个shader都能访问
- uniform在每个shader中都是Unique的
- uniform数据会一直保存在GPU端，直到它被CPU更新
- 如果CPU端声明了uniform，GPU端却没有使用，在编译时这个uniform会被静默移除


shader中，我们使用**uniform**关键字声明
```cpp
 #version 330 core
 out vec4 FragColor;
 uniform vec4 CPU2GPUColor;
 void main()
 {
     FragColor = CPU2GPUColor;
 }
```

在cpu端，我们可以更新uniform，具体步骤如下：
- 获取uniform的location
- 使用glUniformxxx更新uniform
```cpp
float gChannelValue = (sin(glfwGetTime())/2.0f) + 0.5f;//自定义G通道渐变颜色
int uniformLocation = glGetUniformLocation(shaderProgram,"CPU2GPUColor");
glUseProgram(shaderProgram);//下边的uniform更新函数更新当前绑定的shader
glUniform4f(uniformLocation,0.0f,gChannelValue,0.0f,1.0f);
```
对于更新uniform的gl函数，不同的后缀代表着不同的更新类型

| 后缀   |                         |
| ---- | ----------------------- |
| `f`  | 函数需要一个float作为它的值        |
| `i`  | 函数需要一个int作为它的值          |
| `ui` | 函数需要一个unsigned int作为它的值 |
| `3f` | 函数需要3个float作为它的值        |
| `fv` | 函数需要一个float向量/数组作为它的值   |
在实际uniform的更新中，我们可以逐帧更新，这样就可以绘制出动态的颜色了

```cpp
while(!glfwWindowShouldClose(window))
{
    ...
    glUseProgram(shaderProgram);
    ...//更新uniform
    ...//绘制
}
```

## 三、扩充VertexAttribute
上述内容我们了解了如何填充VBO，配置VertexAttribute，以及将这些绑定在VAO
接下来我们扩充一下顶点属性，为每个顶点添加顶点色


```cpp
float vertices[] = {
    // positions         // colors
     0.5f, -0.5f, 0.0f,  1.0f, 0.0f, 0.0f,  // bottom right
    -0.5f, -0.5f, 0.0f,  0.0f, 1.0f, 0.0f,  // bottom left
     0.0f,  0.5f, 0.0f,  0.0f, 0.0f, 1.0f   // top 
};

```

```cpp
//使用glVertexAttribPointer制定Layout时，启用新加的顶点属性
glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float),
    (void*)(3*sizeof(float)));
glEnableVertexAttribArray(1);

```


```cpp
//shader中就可以通过layout读取了
layout (location = 1) in vec3 aColor;

```

## 四、Shader类

头文件

```cpp
#ifndef SHADER_H
#define SHADER_H

#include <glad/glad.h>; // 包含glad来获取所有的必须OpenGL头文件

#include <string>
#include <fstream>
#include <sstream>
#include <iostream>


class Shader
{
public:
    // 程序ID
    unsigned int ID;

    // 构造器读取并构建着色器
    Shader(const char* vertexPath, const char* fragmentPath);
    //~Shader();
    // 使用/激活程序
    void use();
    // uniform工具函数
    void setBool(const std::string& name, bool value) const;
    void setInt(const std::string& name, int value) const;
    void setFloat(const std::string& name, float value) const;
private:
private:
    // utility function for checking shader compilation/linking errors.
    // ------------------------------------------------------------------------
    void checkCompileErrors(unsigned int shader, std::string type);
};

#endif

```

cpp实现：

```cpp
#include "Shader.h"

Shader::Shader(const char* vertexPath, const char* fragmentPath)
{
	//read shader
	std::string vertexCode;
	std::string fragmentCode;
	std::ifstream vShaderFile;
	std::ifstream fShaderFile;
	//确保ifstream对象可以抛出异常
	vShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);
	fShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);

	try //try用来捕获文件读取异常
	{
		//打开文件
		vShaderFile.open(vertexPath);
		fShaderFile.open(fragmentPath);
		std::stringstream vShaderStream, fShaderStream;
		//读取文件的缓冲内容到流中
		vShaderStream << vShaderFile.rdbuf();
		fShaderStream << fShaderFile.rdbuf();
		//关闭文件处理器
		vShaderFile.close();
		fShaderFile.close();
		//转换流为字符串
		vertexCode = vShaderStream.str();
		fragmentCode = fShaderStream.str();
	}
	catch (std::ifstream::failure& e)
	{
		std::cout << "ERROR::SHADER::FILE_NOT_SUCCESSFULLY_READ" << std::endl;
	}

	const char* vShaderCode = vertexCode.c_str();
	const char* fShaderCode = fragmentCode.c_str();
	std::cout << "vertex shader code:\n" << vShaderCode << std::endl;
	std::cout << "fragment shader code:\n" << fShaderCode << std::endl;
	//compile shaders
	unsigned int vertex, fragment;
	int success;
	char infoLog[512];
	vertex = glCreateShader(GL_VERTEX_SHADER);
	glShaderSource(vertex, 1, &vShaderCode, NULL);
	glCompileShader(vertex);
	checkCompileErrors(vertex, "VERTEX");

	fragment = glCreateShader(GL_FRAGMENT_SHADER);
	glShaderSource(fragment, 1, &fShaderCode, NULL);
	glCompileShader(fragment);
	checkCompileErrors(vertex, "FRAGMENT");

	//shader program
	ID = glCreateProgram();
	glAttachShader(ID, vertex);
	glAttachShader(ID, fragment);
	glLinkProgram(ID);
	checkCompileErrors(vertex, "PROGRAM");

	//delete shader
	glDeleteShader(vertex);
	glDeleteShader(fragment);
}

//Shader::~Shader()
//{
//	glDeleteProgram(ID);
//}


void Shader::use()
{
	glUseProgram(ID);
}

void Shader::setBool(const std::string& name, bool value) const
{
	glUniform1i(glGetUniformLocation(ID, name.c_str()), value);
}

void Shader::setInt(const std::string& name, int value) const
{
	glUniform1i(glGetUniformLocation(ID, name.c_str()), value);
}

void Shader::setFloat(const std::string& name, float value) const
{
	glUniform1f(glGetUniformLocation(ID, name.c_str()), value);
}

void Shader::checkCompileErrors(unsigned int shader, std::string type)
{
	int success;
	char infoLog[1024];
	if (type != "PROGRAM")
	{
		glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
		if (!success)
		{
			glGetShaderInfoLog(shader, 1024, NULL, infoLog);
			std::cout << "ERROR::SHADER_COMPILATION_ERROR of type: " << type << "\n" <<infoLog <<"\n	-- --------------------------------------------------- -- " <<std::endl;
		}
	}
	else
	{
		glGetProgramiv(shader, GL_LINK_STATUS, &success);
		if (!success)
		{
			glGetProgramInfoLog(shader, 1024, NULL, infoLog);
			std::cout << "ERROR::PROGRAM_LINKING_ERROR of type: " << type << "\n" << infoLog<< "n --	--------------------------------------------------- -- " << std::endl;
		}
	}
}


```
