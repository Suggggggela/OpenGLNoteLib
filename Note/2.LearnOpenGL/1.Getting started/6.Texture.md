
## 1.uv
![[assets/6.Texture_image_1.png]]

对于纹理的采样，我们需要uv坐标进行uv映射，openGL左下角是00点
我们可以先把uv存在Vertices中
```cpp
float vertices[] = 
{ // ---- 位置 ----    ---- 颜色 ----      - 纹理坐标 
 0.5f,  0.5f, 0.0f,    1.0f, 0.0f, 0.0f,  1.0f, 1.0f, // 右上 
 0.5f, -0.5f, 0.0f,    0.0f, 1.0f, 0.0f,  1.0f, 0.0f, // 右下 
-0.5f, -0.5f, 0.0f,    0.0f, 0.0f, 1.0f,  0.0f, 0.0f, // 左下 
-0.5f,  0.5f, 0.0f,    1.0f, 1.0f, 0.0f,  0.0f, 1.0f // 左上 
};
```

## 2.texture setting
### 纹理设置类型
#### Warpping 纹理环绕
uv的范围一般都是映射在（0，1）的范围映射
WrappingMode说的是超过这个范围，贴图应该是什么样的
- Repeat，默认，重复纹理
- MirrorRepeat，镜像重复
- Clamp to edege，钳制到边上，边缘超出范围会被拉伸
- Clamp to Boder，边缘超出范围为制定颜色
![[assets/6.Texture_image_2.png|724x202]]
#### Filtering 纹理过滤
纹理过滤是指如何根据uv和纹素（texel = texture pixel）计算出映射到屏幕上的像素的
因为贴图和屏幕分辨率是不同的，所以就需要纹理过滤这种方法来保证屏幕上显示的尽可能没有锯齿和平滑，并根据纹理的大小和视图中的大小差异平滑过渡纹理（两种情况：uv映射到比texel大或者小的情况，对应缩小纹理Minification和放大纹理Magnification，进行分别设置）
常见的两种：
- Nearest，最临近，取周围最近的颜色
- Linear，线性插值，根据uv周围的texel颜色进行插值，取颜色
- ![[assets/6.Texture_image_3.png|394x328]]

#### Mipmap
早期的游戏中会出现相机运动远处纹理闪烁的情况，实际上是因为此时那里的texel>pixel了
mipmap的出现很好的解决了这个问题
它的全名叫多级渐远纹理，它在texutre的原分辨率的基础上产生多级纹理，后边的每一级都是之前分辨率的1/2
对于内存，开启mipmap后会增加1/3
![[assets/6.Texture_image_4.png|268x179]]
不同级别之间的mipmap切换会带来不真实的割裂感感，所以你也可以对它指定一种过滤方式来缓解
最后要注意的是：mipmap大都用来纹理缩小min的时候，因为它产生的多级纹理分辨率都是小于原texture的，所以设置过滤模式时，需要设置的是GL_TEXTURE_MIN_FILTER
对于生成mipmap，我们可以通过glGenerateMipmap完成
### 纹理设置方式
上述的纹理设置，都可以通过`glTextureParameter`设置
以这里为例，我们进行纹理配置

```cpp
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
```

## 3.UseTexture
#### VertexAttribute
记得把新加到vertices中的uv指定到布局在中
```cpp
//set vertex attribute layer
//pos
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);
//vColor
glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float),
    (void*)(3*sizeof(float)));
glEnableVertexAttribArray(1);
//uv
glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float),
    (void*)(6*sizeof(float)));
glEnableVertexAttribArray(2);

```

#### UseTexture

加载纹理使用的也是stb_image库，具体不多说了，最好新建个vendor文件夹放stb_image
我们直接放上生成Texture的全部代码
```cpp
unsigned int texture1, texture2;//id
int width, height, nrChannels;

glGenTextures(1, &texture1);
glBindTexture(GL_TEXTURE_2D, texture1);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
stbi_set_flip_vertically_on_load(true);//翻转
unsigned char* data = stbi_load("textures/container.jpg", &width, &height, &nrChannels, 0);
if (data)
{
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);//为texture分配内存
	glGenerateMipmap(GL_TEXTURE_2D);
}
else
{
    std::cout << "Failed to load textures/container.jpg" << std::endl;
}
stbi_image_free(data);

//texture2...

//set texture uniform
textureShader.use();

textureShader.setInt("texture1", 0);
textureShader.setInt("texture2", 1);


while(Renering)
{
    //Draw
    //BindTextureUnit，这里glad是2023版本如下设置，cherno的版本是2019，可以通过glBindTextureUnit设置
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, texture1);
    glActiveTexture(GL_TEXTURE1);
    glBindTexture(GL_TEXTURE_2D, texture2);

    //useShader
    textureShader.use();
}
```

