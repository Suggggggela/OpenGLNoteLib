

## 1.Camera
上节我们学习了ViewMatrix，它代表着相机
OpenGL是没有Camera的概念的，所有Camera的变换实际上都是场景的反向变换，通过ViewMatrix实现的

当我们讨论ViewSpace时，是在以Camera的视角作为场景原点为基础上，讨论场景中所有顶点的坐标
也就是说ViewMatrix将这些坐标从世界空间转换到相对于Camera位置和方向的View坐标

那么如何定义一个Camera呢？我们可以像之前定义正视和透视一样的方法通过几个属性描述它：
- Position，位置（世界空间）
- Direction，观察方向
- Right，指向右侧的向量
- Up，指向上方的向量

![[assets/9.Camera_image_1.png|682x158]]

### Position
位置就是一个世界空间中指向Camera位置的向量，以上节的为例：
```cpp
glm::vec3 cameraPos = glm::vec3(0.0f, 0.0f, 3.0f);
```

### Direction
方向是说Camera指向的方向，我们通常使用CameraTarget和CameraPos来描述
我们以Target为场景原点为例：
```cpp
glm::vec3 cameraTarget = glm::vec3(0.0f, 0.0f, 0.0f);
//cameraTarget - cameraPos = Camera看向场景原点的方向
//以上的情况下，Camera看向的z轴是负的
//我们希望Camera看向的是Z轴的正方向，所以下边反转了两个点相减的主次顺序
glm::vec3 cameraDirection = glm::normalize(cameraPos - cameraTarget);
```

### Right
右方向代表着Camera的x轴
我们从上边知道Direction是指向Z轴方向的，然后再构造一个指向Y轴的UpVector，就可以通过叉乘得到右方向
```cpp
glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f);
glm::vec3 cameraRight = glm::normalize(glm::cross(up, cameraDirection));
```

### Up
上方向代表着Camera的y轴，上边已经有了Direction和Right，我们进行叉乘就能得到了
```cpp
glm::vec3 cameraUp = glm::cross(cameraDirection, cameraRight);
```

### LookAt矩阵
前边三者组成了一个坐标系，在这三个坐标轴的基础上，再加一个平移向量，就构成了一个看着(Look at)给定目标的观察矩阵：LookAt矩阵
你可以用这个矩阵乘以任何向量来将其变换到上边这个坐标空间
![[assets/9.Camera_image_2.png|431x127]]

                                                //R = Right
                                                //U = Right
                                                //D = Direction
                                                //P = CameraPosition
glm提供了构建LookAt矩阵的方法：
```cpp
glm::mat4 view; 
view = glm::lookAt(glm::vec3(0.0f, 0.0f, 3.0f), glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 1.0f, 0.0f));
//Parameter:CameraPosition,CameraTarget,Up
```

当然，你也可以手动计算LookAt矩阵

```cpp
// Custom implementation of the LookAt function 
glm::mat4 calculate_lookAt_matrix(glm::vec3 position, glm::vec3 target, glm::vec3 worldUp) 
{ // 1. Position = known 
 // 2. Calculate cameraDirection 
 glm::vec3 zaxis = glm::normalize(position - target); 
 // 3. Get positive right axis vector 
 glm::vec3 xaxis = glm::normalize(glm::cross(glm::normalize(worldUp), zaxis)); 
 // 4. Calculate camera up vector 
 glm::vec3 yaxis = glm::cross(zaxis, xaxis); 
 
 // Create translation and rotation matrix 
 // In glm we access elements as mat[col][row] due to column-major layout 
 glm::mat4 translation = glm::mat4(1.0f); // Identity matrix by default 
 translation[3][0] = -position.x; // Third column, first row 
 translation[3][1] = -position.y; 
 translation[3][2] = -position.z; 
 glm::mat4 rotation = glm::mat4(1.0f); 
 rotation[0][0] = xaxis.x; // First column, first row 
 rotation[1][0] = xaxis.y; 
 rotation[2][0] = xaxis.z; 
 rotation[0][1] = yaxis.x; // First column, second row 
 rotation[1][1] = yaxis.y; 
 rotation[2][1] = yaxis.z; 
 rotation[0][2] = zaxis.x; // First column, third row 
 rotation[1][2] = zaxis.y; 
 rotation[2][2] = zaxis.z; // Return lookAt matrix as combination of translation and rotation matrix 
 return rotation * translation; // Remember to read from right to left (first translation then rotation) 
 } 

 // Don't forget to replace glm::lookAt with your own version 
 // view = glm::lookAt(glm::vec3(camX, 0.0f, camZ), glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 1.0f, 0.0f)); 
 view = calculate_lookAt_matrix(glm::vec3(camX, 0.0f, camZ), glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 1.0f, 0.0f));

```

### 绕着Y轴旋转观观察场景
我们将CameraTarget固定为场景原点（0,0,0），固定相机的y轴，通过一个半径Radius环绕着观察
```cpp
float radius = 10.0f; 
//更新相机的x，z，让它环绕着移动
float camX = sin(glfwGetTime()) * radius; 
float camZ = cos(glfwGetTime()) * radius; 
glm::mat4 view = glm::lookAt(glm::vec3(camX, 0.0, camZ), glm::vec3(0.0, 0.0, 0.0), glm::vec3(0.0, 1.0, 0.0));
```


## 2.相机系统
### 相机移动
相机的移动，我们可以通过键盘的wasd控制
首先定义相机的属性
```cpp
glm::vec3 cameraPos = glm::vec3(0.0f, 0.0f, 3.0f); 
glm::vec3 cameraFront = glm::vec3(0.0f, 0.0f, -1.0f); 
glm::vec3 cameraUp = glm::vec3(0.0f, 1.0f, 0.0f);
```
此时的View矩阵可以这样表示
```cpp
view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);
```

接下来就是根据键盘的输入进行变换，示例中已经有glfwInput的相关代码了
```cpp
void processInput(GLFWwindow *window) 
    { ... 
    float cameraSpeed = 0.05f; // adjust accordingly 
    if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) 
    cameraPos += cameraSpeed * cameraFront; 
    if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) 
    cameraPos -= cameraSpeed * cameraFront; 
    if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) 
    cameraPos -= glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed; 
    if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) 
    cameraPos += glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed; 
    }
```

### 欧拉角 Euler angles
欧拉角是可以表示3D空间中任意旋转的3个值，分别为：
- pitch 俯仰角
- yaw 偏航角
- roll 滚转角
![[assets/9.Camera_image_3.png|583x195]]

对于Camera系统，我们只关心前两个pitch和yaw，给定这两个值，我们就可以计算出一个代表相机方向的新向量

我们把半径设定1，推一下如何通过pitch和yaw表示方向向量的x，y，z
![[assets/9.Camera_image_4.png|498x488]]
通过上边我们就知道代码里应该这样写
```cpp
cameraDirection.x = cos(glm::radians(pitch)) * cos(glm::radians(yaw));
cameraDirection.y = sin(glm::radians(pitch));
cameraDirection.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch))
```

### 鼠标输入

上述我们知道可以用过pitch和yaw计算出CameraDirection，现在我们看一下如何通过鼠标移动计算出pitch和yaw
基本上可以概括为以下几步：
- 计算鼠标距上一帧的偏移量。
- 把偏移量添加到摄像机的俯仰角和偏航角中。
- 对偏航角和俯仰角进行最大和最小值的限制。
-  计算方向向量。


```cpp
//1.
float lastX, lastY;
float xoffset = xpos - lastX;
float yoffset = lastY - ypos; // 注意这里是相反的，因为y坐标是从底部往顶部依次增大的
lastX = xpos; 
lastY = ypos;
//2.
yaw += xoffset; 
pitch += yoffset;
//3.
if(pitch > 89.0f) pitch = 89.0f; 
if(pitch < -89.0f) pitch = -89.0f;

//4.
glm::vec3 front = glm::vec3(1.0f); 
front.x = cos(glm::radians(pitch)) * cos(glm::radians(yaw)); 
front.y = sin(glm::radians(pitch)); 
front.z = cos(glm::radians(pitch)) * sin(glm::radians(yaw)); 
cameraFront = glm::normalize(front);
```


### 缩放
缩放(Zoom)是通过fov控制的，fov代表了能看到场景的范围

```cpp
//yoffset为滚轮的y
if(fov >= 1.0f && fov <= 45.0f)
fov -= yoffset; 
if(fov <= 1.0f) 
fov = 1.0f; 
if(fov >= 45.0f) 
fov = 45.0f;

//重新计算projectionMatrix
projection = glm::perspective(glm::radians(fov), 800.0f / 600.0f, 0.1f, 100.0f);
```

### 鼠标的CallBack
上边鼠标的输入逻辑我们只列举了伪代码，实际的代码中会有区别，我们需要将逻辑写在一个方法中，在鼠标进行相关动作的回调函数中调用它
例如：鼠标输入调整pitch和yaw
```cpp
void mouse_callback(GLFWwindow* window, double xpos, double ypos);
void mouse_callback(GLFWwindow* window, double xpos, double ypos) 
{
    ...
}
//在window设置的时候，注册回调函数
// glfw window creation
GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, "LearnOpenGL", NULL, NULL); 
if (window == NULL) 
{ 
    std::cout << "Failed to create GLFW window" << std::endl; 
    glfwTerminate(); 
    return -1;
} 

glfwMakeContextCurrent(window); 
glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);  
glfwSetCursorPosCallback(window, mouse_callback);//注册鼠标移动的回调函数到glfw
```

## 3.Camera Class

```cpp
//Header
#ifndef CAMERA_H
#define CAMERA_H

#include <glad/glad.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>

enum Camera_Movement 
{
	FORWARD,
	BACKWARD,
	LEFT,
	RIGHT
};

const float YAW			= -90.0f;
const float PITCH		= 0.0f;
const float SPEED		= 2.5f;
const float SENSITIVITY = 0.1f;
const float ZOOM		= 45.0f;	

class Camera
{
public:
	glm::vec3 Position;
	glm::vec3 Front;
	glm::vec3 Up;
	glm::vec3 Right;
	glm::vec3 WorldUp;

	float Yaw;
	float Pitch;
	float MovementSpeed;
	float MouseSensitivity;
	float Zoom;

	//construct with vec
	Camera(glm::vec3 position = glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f), float yaw = YAW, float pitch = PITCH);
	//construct with value
	Camera(float posX, float posY, float posZ, float upX, float upY, float upZ, float yaw, float pitch);


	glm::mat4 GetViewMatrix();
	void ProcessKeyboard(Camera_Movement direction, float deltaTime);

	void ProcessMouseMovement(float xoffset, float yoffset, GLboolean constrainPitch = true);

	void ProcessMouseScroll(float yoffset);

private:
	void updateCameraVectors(); //用于更新
};

#endif

```


```cpp
//cpp
#include "Camera.h"


	Camera::Camera(glm::vec3 position, glm::vec3 up, float yaw, float pitch)
		: Front(glm::vec3(0.0f, 0.0f, -1.0f)), MovementSpeed(SPEED), MouseSensitivity(SENSITIVITY), Zoom(ZOOM)
	{
		Position = position;
		WorldUp = up;
		Yaw = yaw;
		Pitch = pitch;
		updateCameraVectors();
	}

	Camera::Camera(float posX, float posY, float posZ, float upX, float upY, float upZ, float yaw, float pitch)
		: Front(glm::vec3(0.0f, 0.0f, -1.0f)), MovementSpeed(SPEED), MouseSensitivity(SENSITIVITY), Zoom(ZOOM)
	{
		Position = glm::vec3(posX, posY, posZ);
		WorldUp = glm::vec3(upX, upY, upZ);
		Yaw = yaw;
		Pitch = pitch;
		updateCameraVectors();
	}
glm::mat4 Camera::GetViewMatrix()
{
	return glm::lookAt(Position, Position + Front, Up);
}

void Camera::ProcessKeyboard(Camera_Movement direction, float deltaTime)
{
	float velocity = MovementSpeed * deltaTime;
	if (direction == FORWARD)
		Position += Front * velocity;
	if (direction == BACKWARD)
		Position -= Front * velocity;
	if (direction == LEFT)
		Position -= Right * velocity;
	if (direction == RIGHT)
		Position += Right * velocity;
}

void Camera::ProcessMouseMovement(float xoffset, float yoffset, GLboolean constrainPitch)
{
	xoffset *= MouseSensitivity;
	yoffset *= MouseSensitivity;

	Yaw += xoffset;
	Pitch += yoffset;

	// make sure that when pitch is out of bounds, screen doesn't get flipped
	if (constrainPitch)
	{
		if (Pitch > 89.0f)
			Pitch = 89.0f;
		if (Pitch < -89.0f)
			Pitch = -89.0f;
	}

	updateCameraVectors();
}

void Camera::ProcessMouseScroll(float yoffset)
{
	Zoom -= (float)yoffset;
	if (Zoom < 1.0f)
		Zoom = 1.0f;
	if (Zoom > 45.0f)
		Zoom = 45.0f;
}

void Camera::updateCameraVectors()
{
	glm::vec3 front;
	front.x = cos(glm::radians(Yaw)) * cos(glm::radians(Pitch));
	front.y = sin(glm::radians(Pitch));
	front.z = sin(glm::radians(Yaw)) * cos(glm::radians(Pitch));
	
	// normalize the vectors, because their length gets closer to 0 the more you look up or down which results in slower movement.
	Front = glm::normalize(front);
	Right = glm::normalize(glm::cross(Front, WorldUp));  
	
	Up = glm::normalize(glm::cross(Right, Front));
}


```


## 4.测试

### 相机
初始化

```cpp
//camera
Camera camera(glm::vec3(0.0f, 0.0f, 3.0f));//构造相机
float lastX = SCR_WIDTH / 2.0f;
float lastY = SCR_HEIGHT / 2.0f;
bool firstMouse = true;
//time
float deltaTime = 0.0f;
float lastFrame = 0.0f;


```

### 鼠标回调

回调方法
```cpp
void mouse_callback(GLFWwindow* window, double xposIn, double yposIn)
{
    float xpos = static_cast<float>(xposIn);
    float ypos = static_cast<float>(yposIn);

    if (firstMouse)
    {
        lastX = xpos;
        lastY = ypos;
        firstMouse = false;
    }

    float xoffset = xpos - lastX;
    float yoffset = lastY - ypos; // reversed since y-coordinates go from bottom to top

    lastX = xpos;
    lastY = ypos;

    camera.MouseSensitivity = 0.01;
    camera.ProcessMouseMovement(xoffset, yoffset);
}

void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)
{
    camera.ProcessMouseScroll(static_cast<float>(yoffset));
}

```

在glfw初始化window时，注册回调事件

```cpp
glfwMakeContextCurrent(window);

glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
glfwSetCursorPosCallback(window, mouse_callback);
glfwSetScrollCallback(window, scroll_callback);

glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED); //查看场景状态，隐藏鼠标指针
```

### 键盘

```cpp
void processInput(GLFWwindow* window)
{
    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
        glfwSetWindowShouldClose(window, true);

    if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
        camera.ProcessKeyboard(FORWARD, deltaTime);
    if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
        camera.ProcessKeyboard(BACKWARD, deltaTime);
    if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
        camera.ProcessKeyboard(LEFT, deltaTime);
    if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
        camera.ProcessKeyboard(RIGHT, deltaTime);
}

```
