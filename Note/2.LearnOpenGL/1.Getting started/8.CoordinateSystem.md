
## 1.空间
这节的内容是坐标系统，也就是常说的几个空间，这里提到的有以下这些：
- **局部空间/模型空间**，模型本身的空间，模型自带的
- **世界空间**，模型空间通过M矩阵转换到“游戏世界”之后的空间
- **观察空间**，相机观察下的空间，通过View矩阵转换



- **裁剪空间**

裁剪空间是一个4D空间（齐次坐标）,顾名思义它是用来裁剪的空间

通过Projection(投影矩阵)将物体从ViewSpace映射到裁剪空间，xyz都是（-1,1）的范围
此时，物体的坐标范围会被限制在一个特定的**ViewingBox**（如正射投影的盒子或透视投影的平截头体）内。
进入裁剪空间后，会对物体**进行裁剪**，超出范围的都会被裁剪，只有在这个空间的范围内的顶点才会被送到管线的下个阶段继续处理


- **NDC空间(**标准化设备空间) ，

在裁剪空间裁剪完成后，物体会通过**透视除法**被变换到标准化设备空间
NDC 空间中的坐标是相对于视口（窗口）坐标系的。这些 NDC 坐标会被映射到最终的屏幕空间坐标

**透视除法**是**将4D裁剪空间坐标变换为3D标准化设备坐标**的过程，在这个过程中我们将位置向量的x，y，z分量分别除以向量的齐次w分量进行归一化
这一步位于顶点shader输出和光栅化之间，**会顶点着色器运行的最后被自动执行**（也就是vs输出gl_Position之后）

- **屏幕空间**
物体经过裁剪和透视除法转换到NDC空间后，会进行最后一步：**视口变换**（viewport transform）

NDC空间是(-1~1)的，OpenGL会根据viewport的大小映射到（width，height）
通过视口变换后就是屏幕空间了，屏幕空间是最终渲染图像的坐标空间

## 2.MVP变换
**MVP变换**
MVP其实就是Model，View，Projection，这描述了一个顶点坐标被变换到裁剪坐标的过程
![[assets/8.CoordinateSystem_image_1.png|371x56]]
这个反向的顺序是因为OpenGL是列主序的
//对于"列主序" ，可以查看Hazel-Camera这一节的内容 [31.Camera](../../../../../【3.Engine】/Cherno_Hazel/31.Camera.md)

## 3.投影类型
### Frustum平截头体
平截头体就是上边物体从ViewSpace转换到ClipSapce后被限制到的特定的**ViewingBox**
在平截头体中的物体都会被映射到屏幕上
对于不同类型的投影，投影矩阵不同，他们的平截头体也不同，我们一一道来

### 正视投影
正视投影定义了一个立方体Frustum，它直接将坐标映射到2D平面
我们可以用以下这些属性描述它：
- NearPlane，近平面
- FarPlane，远平面
- Width，Height
![[assets/8.CoordinateSystem_image_2.png|247x210]]

```cpp
glm::ortho(0.0f, 800.0f, 0.0f, 600.0f, 0.1f, 100.0f);
//Parameter:left,right,bottom,top,nearPlan,farPlane
```

### 透视投影
现实世界是存在透视关系的，所以对于3D来说，需要透视投影解决正视投影的不真实感
透视投影的投影矩阵，额外修改了每个顶点坐标的w值，离相机越远的物体w分量越大，那么经过透视除法后它就越小（近大远小）

我们同样使用一些属性定义它：
- fov，field of view视野，觉得了观察空间的大小
- aspect，宽高比，既width/height
- NearPlane
- FarPlane
![[assets/8.CoordinateSystem_image_3.png|352x298]]


```cpp
glm::mat4 proj = glm::perspective(glm::radians(45.0f), (float)width/(float)height, 0.1f, 100.0f);
//Parameter:fov(弧度制，角度记得转换),宽高比，近平面，远平面
```


## 4.测试
首先shader中定义mvp的uniform，并在position处应用

```glsl
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
void main()
{
    gl_Position = vec4(aPos, 1.0);
    gl_Position = projection * view * model * vec4(aPos, 1.0);
    TexCoord = aTexCoord;
}

```

Vertices处，我们这次定义36个顶点的cube（6个面，每个面6个顶点），并且index1的Attribute为uv

```cpp
 float vertices[] = {
     -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,
      0.5f, -0.5f, -0.5f,  1.0f, 0.0f,
      0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
      0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
     -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
     -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,

     -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
      0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
      0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
      0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
     -0.5f,  0.5f,  0.5f,  0.0f, 1.0f,
     -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,

     -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
     -0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
     -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
     -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
     -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
     -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

      0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
      0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
      0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
      0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
      0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
      0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

     -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
      0.5f, -0.5f, -0.5f,  1.0f, 1.0f,
      0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
      0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
     -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
     -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,

     -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
      0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
      0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
      0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
     -0.5f,  0.5f,  0.5f,  0.0f, 0.0f,
     -0.5f,  0.5f, -0.5f,  0.0f, 1.0f
 };

```

设置VertexAttribute的Layout

```cpp
 // position attribute
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);
// texture coord attribute
glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float)));
glEnableVertexAttribArray(1);

```

texture部分不用做修改，在RenderLoop中，设置mvp矩阵，绘制一个3D的立方体

```cpp
glm::mat4 model = glm::mat4(1.0f);  
glm::mat4 view = glm::mat4(1.0f); 
glm::mat4 projection = glm::mat4(1.0f); 

model = glm::rotate(model, (float)glfwGetTime(), glm::vec3(0.5f, 1.0f, 0.0f)); 
view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f)); 
projection = glm::perspective(glm::radians(45.0f), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f); 

unsigned int modelLoc = glGetUniformLocation(ourShader.ID, "model"); 
unsigned int viewLoc = glGetUniformLocation(ourShader.ID, "view"); 
unsigned int projectionLoc = glGetUniformLocation(ourShader.ID, "projection"); 
glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model)); 
glUniformMatrix4fv(viewLoc, 1, GL_FALSE, glm::value_ptr(view)); 
glUniformMatrix4fv(projectionLoc, 1, GL_FALSE, glm::value_ptr(projection)); 

glBindVertexArray(VAO); 
glDrawArrays(GL_TRIANGLES, 0, 36); //记得是绘制36个顶点

```
