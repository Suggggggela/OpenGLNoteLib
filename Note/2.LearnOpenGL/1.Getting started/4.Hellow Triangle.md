## Preface

OpenGL 中所有事物都是 3D 的，而屏幕都是 2D 的，所以 OpenGL 的一大部分工作就是 transform 3D 坐标 to 2D

​	为了完成这项工作，我们需要 Graphic/Render Pipeline 这个老生畅谈的东西
使用 RenderPipeline 可以轻松地用称为 shader 的程序，让这个工作并行的跑在 GPU 上

大致过程如下：

​	vextex DATA -> vertex shader -> geometry shader -> primitive assembly -> rasterization->  clipping -> fragment shader -> testing、blending

![](assets/4.Hellow%20Triangle_image_1.png)
​	//RenderPipeline Picture

​	如果要画些什么东西，比如一个三角形，首先需要知道三角的三个顶点的坐标。
我们将这三个顶点的坐标传入一个数组中以供使用，它叫做 **顶点数据(VertexData)**

这里我们先简单阐述一下几个概念

- 顶点(Vertex)
	- 一个3D坐标的**数据集合**（比如位置、顶点色）
- 顶点数据(VertexData)
	- 包含了**数据集合的所有类型**,它可以包含任何我们需要的数据
- 顶点属性(VertexAttribute)
	- 用顶点属性表示，一系列**顶点的集合**



因为叫做管线/流水线，所以整个过程中下一阶段的输入基本是上一阶段的输出，这里我们先概括的描述一下这个过程：

1.Vertex Shader接收顶点作为输入，一般进行顶点维度的操作，和坐标变化
2.Primitive Assembly接收VertexShader阶段输出的顶点，根据指示将其装配成指定的图元（比如：三角形还是点还是面？）
3.Geometry Shader不是必须配置的，它支持我们将图元形式的顶点生成新的图元
4.Rasterization光栅化过程会将图元映射成屏幕上的像素，以后后续操作
5.Clipping裁切发生在FragmentShader之前，这一步会将废弃的像素裁切掉，避免在后续片元着色器中进行无用功（已经被丢掉的，就不要着色了）
6.FragmentShader接收上一阶段的像素，进行着色计算，这一步之后像素就有了对应的颜色
7.最后，我们对像素进行各种Testing和Blending，决定最后显示出的样子





## 一、Vertex Input

首先我们要知道两点：
- OpenGL是一个3D图形库，所以我们指定的坐标都是三维坐标xyz
- OpenGL并不是把所有范围的3D坐标转换为屏幕的2D坐标，仅转换各个轴[-1,1]这个范围的坐标。我们把这些坐标叫做NDC(Normal Deviced Coordinates)，这个范围以外的坐标都不会显示到屏幕上

因为我们现在只想画一个简单的三角形，所以这里我们先直接将NDC规范过后的坐标存在一个float数组中，表示三角形的三个顶点
```cpp
flaot vertices[] = {
    -0.5f,-0.5f,0.0f,
     0.5f,-0.5f,0.0f,
     0.0f, 0.5f,0.0f}
//其中，Z代表屏幕的深度（Depth）
```

有了VertexData之后，下一步就是将它作为input 送到 vertex shader中

这一步是这样完成的：
- 在GPU  Memory上拿出一块内存用来存放VertexData
- 配置OpenGL如何解释这块内存，如何送到显卡，
- 接下来的Vertex Shader中就会对内存中的这些顶点进行处理

> 上述说的这块内存叫做VBO（VertexBufferObject），它是可以存放大量vertices的一块GPU内存，我们用它来管理VertexData（使用VBO的好处就是，我们可以将batch的一大批vertices一次性发送给GPU）

这个过程大概有以下几步：
- Generate VBO with unique ID
- Bind to corresponding type Buffer Object
- Copy VertexData to buffer's memory

### 1.Generate VBO
vertex buffer object是我们接触的第一个OpenGLObject，和OpenGL章节所说的任何一个OpenGL中的object一样，拥有一个对应的Unique ID，我们像下边这样来生成：
```cpp
unsigned int VBO;
glGenBuffers(1,&VBO);
```

### 2.Bind Buffer Object
OpenGL中有许多种buffer object类型，vertex buffer对应的类型是`GL_ARRAY_BUFFER`
OpenGL支持我们绑定多个buffer object，只要它们不是同一个类型的即可

```cpp
glBindBuffer(GL_ARRAY_BUFFER,VBO);
```

### 3.Copy VertexData To Buffer‘s Memory
一但我们将VBO绑定到了GL_ARRAY_BUFFER，接下来使用的任何GL_ARRAY_BUFFER目标上的缓冲调用都会用来配置绑定的VBO
接下来我们用`glBufferData`函数，将之前声明的VertexData复制到Buffer的内存中
```cpp
glBufferData(GL_ARRAY_BUFFER,sizeof(vertices),vertices,GL_STATIC_DRAW);
//glBufferData是用来将数据复制到当前绑定buffer的函数
//参数详解
  //BUFFER TYPE
  //数据大小（bytes）
  //实际数据
  //管理数据形式，有三种管理形式
    //GL_STATIC_DRAW，代表数据几乎不会变
    //GL_DTNAMIC_DRAW，代表数据会被频繁改变
    //GL_STREAM_DRAW，代表数据每次绘制都会被改变
```

## 二、Vertex Shader
在上一小节中，我们通过VBO将VertexData存到GPU内存中，接下来我们写一个处理这些数据的Shader
值得一提的是，如果我们需要用modern OpenGL渲点什么，那么需要至少配置一个Vertex和Fragment Shader
这节我们用GLSL写一个最最简单的VertexShader，并且编译它
可以注意以下关键点：
  - 每个着色器都以版本声明为起始
  - 使用`in`关键字声明所有的Input Vertex Attribute

```cpp
//1.begin with a declaration of it's version
#version 330 core
//2.declare the input vertex attribute use "in" keyword
  //there we only use one vertex attribute since we only careabout the position
  //"layout (location=0)" set the location
layout (location = 0) in vec3 aPos;

void main()
{
  gl_Position = vec4(aPos.x, aPos.y, aPos.z,1.0);
  //gl_Positon是一个预定义的变量，作为VertexShader的输出，为vec4类型
  //vec4的第四个参数叫做perspective division，会在后续的空间变换部分详细讲解
}
```
为了演示，这段代码中我们没有对输入坐标数据做任何转换就输出了（我们定义时就是按照NDC坐标定义的），实际情况下，输入的坐标数据都不是NDC坐标

## 三、Compiling shader
编译Shader SourceCode我们可以简单分为以下几个Step：
- store source code in C-Style "Const Char"
- creat shader object
- creat shader with `glCreatShader`
- attach shader source code and compiling

### 1.store source code
首先我们使用`const char`将VertexShader的SourceCode硬编码到c风格的字符串中
```cpp
//we have to compile shader at run-time,in order for OpenGL use
const char *vertexShaderSouce = 
"#version 330 core\n"
"layout (location = 0) in vec3 aPos;\n" 
"void main()\n" 
"{\n" 
" gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n" 
"}\0";
```

### 2.Creat shader Object
接下来使用ID引用创建Shader Object，并使用`glCreatShader`创建shader
```cpp
unsigned int vertexShader;
vertexShader = glCreatShader(GL_VERTEX_SHADER);
```
### 3.attach shader object and source code ,compile
将shader sourcecode attach到 shader object上，然后编译它
```cpp
glShaderSource(vertexShader,1,&vertexShaderSource,NULL);
//params:
  //shaderObject
  //how many strings passing as source code
  //source code
  //???待解释
glCompileShader(vertexShader);
```
### Note:Check compile result
最后，我们可以通过以下方法检查编译的结果
```cpp
int success;
char infiLog[512];

//this reture shader's compile status
glGetShaderiv(vertexShader,GL_COMPILE_STATUS,&success);

if(!success)
{
  glGetShaderInfoLog(vertexShader,512,NULL,infoLog);
  std:cout << "ERROR::SHADER::VERTEX::COMPILATION_FAILD\n" << infoLog <<std::endl;
}
```

## 四、Fragment Shader
### 1.basic fragment shader
`The fragment shader is all about calculating the color output of your pixels`
为了简单起见，我们只是单纯的输出一个纯色
```cpp
#version 330 core 
out vec4 FragColor;
void main()
{
  FragColor = vec4(1.0f,0.5f,0.2f,1.0f);
}
```
fragment shader只需要一个vec4输出变量，代表着颜色的RGBA4个通道
这里我们使用一个`out`关键字声明

### 2.compile it
像vertexShader一样，我们使用相同的step将其编译
```cpp
//generate shaderObject
unsigned int fragmentShader;
fragmentShader = glCreatShader(GL_FRAGMENT_SHADER);

//attach sourceCode and Object
glShaderSource(fragmentShader,1,&fragmentShaderSource,NULL);

//compile it
glCompileShader(fragmentShader);
```

## 五、Shader Program
vertexShader和fragmentShader都编译好了，想要使用他们，就需要需要将两个shaderObject link到一个用来渲染的Shader Program
### 1.Shader Program Object
Shader Program Object是多个shader合并、Link的结果，在渲染对象的时候激活这个Shader Program，它就会在发送渲染call的时候被使用
当link多个shader到一个program时，它会将每个shader的输出link到下个shader输入。此时如果出现输出和输入不匹配的情况，就会出现link error
### 2.Steps for Use Shader Program 
大致可以概括为以下几步：
- creat shader program
- attach shader to program,and link 
- use program
- delete shader objs after linked

创建shaderProgram object
```cpp
unsigned int shaderProgram;
//use "glCreatProgram" creat shader program
shaderProgram = glCreatProgram();
```

attach shader 到 program，然后使用`glLinkProgram`进行link
```cpp
glAttachShader(shaderProgram,vertexShader);
glAttachShader(ShaderProgram,fragmentShader);
glLinkProgram(shaderProgram);
```

使用编译shader时类似的方法，检查一下lnik结果
```cpp
glGetProgramiv(shaderProgram,GL_LINK_STATUS,&success);
if(!sucess)
{
  glGetProgramInfoLog(shaderProgra,512,NULL,infoLog);
  ......
}
```

在link的结果是一个程序对象，我们可以使用`glUseProgram`来激活
```cpp
glUseProgram(shaderProgram);
//Every shader and rendering call after glUseProgram will now use this program object.
```

最后，在link完成后，记得删除shaderObject，完成相应的工作之后，我们就不需要他们了(悲)
```cpp
glDeleteShader(vertexShader);
glDeleteShader(fragmentShader);
```

到此为止，我们就将 输入的vertexData 发送给GPU，并且告诉GPU在shader中如何处理它了。

## 六、linking Vertex Attribute
不过不要激动，OpenGL还有两个问题没有解决：
- 如何解释memory中的vertexData？
- 如何将GPU中的vertexData和vertexShader的Attribute联系起来？

这一小节就是用来解决这些问题的，引用ChernoOpenGL系列里的说法：**告诉OpenGL你vertexData的布局(Layout，或者说数据的组织方式)**

### 1.How vertex buffer data organized
vertexShader允许我们指定任何vertexAttribute形式的input
代价是我们必须手动指定input的**vertex Data的哪一部分**对应着**vertexShader的哪一个Attribute**
所以，在开始渲染前，我们必须告诉OpenGL该如何解释vertexData

vertex buffer data会为以下这样的组织方式被解释：
![](assets/4.Hellow%20Triangle_image_2.png)
通过上边的示意图，我们可以提取出以下有效信息：
- position data(上述的X、Y、Z)被存储为32位(bit) = 4字节(byte)的float
- 每个position包含3个上边这样的position data
- 这三个值之间没有空隙，在数组中**紧密排列(Tightly Packed)**
- data中的第一个值位于buffer的开始

有了这些信息我们就可以告诉OpenGL如何解释vertexData(per vertex attribute)了
我们使用`glVertexAttribPointer`这个函数来完成
```cpp
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); 
//参数详解
  //[param1]：which vertex attribute want to configure
            //因为这个示例中我们在VS的in输入使用"layout(location = 0)"为location定义了position类型的vertex attribute，所以这里传0到第一个参数
  //[param2]：size of the vertex attribute
            //示例中vertex attribute的类型是vec3,所以这里传3
  //[param3]：param2's data type
            //示例中为vec3,实际上是3个float，所以这里写"GL_FLOAT"
  //[param4]:whether the data to be normalized
            //如果填GL_TRUE,会被normalized到[-1,1]
            //这里我先填GL_FALSE
  //[param5]：Stride(步长),the space between consecutive vertex attributes.
            //上边我们说过了,数据之间是"紧密排列"的,所以我们可以推测出两个vertex attribute之间的空间 = data type 长度 = 3 float
            //注意,这里我们也可以填“0”,OpenGL会自己推测,前提是数据之间是紧密排列的
  //[param6]：the offset where the positiondata begins in buffer
            //这个参数需要是void类型的,所以进行强制类型转换
            //上边我们说了,data中的第一个值位于buffer开始,所以offset应该=0


```

回顾刚开始提到的VBO这个概念，我们可以梳理一下**vertex attribute 和 vertex data是如何被对应的**：
- each vertex attribute 从VBO管理的内存获取data
- 从哪个VBO管理的内存处获取,取决于在告诉OpenGL如何解释VertexData时（调用glVertexAttribPointer时），具体是哪个VBO将其绑定到`GL_ARRAY_BUFFER`的（调用glBufferData时）
- 因为顺序是绑定VBO-> 调用`glVertexAttribPointer`,所以在调用这个之前，先前定义的VBO仍处于绑定状态,这样一来vertex attribute 0 与它的vertex data 关联(associated)了


在确定如何解释 vertex data之后，我们还需要通过`glEnableVertexAttribArray`来Enable vertex attribute(默认情况下它是被discard的)
```cpp
glEnableVertexAttribArray(0); 
//argument = vertex attribute location
```

这么一来我们基本做好准备了：
- 先用VBO初始化Buffer的vertex data
- 设置了vs fs,并告诉OpenGL如何将vertex data link到 vs的vertex attribute 

那么现在用OpenGL画一个Object可以概括成以下流程：
```cpp
// 0. copy our vertices array in a buffer for OpenGL to use 
glBindBuffer(GL_ARRAY_BUFFER, VBO); 
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); 
// 1. then set the vertex attributes pointers 
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); 
glEnableVertexAttribArray(0); 
// 2. use our shader program when we want to render an object 
glUseProgram(shaderProgram); 
// 3. now draw the object 
some draw funcs......
```
如果情况有变，复**杂到多个VertexAttribute和多个Object时，就不得不重复绑定VBO、为每个Object配置vertex Attributes的步骤**
这样一来，就成了一个很繁琐的过程(一个网格就要写一段这样类似的代码)

借助VBO-vertices的思路，我们可以抽象出一个新的Object来简化这个过程，于是就有了VAO

### 2.VAO
VAO = Vertex Array Object,就像VBO一样，也可以被绑定到特定的东西上(VertexArray)
![](assets/4.Hellow%20Triangle_image_3.png)
一个VAO中存着以下数据：
- Calls to `glenable/DisableVertexAttribArray` 
	对enable/disableVertexAttributeArray函数的调用
	
- vertex attribute configurations(by `glVertexAttribPointer`)
通过glVertexAttributePoint设置顶点属性的配置

- vertex buffer objects associated with vertex attributes （by calls to `glVertexAttribPointer`）
    	通过调用glVertexAttributePointer告诉OpenGL的数据组织方式(布局)


使用VAO的好处是：**就算有多个东西需要画，也只用调用一个glVertexAttribPointer来配置VertexAttribute**，当绘制对象的时候，绑定相应的VAO即可，因为刚刚设置的所有装填都存在VAO里了

值得一提的是，Core OpenGL是必须使用VAO的，不然它会拒绝画些什么东西。

//关于VAO的深入理解，可以看看其他资料回答
知乎回答： https://www.zhihu.com/question/30095978/answer/2297871479
Cherno关于VAO的视频： https://www.youtube.com/watch?v=Bcs56Mm-FJY

### 3.Use VAO
使用VAO可以分为以下几种情况：
- Generate VAO
- 配置VBO时绑定VBO然后取消绑定备用
- 绘制对象前将VAO与Preferred Settings绑定

Generate VAO
```cpp
unsigned int VAO;
glGenVertexArrays(1,&VAO);
```

VAO的绑定的情况类似下边的代码
```cpp
// 0.Initialization
	.......
// 1.Bind VAO
glBindVertexArray(VAO);
// 2.copy vertices array into VBO 
glBindBuffer(GL_ARRAY_BUFFER,VBO);
glBufferData(GL_ARRAY_BUFFER,sizeof(vertices),vertices,GL_STATIC_DRAW);
//3.set vertex attributes pointers
glVertexAttribPointer(0,3,GL_FLOAT,GL_FALSE,3*sizeof(float),(void*)0);
glEnableVertexAttributArray(0);
//以上的2、3步，也绑定了我们上边所说VAO中包含的3个东西：VertexArray状态、数据的布局，VBO

[...]
//Draw code in render loop[]
// 4.draw obj
glUseProgram(shaderProgram);
glBindVertexArray(VAO);//Bind VAO before draw funcs
someDrawFuncs();
```


### 4.Draw Triangle！
终于到了这一步，OpenGL提供了`glDrawArrays`这个函数，使用它通过当前激活的shader、预设的vertex attribute 配置、VBO的vertex data（使用VAO之后，通过VAO间接绑定）来绘制片元
```cpp
glUseProgram(shaderProgram);
glBindVertexArray(VAO);
glDrawArrays(GL_TRIANGLES,0,3);
//参数详解
	//[param1]:primitive type we'd like to draw
	//[param2]:starting index of the vertex array
	//[param3]:counts of vertices we'd like to draw
```
完整的代码可以参考原地址：
          https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/2.1.hello_triangle/hello_triangle.cpp

## 七、EBO
### 1.Use EBO
在谈论什么是EBO之前，我们来考虑一种新的情况：画一个矩形
因为OpenGL主要处理三角形，那么有一个想法是通过画两个三角形拼起来，合成一个矩形
我们将vertices改为下边这样
```cpp
float vertices[] =
{ 
  // first triangle
  0.5f, 0.5f, 0.0f, // top right
  0.5f, -0.5f, 0.0f, // bottom right 
  -0.5f, 0.5f, 0.0f, // top left 
  
  // second triangle 
  0.5f, -0.5f, 0.0f, // bottom right
  -0.5f, -0.5f, 0.0f, // bottom left 
  -0.5f, 0.5f, 0.0f // top left 
};
```
![|350](assets/4.Hellow%20Triangle_image_4.png)
根据上边的示意图你会发现一个问题：左上和右下这两个顶点被画了两遍
当然这种情况下还好，但如果顶点数超过一定数量级后，这显然不合理
有没有解决这种情况的办法呢？
答案是有的，比如：
          **我们可以存储唯一的顶点，然后为这些顶点指定绘制顺序**

EBO = Element Buffer Obejct 就是以这个原理工作的
就像VAO、VBO一样，EBO中也存着一些东西，它存的是顶点绘制的索引（即：以怎样的顺序绘制顶点）

使用上述方法的话，vertices和index应该是下边这样：
```cpp
float vertices[] = 
{
  0.5f, 0.5f, 0.0f, // top right 
  0.5f, -0.5f, 0.0f, // bottom right 
  -0.5f, -0.5f, 0.0f, // bottom left 
  -0.5f, 0.5f, 0.0f // top left
};
//draw vertex index 
unsigned int indices[] =
{
//first triangle
  0,1,3,
  //second triangle
  1,2,3
};
```
EBO相关的代码如下
```cpp
//1.Create
unsigned int EBO;
glGenBuffers(1,&EBO);

//2.Copy indices into buff
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,EBO);
glBufferData(GL_ELEMENT_ARRAY, sizeof(indices), indices,GL_STATIC_DRAW );

//3.use "glDrawElements" replace "glDrawArrays"
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,EBO);
glDrawElements(GL_TRIANGLE, 6, GL_UNSIGNED_INT, 0);
//参数详解
  //[param1]：draw mode
  //[param2]:  counts of elements we'd like to draw
  //[param3]:  type of indices
  //[param4]:  allows specify an offset in the EBO(or when u're not use EBO, pass in an index array)
```

### 2.bind EBO to VAO
`glDrawElements(GL_TRIANGLE, 6, GL_UNSIGNED_INT, 0);`
上边最后一行代码中，“glDrawElements”这个函数，接收的indices数据是从当前绑定到"GL_ELEMENT_ARRAY"目标的EBO中获取的
这意味着每次渲染带有indices的对象时，都需要绑定相应的EBO，这个情况和引入VAO时有点类似
因为VAO恰好也能跟踪EBO绑定的，所以我们可以使用以下方法：
**将最新的EBO绑定到VAO，这样一来，绑定到VAO后，也会自动绑定EBO**
![](assets/4.Hellow%20Triangle_image_5.png)
注意！当绑定target为"GL_ELEMENT_ARRAY_BUFFER"时，VAO会存着"glBindBuffer"的指令，这就意味着：VAO中也存着EBO的unbind的指令。**也就是说：EBO解绑的状态也在VAO中存着**
所以在**解绑VAO之前不要解绑EBO，不然就相当于没配置EBO了**

最后的代码类似于这样：

```cpp
// ..:: 初始化代码 :: .. 
// 1. 绑定顶点数组对象 
glBindVertexArray(VAO); 
// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用 
glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); 
// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用 
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW); 
// 4. 设定顶点属性指针 
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0); [...] 

// ..:: 绘制代码（渲染循环中） :: .. 
glUseProgram(shaderProgram); 
glBindVertexArray(VAO); 
glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); glBindVertexArray(0);
```











