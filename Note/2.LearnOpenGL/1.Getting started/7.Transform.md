
这节涉及到现代的知识，具体就不做完整说明，我们仅仅整理一些结论性的内容

## 1.Vector
- 向量有哪些属性？
方向和长度，长度为一的为方向向量

- 向量有哪些运算？
    - 取反：所有分量取反
    - 和标量运算：每个分量和标量运算
    - 加减：对应分量做加减
    - 点乘：dot(a,b) 点乘的结果等于两个向量的长度相乘 x cosθ，θ为向量夹角（对于单位为1的方向向量，点乘=他们的cosθ）
    - 叉乘：cross(a,b) 叉乘的结果等于这两个向量构成平面的法向

## 2.Matrix
矩阵和标量的运算：对所有分量做运算

### 矩阵和矩阵之间的运算
#### 乘法
![335x196](assets/7.Transform_image_1.png)

![358x324](assets/7.Transform_image_2.png)

### 矩阵和向量之间的运算
#### 单位矩阵
这个矩阵乘以一个向量，这个向量不会变化
![381x139](assets/7.Transform_image_3.png)
#### Scale
![395x133](assets/7.Transform_image_4.png)

#### Translate
![399x157](assets/7.Transform_image_5.png)
#### Rotate
![543x379](assets/7.Transform_image_6.png)

沿着任意轴3旋转的：
![612x91](assets/7.Transform_image_7.png)
#### Transform变换（以上三种的总称）
我们可以将矩阵组合起来，表示一次变换transform
注意，矩阵是左乘

## 3.glm
数学库依然用的glm，将文件夹放到vendor里就行
## 4.test
首先测试一下glm有没有配置成功

```cpp
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>

 glm::vec4 vec(1.0f, 0.0f, 0.0f, 1.0f);
 glm::mat4 trans = glm::mat4(1.0f);//0.9.9及以上版本需要初始化为单位矩阵
 trans = glm::translate(trans, glm::vec3(1.0f, 1.0f, 0.0f));
 vec = trans * vec;
 std::cout << vec.x << vec.y << vec.z << std::endl;//(1+1,0+1,0+0)
```

成功了之后，就可以在vertexshader中添加transform的Unifrom，并在程序中动态更新，让它动起来了