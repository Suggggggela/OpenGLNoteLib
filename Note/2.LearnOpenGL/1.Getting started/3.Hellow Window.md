  在一切开始前，我们先验证一下 GLFW 和 GLAD 是否
## 一、Check GLFW 
‌‌‌　　我们使用以下代码进行测试，具体作用写在注释中

```cpp
#include <glad/glad.h> 
#include <GLFW/glfw3.h>
#include <iostream>

‌‌‌　　int main()
‌‌‌　　{
    //GLFW Init
    glfwInit();
    //GLFW Configure
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);//3 代表 OpenGL 版本
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
        //mac OS use 
        //glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
‌‌‌　　}
```
‌‌‌　　此时编译一下项目，如果有 undefined reference 错误，说明你的 GLFW 并没有配置好


‌‌‌　　我们继续在 main 函数中写，创建一个窗口对象，并且使用 glfw 将它设置为当前线程的主 contex
```cpp
‌‌‌　　GLFWwindow* window = glfwCreateWindow(800, 600, "LearnOpenGL", NULL, NULL); 
‌‌‌　　if (window == NULL) 
‌‌‌　　{ 
    std::cout << "Failed to create GLFW window" << std::endl; 
    glfwTerminate(); 
    return -1; 
‌‌‌　　} 
‌‌‌　　glfwMakeContextCurrent(window);
```

## 二、Check GLAD
  前边提到过，GLAD 是替我们完成 OpenGL 指针管理的，所以在调用任何 OpenGL 函数之前，需要先进行以下操作

```cpp
‌‌‌　　//glad manage OpenGLFunPointer before call any OpenGLFunc
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
    {
        std::cout << "Failed to initialize GLAD" << std::endl;
        return -1;
    }
```

## 三、ViewPort
  接下来就可以干点正事了。

  首先告诉 OpenGL 窗口（ViewPort）的大小


```cpp
‌‌‌　　//func param (bottom conner corrd, width, height)
‌‌‌　　glViewport(0,0,width,height);
```

  //这里注意，你需要区分清 glfw window 和 OpenGL ViewPort 的区别
  //一般我们使用维度（Dimension）来描述 ViewPort 的宽高大小，你可以将 OpenGL ViewPort 的维度设置的比 glfw window 小，这样你就可以在 OpenGL 窗口外画些别的东西了

  因为窗口大小会被随时修改，所以我们将它写成一个回调方法

```cpp
‌‌‌　　//Declare outside the mainFunc
‌‌‌　　void framebuffer_size_callback(GLFWwindow* window, int width, int height);

‌‌‌　　//tell glfw set OpenGLViewPort size when window size change, before glad 
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
```

## 四、Ready your engine
  按照正常的逻辑，渲染当然不是绘制完图像后关闭退出窗口，所以我们需要做一些符合常理的东西，比如：
      屏幕上将一直绘制，除非用户主动关闭
```cpp
‌‌‌　　//Render Loop
    while (!glfwWindowShouldClose(window))
    {
        //check if any event triggered
        glfwPollEvents();
        //swap the color buffer
        //Color Buffer = 
        //a large 2D buffer that contains color values for each pixel in GLFW's window
        glfwSwapBuffers(window);
    }
```
这里我们解释一下为什么需要 "swap buffer"
    因为绘制生成的图像并不是即时的，而是逐像素的，也就是说如果我们将绘制的结果即时输出到屏幕上，会出现伪影闪烁的问题。
双缓冲(double bufffer)就是为了解决这个问题。
    它将缓冲区分为前缓冲区和后缓冲区。后缓冲用来根据命令逐像素绘制，当绘制命令执行完毕，得到完整的屏幕画面时，就 swap 到前缓冲区，显示到屏幕上。

## 五、Last step of RenderLoop
  当 RenderLoop 结束时，我们需要释放和删除 GLFW 分配下的所有资源，可以通过在 Main 函数的末尾调用以下函数来实现

```cpp
    //relase resource
    glfwTerminate();
    return 0;
```


到此为止，如果一切正确，跑一下项目，会得到一个黑的 OpenGL 窗口

## 六、Input
  这部分我们来添加一些输入事件的支持
  例如，当我们按下 ESC 的时候，退出 ViewPort

```cpp
    //input func 
    void processInput(GLFWwindow *window) 
    { 
        if(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) 
            glfwSetWindowShouldClose(window, true); 
    }

    //insert into render loop
    while (!glfwWindowShouldClose(window)) 
    { 
        processInput(window); 
        
        glfwSwapBuffers(window); 
        glfwPollEvents(); 
    }
```

## 七、Rendering

  终于到了正菜，渲染部分的代码我们应该在 Render Loop 中完成，代码结构类似这样
```cpp
// render loop 
while(! glfwWindowShouldClose(window))
    { 
        // input 
        processInput(window); 
        
        // rendering commands here ... 
        
        
        // check and call events and swap the buffers 
        glfwPollEvents(); 
        glfwSwapBuffers(window); 
    }
```

  为了测试，我们将 ViewPort 渲染成一个纯色，可以使用以下代码
  而且可以在调用 glClear 之前，使用 `glClearColor(color)` 指定一个颜色去 clear

```cpp
//this is a state-setting func
glClearColor(0.2f, 0.3f, 0.3f, 1.0f);

//this is a state-using func
glClear(GL_COLOR_BUFFER_BIT);
```

如果我们没有使用 glClearColor 配置颜色，那么填充的颜色将是默认的黑色

## SourceCode

```c++
#include <glad/glad.h>
#include <GLFW/glfw3.h>

#include <iostream>

//Declare funcs
void framebuffer_size_callback(GLFWwindow* window, int width, int height);
void processInput(GLFWwindow* window);

int main()
{
    //GLFW Init
    glfwInit();
    //GLFW Configure
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
        //mac OS use 
        //glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);

    //Creat Window
    GLFWwindow* window = glfwCreateWindow(800, 600, "LearnOpenGL", NULL, NULL);
    if (window == NULL)
    {
        std::cout << "Failed to create GLFW window" << std::endl;
        glfwTerminate();
        return -1;
    }
    glfwMakeContextCurrent(window);

    //glad manage OpenGLFunPointer before call any OpenGLFunc
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
    {
        std::cout << "Failed to initialize GLAD" << std::endl;
        return -1;
    }

    //set OpenGLWindow size
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);

    //Render Loop
    while (!glfwWindowShouldClose(window))
    {
        //input
        processInput(window);
        
        //rendering
            //state-setting function
            //set the color that clear use, when glClear be called
            glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
            //state-using function
            //clear the color buffer
            glClear(GL_COLOR_BUFFER_BIT);

        //check and call event, swap buffers
        glfwPollEvents();
        glfwSwapBuffers(window);
    }

    //relase resource
    glfwTerminate();
    return 0;
}

// glfw: whenever the window size changed (by OS or user resize) this callback function executes
void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{
    // make sure the viewport matches the new window dimensions; note that width and 
    // height will be significantly larger than specified on retina displays.
    // the first two is viewport bottom left conner coord
    glViewport(0, 0, width, height);
}

// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly
void processInput(GLFWwindow* window)
{
    //esc -> close window
    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
        glfwSetWindowShouldClose(window, true);
}
```



