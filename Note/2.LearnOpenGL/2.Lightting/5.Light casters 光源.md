## 1.平行光
平行光描述的是处于无限远的光源，当这个光源足够远时，照过来的光线都是平行的相同方向，就像太阳一样
描述平行光可以用以下的属性：
- direction

![[assets/5.Light casters 光源_image_1.png|354x227]]


//注意，这里的direction是光源指向物体的，和shader中计算需要的LightDir方向是相反的，所以在shader中记得取反
```cpp

struct Light {
    //vec3 position;
    vec3 direction;

    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};


```

## 2.点光源
点光源的特点是具有位置，朝所有方向发光，并且光会随着和光源位置的距离衰减
- position
- attenuation

![[assets/5.Light casters 光源_image_2.png|404x224]]

**点光源的衰减**
点光源的衰减并不是线性的，而是在一定距离后快速衰减，之后再缓慢衰减
一般我们使用以下的经验衰减曲线：
- F = 衰减值
- d = 距离
- 常数项Kc、一次项Kl和二次项Kq         常数项一般为1

![[assets/5.Light casters 光源_image_3.png|222x55]]
它的衰减大致是这样的：
![[assets/5.Light casters 光源_image_4.png|386x212]]

对于一次项和二次项，经验参数为： https://wiki.ogre3d.org/tiki-index.php?page=-Point+Light+Attenuation

|距离|常数项|一次项|二次项|
|---|---|---|---|
|7|1.0|0.7|1.8|
|13|1.0|0.35|0.44|
|20|1.0|0.22|0.20|
|32|1.0|0.14|0.07|
|50|1.0|0.09|0.032|
|65|1.0|0.07|0.017|
|100|1.0|0.045|0.0075|
|160|1.0|0.027|0.0028|
|200|1.0|0.022|0.0019|
|325|1.0|0.014|0.0007|
|600|1.0|0.007|0.0002|
|3250|1.0|0.0014|0.000007|

```cpp

struct Light {
    vec3 position;

    vec3 ambient;
    vec3 diffuse;
    vec3 specular;

    float constant;
    float linear;
    float quadratic;
};

// attenuation
float distance = length(light.position - FragPos);
float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));



```




## 3.聚光灯

聚光灯的特点是只朝一个方向发送光线，结果就是只有在聚光方向的特定半径内的物体才会被照亮，其它的物体都会保持黑暗
OpenGL中聚光是用一个世界空间位置、一个方向和一个切光角(Cutoff Angle，切光角指定了聚光的半径）表示的
- `LightDir`：从片段指向光源的向量
- `SpotDir`：聚光所指向的方向
- `Phi ϕ`：指定了聚光半径的切光角，落在这个角度之外的物体都不会被这个聚光所照亮，当向量为单位向量时，cosφ = dot(LDir, SpotDir)
- `Theta θ`：LightDir向量和SpotDir向量之间的夹角，在聚光内部的话θ值应该比ϕ值小。
![[assets/5.Light casters 光源_image_5.png|423x306]]


**判断是否在聚光灯范围内**
```cpp
float theta = dot(lightDir, normalize(-light.direction)); 
if(theta > light.cutOff) 
{ // 执行光照计算 
} else // 否则，使用环境光，让场景在聚光之外时不至于完全黑暗 
color = vec4(light.ambient * vec3(texture(material.diffuse, TexCoords)), 1.0);
```
关于这里的判断条件：当θ > 切光角时，执行光照计算的解释：
            当前代码中θ和切光角，都不是角度值而是cos值表示的
            当角度为0°，cos = 1
            当角度为90°， cos =0
            也就是说：当角度越大时，cos越小，所以判断条件为>代表的是角度小于


**平滑灯光边缘**
如果直接按上边的计算的话，shading的情况会是下边这样，我们必须处理一下边缘的硬切边
![[assets/5.Light casters 光源_image_6.png|349x220]]

处理硬切边的方法是：创建两个圆锥，内圆锥为原聚光源的范围，外圆锥用来柔滑切边
外圆锥需要一个额外的cosγ，当一个片元处在θ和γ之间，就应用一个强度为0~1的平滑
它的公式如下：  
ϵ(Epsilon)是内（θ）和外圆锥（γ）之间的余弦值差（ϵ = θ − γ）
I值就是在当前片段聚光的强度。
![[assets/5.Light casters 光源_image_7.png]]

```cpp

struct Light 
{ 
    vec3 position; 
    vec3 direction; 
    float cutOff; 
    float outerCutOff; 
    vec3 ambient; 
    vec3 diffuse; 
    vec3 specular; 
    float constant; 
    float linear; 
    float quadratic; 
};


// spotlight (soft edges)
float theta = dot(lightDir, normalize(-light.direction));
float epsilon = (light.cutOff - light.outerCutOff);
float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0);
diffuse *= intensity;
specular *= intensity;

// attenuation
float distance = length(light.position - FragPos);
float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));

```


具体的测试代码我们留到下节多光源进行

