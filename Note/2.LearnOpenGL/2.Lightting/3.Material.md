
材质包含着shading的数据集，这节我们对shader的整体进行结构化重构
## 1.Materia Struct
材质结构体中的数据代表着各部分光照的**颜色**
```cpp
#version 330 core 
struct Material 
{ 
    vec3 ambient; 
    vec3 diffuse; 
    vec3 specular; 
    float shininess; //影响镜面高光的散射/半径
}; 

uniform Material material;

```

在shader中设置材质的时候，就是访问成员的那样的写法，例如
```cpp

vec3 specular = lightColor * (spec * material.specular);


```
cpu端设置Uniform也是同样的：
```cpp
lightingShader.setVec3("material.ambient", 1.0f, 0.5f, 0.31f);
```


对于现实世界材质的模拟，可以通过下边的链接查询 : http://devernay.free.fr/cours/opengl/materials.html
## 2.Light Struct
Light结构体的数据代表着各部分光照的**权重**，通过这样的计算，就能避免上边材质数据计算后过曝的情况（实际上是能量不守恒了）

```cpp
struct Light
{ 
    vec3 position; 
    vec3 ambient; 
    vec3 diffuse; 
    vec3 specular; 
}; 

uniform Light light;
```

相应的，在计算光照时我们要加入各部分光照的权重

```cpp
vec3 specular = light.specular * (spec * material.specular);
```

Uniforms的设置和material完全一致

## 3.测试
CPU端
```cpp
//Draw
//--------------------cube------------------------------
blinnPhongShader.use();
blinnPhongShader.setVec3("objectColor", 0.2f, 0.5f, 0.3f);
blinnPhongShader.setVec3("viewPos", camera.Position);
//lightUnifroms
glm::vec3 lightColor = glm::vec3(1.0f,1.0f,1.0f);
glm::vec3 diffuseColor = lightColor * glm::vec3(0.5f);
glm::vec3 ambientColor = diffuseColor * glm::vec3(0.2f);
blinnPhongShader.setVec3("light.position", lightPos);
blinnPhongShader.setVec3("light.ambient", ambientColor);
blinnPhongShader.setVec3("light.diffuse", diffuseColor);
blinnPhongShader.setVec3("light.specular", 1.0f, 1.0f, 1.0f);
//materialUniforms
blinnPhongShader.setVec3("material.ambient", 1.0f, 0.5f, 0.31f);
blinnPhongShader.setVec3("material.diffuse", 1.0f, 0.5f, 0.31f);
blinnPhongShader.setVec3("material.specular", 0.5f, 0.5f, 0.5f);
blinnPhongShader.setFloat("material.shininess", 32.0f);
```

Shader

```cpp
#version 330 core
out vec4 FragColor;

struct Material
{
    vec3 ambient; 
    vec3 diffuse; 
    vec3 specular; 
    float shininess; //影响镜面高光的散射/半径
};

struct Light {
    vec3 position;

    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};

in vec3 FragPos;
in vec3 Normal;

uniform vec3 viewPos;
uniform vec3 objectColor;
uniform Material material;
uniform Light light;

void main()
{

  vec3 normal = normalize(Normal);
  vec3 lightDir = normalize(light.position - FragPos);
  vec3 viewDir = normalize(viewPos - FragPos);
  vec3 reflectDir = reflect(-lightDir, normal);
  
  //InDirect
   vec3 ambient = material.ambient * light.ambient;
  //Dirct
  vec3 diffuse = (max(dot(normal,lightDir), 0.0) * material.diffuse) * light.diffuse;
  
  float glossy = material.shininess;
  vec3 specular = (pow(max(dot(viewDir, reflectDir), 0), glossy) * material.specular) * light.specular ;
  
  //Final
  vec3 final = (ambient + diffuse + specular) ;
  FragColor = vec4(final, 1.0);
  //FragColor = vec4(1.0, 1.0, 1.0, 1.0);
 
}
```
