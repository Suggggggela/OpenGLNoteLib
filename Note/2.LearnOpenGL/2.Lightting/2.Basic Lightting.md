
这节我们写一个简单的Phong模型光照
## 1.环境灯光
环境灯光这里只是简单的添加一个颜色因子

```cpp
void main() 
{ 
    float ambientStrength = 0.1; 
    vec3 ambient = ambientStrength * lightColor; 
    vec3 result = ambient * objectColor; 
    FragColor = vec4(result, 1.0); 
}

```

## 2.漫反射
漫反射描述的是光照和物体表面因为夹角θ而带来的效果
而描述物体表面的属性，就是**法向量**，它代表垂直于物体表面的方向，也就是面的朝向
通过光照的方向和法向量，我们就可以通过点乘计算出θ（所以这里的向量我们需要进行normalize），进而计算出漫反射
![413x297](assets/2.Basic%20Lightting_image_1.png)

```CPP
    cosθ = dot（normal,lightDir）; //向量都为单位向量
```

### 法向量
法向量一般是通过geometry传递进来的
对于模型的单个顶点，是没有法向量的，如果想要计算的话，可以通过周围的顶点构建出表面，和顶点叉乘计算出法向
例子中我们直接把法线存在Vertices中，然后在VertexAttribute中指定Layout即可
### 漫反射
解决完法向量问题，我们来看看LightDirection怎么计算
我们需要知道两个点来计算向量：CameraPosition，FragmentPosition

在世界空间中计算漫反射的话：
对于LightPosition，在例子中就是代表Light的cube的世界空间Position
对于FragmentPosition，其实就是顶点的世界空间位置，我们可以通过M矩阵将模型的顶点转换的到世界空间
```cpp
uniform vec3 lightPos;
FragPos = vec3(model * vec4(aPos, 1.0));
```

拿到数据后，我们可以在FragmentShader计算漫反射

```cpp
vec3 norm = normalize(Normal); 
vec3 lightDir = normalize(lightPos - FragPos);

vec3 diff = max(dot(norm, lightDir), 0.0); 
vec3 diffuse = diff * lightColor;

```

### 法线矩阵
当我们谈论法线矩阵时一般都在说顶点法线，它同来转换法线到世界空间
因为顶点可以通过M矩阵将其转换到世界空间，但对于法向量来说，不等比缩放时会造成法线不垂直于表面
![303x178](assets/2.Basic%20Lightting_image_2.png)

避免这个情况应运而生的就是法线矩阵，它使用了一些线性代数的操作来移除对法向量错误缩放的影响
法线矩阵被定义为：M矩阵左上角3x3部分的逆矩阵的转置矩阵
这个矩阵是将顶点法线转换到ViewSpace的，我们只需要转换到世界空间，所以只使用M矩阵就够了
```cpp
NormalMatrix = mat3(transpose(inverse(model)));
```


## 3.镜面反射（高光）
镜面反射描述的是光经过表面反射到观察者眼中的现象，反射和观察者的方向夹角越小，反射光就越强
![315x225](assets/2.Basic%20Lightting_image_3.png)
上图橙色的向量为反射向量ReflectDirection，可以通过LightDir和Normal计算
灰色的向量为ViewDirection，可以通过观察者位置和像素位置计算


```cpp
uniform vec3 viewPos;
lightingShader.setVec3("viewPos", camera.Position);
vec3 specularStrength = 0.5;

vec3 viewDir = normalize(viewPos - FragPos); 
vec3 reflectDir = reflect(-lightDir, norm);

vec3 spec = pow(max(dot(viewDir, reflectDir), 0.0), 32); 
vec3 specular = specularStrength * spec * lightColor;

```

到此为止，整个光照模型的总体如下：

```cpp
vec3 result = (ambient + diffuse + specular) * objectColor; 
FragColor = vec4(result, 1.0);

```



## 4.GroundShading
GroundShading说白了就是这个光照模型放在VertexShader计算，性能消耗少，但是效果也差了
![2.Basic Lightting_image_4](assets/2.Basic%20Lightting_image_4.png)
## 5.测试
接下来我们测试这节的内容


```cpp

// lighting
glm::vec3 lightPos(1.2f, 1.5f, 2.0f);


float vertices[] = {
    -0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,
     0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,
     0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f,
     0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f,
    -0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f,
    -0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,

    -0.5f, -0.5f,  0.5f,  0.0f,  0.0f,  1.0f,
     0.5f, -0.5f,  0.5f,  0.0f,  0.0f,  1.0f,
     0.5f,  0.5f,  0.5f,  0.0f,  0.0f,  1.0f,
     0.5f,  0.5f,  0.5f,  0.0f,  0.0f,  1.0f,
    -0.5f,  0.5f,  0.5f,  0.0f,  0.0f,  1.0f,
    -0.5f, -0.5f,  0.5f,  0.0f,  0.0f,  1.0f,

    -0.5f,  0.5f,  0.5f, -1.0f,  0.0f,  0.0f,
    -0.5f,  0.5f, -0.5f, -1.0f,  0.0f,  0.0f,
    -0.5f, -0.5f, -0.5f, -1.0f,  0.0f,  0.0f,
    -0.5f, -0.5f, -0.5f, -1.0f,  0.0f,  0.0f,
    -0.5f, -0.5f,  0.5f, -1.0f,  0.0f,  0.0f,
    -0.5f,  0.5f,  0.5f, -1.0f,  0.0f,  0.0f,

     0.5f,  0.5f,  0.5f,  1.0f,  0.0f,  0.0f,
     0.5f,  0.5f, -0.5f,  1.0f,  0.0f,  0.0f,
     0.5f, -0.5f, -0.5f,  1.0f,  0.0f,  0.0f,
     0.5f, -0.5f, -0.5f,  1.0f,  0.0f,  0.0f,
     0.5f, -0.5f,  0.5f,  1.0f,  0.0f,  0.0f,
     0.5f,  0.5f,  0.5f,  1.0f,  0.0f,  0.0f,

    -0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,
     0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,
     0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,
     0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,
    -0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,
    -0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,

    -0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f,
     0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f,
     0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,
     0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,
    -0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,
    -0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f
};


//--------------cuebe---------------------------------
unsigned int cubeVAO, VBO;// , EBO;
glGenVertexArrays(1, &cubeVAO);
glGenBuffers(1, &VBO);
//glGenBuffers(1, &EBO);
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

//vertex attribute layout
glBindVertexArray(cubeVAO);
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);
glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));
glEnableVertexAttribArray(1);
//------------------------------------------------------

//---------------lightCube------------------------------
unsigned int lightCubeVAO;
glGenVertexArrays(1, &lightCubeVAO);
glBindVertexArray(lightCubeVAO);
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);//虽然我们只用了前3个float，但是VBO这里有6个float大小
glEnableVertexAttribArray(0);
//------------------------------------------------------

//Render Loop
while (!glfwWindowShouldClose(window))
{
    float currentFrame = static_cast<float>(glfwGetTime());
    deltaTime = currentFrame - lastFrame;
	lastFrame = currentFrame;

    //input
    processInput(window);

    glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    //Update lightCube Pos
    float radius = 1.5f;
    float angle = glfwGetTime() * 2; // 控制速度，可乘以系数
    lightPos.x = radius * sin(angle);
    lightPos.z = radius * cos(angle);
    // y 坐标可以保持不变，或根据需要调整
    lightPos.y = 0.3f;


    //Draw
    //--------------------cube------------------------------
    blinnPhongShader.use();
    blinnPhongShader.setVec3("objectColor", 0.2f, 0.5f, 0.3f);
    blinnPhongShader.setVec3("lightColor", 1.0f, 1.0f, 1.0f);
    blinnPhongShader.setVec3("lightPos",lightPos);
    blinnPhongShader.setVec3("viewPos", camera.Position);

    //MVP
	glm::mat4 model = glm::mat4(1.0f);
    glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f);
	glm::mat4 view = camera.GetViewMatrix();
    
    blinnPhongShader.setMat4("projection", projection);
    blinnPhongShader.setMat4("view", view);
    blinnPhongShader.setMat4("model", model);
    glBindVertexArray(cubeVAO);
	glDrawArrays(GL_TRIANGLES, 0, 36);
    //-------------------------------------------------------

	//--------------------lightCube---------------------------
	lightCubeShader.use();
    lightCubeShader.setMat4("view", view);
    lightCubeShader.setMat4("projection", projection);
    model = glm::mat4(1.0f);//先初始化为单位矩阵
    model = glm::translate(model, lightPos);//将光源位置传入
    model = glm::scale(model, glm::vec3(0.2f));//缩小cube作为光源来展示
    lightCubeShader.setMat4("model", model);

    glBindVertexArray(lightCubeVAO);
	glDrawArrays(GL_TRIANGLES, 0, 36);
    //--------------------------------------------------------
  
    
	
    
    //glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
    //check and call event, swap buffers
    glfwPollEvents();
    glfwSwapBuffers(window);
}


```
