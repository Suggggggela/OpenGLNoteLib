这里我们继续上节的内容，添加多光源支持，并且重新整理结构

## 1.数据结构
### Material

```cpp
struct Material {
    sampler2D diffuse;
    sampler2D specular;
    sampler2D emission;
    float shininess;
}; 


```

### Light

```cpp
struct DirLight {
    vec3 direction;
	
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};

struct PointLight {
    vec3 position;
    
    float constant;
    float linear;
    float quadratic;
	
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};

struct SpotLight {
    vec3 position;
    vec3 direction;
    float cutOff;
    float outerCutOff;
  
    float constant;
    float linear;
    float quadratic;
  
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;       
};

```

## 2.光照函数
### CalcDirLight

```cpp
vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir)
{
    vec3 lightDir = normalize(-light.direction);
    vec3 reflectDir = reflect(-lightDir, normal);
    
    float diff = max(dot(normal, lightDir), 0.0);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // combine results
    vec3 ambient = light.ambient * vec3(texture(material.diffuse, TexCoords));
    vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuse, TexCoords));
    vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords));
    vec3 emission = vec3(texture(material.diffuse, TexCoords)) * vec3(texture(material.emission, TexCoords)) * timeValue;
    return (ambient + diffuse + specular + emission);
}
```

### CalcPointLight

```cpp
vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
    vec3 lightDir = normalize(light.position - fragPos);
    vec3 reflectDir = reflect(-lightDir, normal);
    
    float diff = max(dot(normal, lightDir), 0.0);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);

    float distance = length(light.position - fragPos);
    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));    

    vec3 ambient = light.ambient * vec3(texture(material.diffuse, TexCoords));
    vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuse, TexCoords));
    vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords));
    ambient *= attenuation;
    diffuse *= attenuation;
    specular *= attenuation;
    return (ambient + diffuse + specular);
}

```

### CalcSpotLight

```cpp
vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
    vec3 lightDir = normalize(light.position - fragPos);
    vec3 reflectDir = reflect(-lightDir, normal);

    float diff = max(dot(normal, lightDir), 0.0);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);

    float distance = length(light.position - fragPos);
    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));    

    float theta = dot(lightDir, normalize(-light.direction)); 
    float epsilon = light.cutOff - light.outerCutOff;
    float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0);

    vec3 ambient = light.ambient * vec3(texture(material.diffuse, TexCoords));
    vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuse, TexCoords));
    vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords));
    ambient *= attenuation * intensity;
    diffuse *= attenuation * intensity;
    specular *= attenuation * intensity;
    return (ambient + diffuse + specular);
}

```

## 3.测试

unifrom设置如下

```cpp
 lightingShader.use();
 lightingShader.setVec3("viewPos", camera.Position);
 lightingShader.setFloat("material.shininess", 32.0f);
 lightingShader.setFloat("timeValue", sin(glfwGetTime() * 2) + 1);

 /*
    Here we set all the uniforms for the 5/6 types of lights we have. We have to set them manually and index
    the proper PointLight struct in the array to set each uniform variable. This can be done more code-friendly
    by defining light types as classes and set their values in there, or by using a more efficient uniform approach
    by using 'Uniform buffer objects', but that is something we'll discuss in the 'Advanced GLSL' tutorial.
 */
 // directional light
 lightingShader.setVec3("dirLight.direction", -0.2f, -1.0f, -0.3f);
 lightingShader.setVec3("dirLight.ambient", 0.05f, 0.05f, 0.05f);
 lightingShader.setVec3("dirLight.diffuse", 0.4f, 0.4f, 0.4f);
 lightingShader.setVec3("dirLight.specular", 0.5f, 0.5f, 0.5f);
 // point light 1
 lightingShader.setVec3("pointLights[0].position", pointLightPositions[0]);
 lightingShader.setVec3("pointLights[0].ambient", 0.05f, 0.05f, 0.05f);
 lightingShader.setVec3("pointLights[0].diffuse", 0.8f, 0.8f, 0.8f);
 lightingShader.setVec3("pointLights[0].specular", 1.0f, 1.0f, 1.0f);
 lightingShader.setFloat("pointLights[0].constant", 1.0f);
 lightingShader.setFloat("pointLights[0].linear", 0.09f);
 lightingShader.setFloat("pointLights[0].quadratic", 0.032f);
 // point light 2
 lightingShader.setVec3("pointLights[1].position", pointLightPositions[1]);
 lightingShader.setVec3("pointLights[1].ambient", 0.05f, 0.05f, 0.05f);
 lightingShader.setVec3("pointLights[1].diffuse", 0.8f, 0.8f, 0.8f);
 lightingShader.setVec3("pointLights[1].specular", 1.0f, 1.0f, 1.0f);
 lightingShader.setFloat("pointLights[1].constant", 1.0f);
 lightingShader.setFloat("pointLights[1].linear", 0.09f);
 lightingShader.setFloat("pointLights[1].quadratic", 0.032f);
 // point light 3
 lightingShader.setVec3("pointLights[2].position", pointLightPositions[2]);
 lightingShader.setVec3("pointLights[2].ambient", 0.05f, 0.05f, 0.05f);
 lightingShader.setVec3("pointLights[2].diffuse", 0.8f, 0.8f, 0.8f);
 lightingShader.setVec3("pointLights[2].specular", 1.0f, 1.0f, 1.0f);
 lightingShader.setFloat("pointLights[2].constant", 1.0f);
 lightingShader.setFloat("pointLights[2].linear", 0.09f);
 lightingShader.setFloat("pointLights[2].quadratic", 0.032f);
 // point light 4
 lightingShader.setVec3("pointLights[3].position", pointLightPositions[3]);
 lightingShader.setVec3("pointLights[3].ambient", 0.05f, 0.05f, 0.05f);
 lightingShader.setVec3("pointLights[3].diffuse", 0.8f, 0.8f, 0.8f);
 lightingShader.setVec3("pointLights[3].specular", 1.0f, 1.0f, 1.0f);
 lightingShader.setFloat("pointLights[3].constant", 1.0f);
 lightingShader.setFloat("pointLights[3].linear", 0.09f);
 lightingShader.setFloat("pointLights[3].quadratic", 0.032f);
 // spotLight
 lightingShader.setVec3("spotLight.position", camera.Position);
 lightingShader.setVec3("spotLight.direction", camera.Front);
 lightingShader.setVec3("spotLight.ambient", 0.0f, 0.0f, 0.0f);
 lightingShader.setVec3("spotLight.diffuse", 1.0f, 1.0f, 1.0f);
 lightingShader.setVec3("spotLight.specular", 1.0f, 1.0f, 1.0f);
 lightingShader.setFloat("spotLight.constant", 1.0f);
 lightingShader.setFloat("spotLight.linear", 0.09f);
 lightingShader.setFloat("spotLight.quadratic", 0.032f);
 lightingShader.setFloat("spotLight.cutOff", glm::cos(glm::radians(12.5f)));
 lightingShader.setFloat("spotLight.outerCutOff", glm::cos(glm::radians(15.0f)));

```


![653x490](assets/6.Multiple%20Lights_image_1.png)