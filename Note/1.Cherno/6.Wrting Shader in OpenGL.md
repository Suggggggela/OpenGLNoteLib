
### 1.创建Shader函数 
首先我们使用CompilerShader
这个函数封装一下编译Shader的过程：
- glCreatShader（创建shader对象）
- glShaderSource（将shader代码传给对象）
- glCompilerShader（编译shader）
- 检查shader编译是否出错
- 返回shader对象
```cpp
static unsigned int CompilerShader(unsigned int shaderType, const std::string& source)
{
	unsigned int id = glCreateShader(shaderType);// 创建一个shader对象
	const char* src = source.c_str();
	// 获取shader的源代码
	//c_str()返回一个const char*指针，指向字符
	

	glShaderSource(id, 1, &src, nullptr);
	//将源代码传递给shader对象
	//id是shader对象的id
	// glShaderSource函数的第二个参数是一个int类型的指针，表示源代码的数量
	// 这里我们只传递一个源代码，所以第二个参数是1
	// glShaderSource函数的第三个参数是一个const char*类型的指针，指向源代码的首地址
	// glShaderSource函数的第四个参数是一个int类型的指针，表示源代码的长度.这里我们传递nullptr，表示源代码的长度是自动计算的


	glCompileShader(id);// 编译shader对象

	// 检查编译错误
	int result;
	glGetShaderiv(id, GL_COMPILE_STATUS, &result);
	if (result == GL_FALSE)
	{
		int length;
		glGetShaderiv(id, GL_INFO_LOG_LENGTH, &length);
		char* message = (char*)alloca(length * sizeof(char));
		// 分配一个长度为length的字符数组
		// alloca函数在栈上分配内存，分配的内存会在函数返回时自动释放

		glGetShaderInfoLog(id, length, &length, message);
		std::cout << "Failed to compile"<<(shaderType==GL_VERTEX_SHADER?"vertex" :"fragment") 
			<< std::endl;
		std::cout << message << std::endl;
		glDeleteShader(id);
		return 0;
	}
	return id;
}
```

接着使用CreateShader函数创建一个program对象，并将vs和fsattach上去
```cpp
static unsigned int CreateShader(const std::string& vertexShader, const std::string& fragmentShader)
{
	unsigned int program = glCreateProgram();// 创建一个程序对象
	unsigned int vs = CompilerShader(GL_VERTEX_SHADER, vertexShader);// 创建一个顶点着色器对象
	unsigned int fs = CompilerShader(GL_FRAGMENT_SHADER, fragmentShader);// 创建一个片段着色器对象

	// 将着色器对象附加到程序对象上
	glAttachShader(program, vs);
	glAttachShader(program, fs);
	glLinkProgram(program);
	glValidateProgram(program);
	

	//实际上shader不用删除，这样会导致缺少debug手段
	glDeleteShader(vs);
	glDeleteShader(fs);
	return program;
}

```

### 2.编写shader代码
我们编写一个简单的vs和fs，只是将position传进去，并且每个像素都输出一个简单颜色
```cpp
std::string vertexShader =
	"#version 330 core\n"
	"layout(location=0) in vec4 position;\n"
	"void main()\n"
	"{\n"
	"	gl_Position = position;\n"
	"}\n";
std::string fragmentShader =
	"#version 330 core\n"
	"out vec4 color;\n"
	"void main()\n"
	"{\n"
	"	color = vec4(1.0, 0.0, 0.0, 1.0);\n"
	"}\n";
```

每行都写个换行符很反人类，我们可以使用R"()"将字符串包住来替换
```cpp
std::string vertexShader =
	R(
	"#version 330 core"
	"layout(location=0) in vec4 position;"
	"void main()"
	"{"
	"	gl_Position = position;"
	"}");
```

### 3.使用Shader
在glVertexAttributePointer之后，我们通过上边的CreateShader函数创建一个program对象，并将刚刚写的vs和fs源代码attach上去
    最后使用glUseProgram
```cpp
unsigned int shader = CreateShader(vertexShader, fragmentShader);
glUseProgram(shader);//把shader程序绑定到当前的OpenGL contex中	
```

### 4.运行程序
到此为止我们已经简单的编写了vs和fs，并使用它绘制了一个三角形
