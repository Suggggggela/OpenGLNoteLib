上节我们使用GLFW库，使用传统OpenGL方法在屏幕上绘制了一个三角形

如果你了解过现代GPU的发展，你会知道早期GPU并不支持自定义shader，基本上就是对Pipeline进行一些配置
如果想要使用现代GPU的功能，我们就需要一些方法获取到显卡中支持的现代GPU功能，比如我们访问drive.dll检索出那些库函数的指针
这里我们使用的库是glew（LearnOpenGL使用的是glad）

首先复制上一节的项目，或者干脆在它的基础上进行GLEW的配置

### 1.配置头文件和Linker依赖
和之前一样，相信你已经对这些相当熟悉了
https://glew.sourceforge.net/index.html
在glew中下载二进制文件，找到头文件和静态库，放入项目的Dependencies中
之后分别在C++中配置AdditionalIncludeDir和Linker中配置AdditionalLibraryDir、AdditionalDependencies

### 2.调整glfw和glew的Include顺序
当你在glfw下之后Include glew时，编译会报错， gl.h included before glew.h
解决方法是先include glew

### 3.添加预处理定义
目前为止，你再次编译，会得到以下错误：unresolved external symbol imp__glewInit@0 referenced 
通过定义跳转，我们可以得到以下信息：
![](assets/2.Using%20Modern%20OpenGL%20in%20C++_image_1.png)

![](assets/2.Using%20Modern%20OpenGL%20in%20C++_image_2.png)
因为我们使用的是静态链接，所以需要在property-C++-PreProcesser中添加GLEW_STATIC这个宏
![563x379](assets/2.Using%20Modern%20OpenGL%20in%20C++_image_3.png)

### 4.编译glew并打印当前驱动OpenGL版本
根据glew的文档原文：
```txt
First you need to create a valid OpenGL rendering context and call glewInit() to initialize the extension entry points. If glewInit() returns GLEW_OK, the initialization succeeded and you can use the available extensions as well as core OpenGL functionality
```
我们知道在glew初始化之前需要检查GLEW_OK的状态，并且需要创建一个rendering contex
所以我们把glew的初始化放在glfw初始化context之后
代码如下：
```cpp
#include <GL\glew.h>
#include "GLFW\glfw3.h"
#include <iostream>

int main(void)
{
	GLFWwindow* window;

	/* Initialize the library */
	if (!glfwInit())
		return -1;

	/* Create a windowed mode window and its OpenGL context */
	window = glfwCreateWindow(640, 480, "Hello World", NULL, NULL);
	if (!window)
	{
		glfwTerminate();
		return -1;
	}

	/* Make the window's context current */
	glfwMakeContextCurrent(window);
	
	//Using glew
	if (glewInit() != GLEW_OK)
	{
		std::cout << "Error" << std::endl;
	}
	std::cout << glGetString(GL_VERSION) << std::endl;

	/* Loop until the user closes the window */
	while (!glfwWindowShouldClose(window))
	{
		/* Render here */
		glClear(GL_COLOR_BUFFER_BIT);

		//First Triangle
		glBegin(GL_TRIANGLES);
		glVertex2f(-0.5f,-0.5f);
		glVertex2f( 0.0f,0.5f);
		glVertex2f( 0.5f,-0.5f);
		glEnd();

		/* Swap front and back buffers */
		glfwSwapBuffers(window);

		/* Poll for and process events */
		glfwPollEvents();
	}

	glfwTerminate();
	return 0;
}
```
