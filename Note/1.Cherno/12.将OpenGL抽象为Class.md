这节我们将移动公共代码到类中以进行重复使用，并且还将他们进行参数化

## 一、Renderer
Renderer用于将我们抽象的其他概念串联起来，基本上是给它一个命令，它将为你渲染一些东西

```cpp
//Renderer.h
#pragma once
#include <GL/glew.h>

#define ASSERT(x) if(!(x)) __debugbreak();//断言宏定义

#define GLCall(x) GLClearError();\
	x;\
	ASSERT(GLCheckError(#x,__FILE__,__LINE__));
//#x是一个字符串常量，表示函数名,__FILE__是一个预定义宏，表示当前文件名，__LINE__是一个预定义宏，表示当前行号

void GLClearError();
bool GLCheckError(const char* function, const char* file, int line);


//Renderer.cpp
#include "Renderer.h"
#include <iostream>
void GLClearError()
{
	while (glGetError() != GL_NO_ERROR);//一直到没有错误为止
}

bool GLCheckError(const char* function, const char* file, int line)
{
	while (GLenum error = glGetError())
	{
		std::cout << "[OpenGL Error] (" << error << "): " << function << " " << file << ":line" << line << std::endl;
		return false;
	}
	return true;
}
```

在之前的代码中删除相关代码，并include Renderer.h，就可以正常运行了
## 二、VertexBuffer

```cpp
//VertexBuffer.h
#pragma once

class VertexBuffer
{
private:
	unsigned int m_RendererID;
public:
	VertexBuffer(const void* data, unsigned int size);
	~VertexBuffer();

	void Bind() const;
	void Unbind() const;
};



//VertexBuffer.cpp
#include "VertexBuffer.h"
#include "Renderer.h"

VertexBuffer::VertexBuffer(const void* data, unsigned int size)
{
	GLCall(glGenBuffers(1, &m_RendererID));
	GLCall(glBindBuffer(GL_ARRAY_BUFFER, m_RendererID));
	GLCall(glBufferData(GL_ARRAY_BUFFER, size, data, GL_STATIC_DRAW));
}

VertexBuffer::~VertexBuffer()
{
	GLCall(glDeleteBuffers(1, &m_RendererID));//parameters: number of buffers, buffer id
}

void VertexBuffer::Bind() const
{
	GLCall(glBindBuffer(GL_ARRAY_BUFFER, m_RendererID));
}

void VertexBuffer::Unbind() const
{
	GLCall(glBindBuffer(GL_ARRAY_BUFFER, 0));
}

```

## 三、IndexBuffer

```cpp
//IndexBuffer.h
#pragma once

class IndexBuffer
{
private:
	unsigned int m_RendererID;
	unsigned int m_Count;
public:
	IndexBuffer(const unsigned int* data, unsigned int count);
	~IndexBuffer();

	void Bind() const;
	void Unbind() const;

	inline unsigned int GetCount() const { return m_Count; }
};



//IndexBuffer.cpp
#include "IndexBuffer.h"
#include "Renderer.h"

IndexBuffer::IndexBuffer(const unsigned int* data, unsigned int count)
	:m_Count(count)
{
	ASSERT(sizeof(unsigned int) == sizeof(GLuint));//下边的BufferData假设unsigned int和GLuint是一样的

	GLCall(glGenBuffers(1, &m_RendererID));
	GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_RendererID));
	GLCall(glBufferData(GL_ELEMENT_ARRAY_BUFFER, count * sizeof(unsigned int), data, GL_STATIC_DRAW));
}

IndexBuffer::~IndexBuffer()
{
}

void IndexBuffer::Bind() const
{
	GLCall(glBindBuffer(GL_ARRAY_BUFFER, m_RendererID));
}

void IndexBuffer::Unbind() const
{
	GLCall(glBindBuffer(GL_ARRAY_BUFFER, 0));
}

```


## 四、使用抽象后的Class
回到绘制的cpp中，首先include上边三个头文件，接下来删除main中的相关gl函数，改为下边的样子：

```cpp
//VAO
unsigned int vao;
glGenVertexArrays(1, &vao);// 生成一个VAO对象，返回的id存储在vao中
glBindVertexArray(vao);// 绑定VAO对象到当前的OpenGL contex中

//VBO
VertexBuffer vbo(position, sizeof(position));

//EBO
IndexBuffer ibo(indices, 6);

```

运行程序，依然可以正常绘制


## 五、关于绘制的封装
对于一个复杂的模型(复杂的VertexBuffer)，一般会用过多个IndexBuffer进行绘制，因为不同部位的材质可能不同
实际上我们会把绘制封装在Renderer中，比如提供一个VBO,EBO,Material，它会查看EBO，询问count，并发出绘制调用
