### 0.回顾上节的三角形绘制
上节绘制三角形，我们可以这样总结流程：
- 创建VertexBuffer，并将其bind到GL_ARRAY_BUFFER上，并通过gl_BUfferr_Data将顶点位置传入
- 通glVertexAttributePointer告诉OpenGL VertexBuffer的数据组织方式
- 在RenderLoop中是使用glDrawArrays绘制三角形

这时我们需要思考：当我们要绘制一个正方形时，改如何绘制？
如果以上边的思路绘制的话，应该是这样的：
- 以同样的方式绘制两个三角形
- 使用6个顶点

```cpp
float position[] =
{
	-0.5f,-0.5f,
	 0.5f,-0.5f,
	 0.5f, 0.5f,

	0.5f, 0.5f,
	-0.5f, 0.5f,
	-0.5f,-0.5f

};
glBufferData(GL_ARRAY_BUFFER, sizeof(position), position, GL_STATIC_DRAW);


glDrawArrays(GL_TRIANGLES, 0, 6);
```

那么问题来了，正方形有四个点，我们却用了6个顶点，并且有两个位置完全相同的顶点，这意味这内存中存着两个完全相同的数据，所以这不是我们想要的

### 1.引入IndexBuffer
我们不妨换个思路：**只存唯一存顶点，并给它们一个index，绘制的时候按照绘制的顺序传入index**
![172x177](assets/8.IndexBuffer（EBO）_image_1.png)
这当然可行
```cpp
float position[] =
	{
		-0.5f,-0.5f,
		 0.5f,-0.5f,
		 0.5f, 0.5f,
		-0.5f, 0.5f
	};

//创建索引缓冲区
unsigned int indices[] =
{
	0,1,2,
	2,3,0
};

```

### 2.使用IndexBuffer绘制正方形

```cpp

unsigned int ibo;// index buffer object id，LearnOpenGL中称为EBO：Element Buffer Object
glGenBuffers(1, &ibo);// 生成ibo object
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);// 绑定iboObject到GL_ELEMENT_ARRAY_BUFFER目标上
glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);// 把数据传入到ibo对象中


RenderLoop
{
    glDrawElements(GL_TRIANGLES,6,GL_UNSIGNED_INT,ntllptr);
    //paramters: draw mode, number of vertices, index type, index buffer
    //nullptr表示使用当前绑定的索引缓冲区，因为我们已经绑定了ibo对象到GL_ELEMENT_ARRAY_BUFFER目标上
}


```
