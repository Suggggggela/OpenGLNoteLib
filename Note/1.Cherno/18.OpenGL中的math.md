
## 一、关于图形学中的数学
我们大部分打交道的是向量和矩阵
这里不展开讲了，因为实在是太繁琐，希望你已经在其他地方了解，比如GAMES101


## 二、数学库：glm
https://github.com/g-truc/glm
我们将glm作为数学库进行使用
我们将glm文件夹include到项目中，即可使用

## 三、例：应用正交矩阵
当前我们仅仅是渲染了2D的一个logo，所以这里我们先考虑2D情况
我们将渲染的顶点乘以一个正交矩阵，就是把他转换到一个2D窗口，来解决顶点定位问题

```cpp
#include"glm/glm.hpp"
#include"glm/gtc/matrix_transform.hpp"

//在设置Uniform之前编写一个正交投影矩阵
//Ortho
glm::mat4 projection = glm::ortho(-2.0f, 2.0f, -1.5f, 1.5f, -1.0f, 1.0f);
//这个矩阵的意义是：将坐标系的范围设置为[-2,2]和[-1.5,1.5]，z轴的范围是[-1,1]，这个矩阵是一个正交投影矩阵
```
为了设置这个矩阵，我们需要在shadercpp中添加设置矩阵数据类型的SetUniform函数

```cpp
//shader.h
#include"glm/glm.hpp"
void SetUniformMat4f(const std::string& name, const glm::mat4& matrix);

//shader.cpp
void Shader::SetUniformMat4f(const std::string& name, const glm::mat4& matrix)
{
	GLCall(glUniformMatrix4fv(GetUniformLocation(name), 1, GL_FALSE, &natrix[0][0]));
	//glUniformMatrix4fv函数用于设置4x4矩阵的uniform变量
	//parameter  0: location,表示uniform变量的地址，这里我们使用GetUniformLocation函数获取uniform变量的地址
	//parameter 1: count,表示矩阵的数量，这里我们只传递一个矩阵，所以设置为1
	//parameter 2: transpose,表示是否转置矩阵，这里我们不需要转置，所以设置为GL_FALSE
	//parameter 3: value,表示矩阵的地址，这里我们传递矩阵的首地址
}
```

shader中，我们将这个矩阵应用到顶点
```hlsl
#shader vertex
#version 330 core
layout(location=0) in vec4 position;
layout(location=1) in vec2 texCoord;
out vec2 v_TexCoord;
uniform mat4 u_MVP; //现在我们只是简单的写了P = Projection
void main()
{
	gl_Position = u_MVP * position;//注意：矩阵需要左乘
	v_TexCoord = texCoord;
};
```
