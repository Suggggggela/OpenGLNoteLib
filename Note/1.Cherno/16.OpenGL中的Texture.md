
## 一、如何在OpenGL使用textures
通过一个路径加载纹理，通过image库的方法获取一个指向RGBA像素缓冲区的指针，接下来将像素数组传给GPU，GPU的fragmentshader中使用纹理

## 二、使用Texture
### 1.stb image库
https://github.com/nothings/stb/blob/master/stb_image.h
从上边的链接复制std image库的头文件，头文件有使用说明，我们按照它创建imagecpp文件
```cpp
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"
```

### 2.Texture Class

```cpp
//Texture.h
#pragma once

#include"Renderer.h"

class Texture
{
private:
	unsigned int m_RendererID;
	std::string m_FilePath;
	unsigned char* m_LocalBuffer;//纹理数据
	int m_Width, m_Height, m_BPP;//宽高和每个像素的字节数
public:
	Texture(const std::string& path);
	~Texture();

	void Bind(unsigned int slot = 0) const; //参数slot表示绑定到的纹理单元,默认为插槽0，根据不同的平台，插槽数量会不同
	void Unbind() const;

	inline int GetWidth() const { return m_Width; }
	inline int GetHeight() const { return m_Height; }
};

```


```cpp
//Texture.cpp
#include "Texture.h"
#include "vendor\stb_image.h"

Texture::Texture(const std::string& path)
	: m_RendererID(0), m_FilePath(path), m_LocalBuffer(nullptr), m_Width(0), m_Height(0), m_BPP(0)
{
	stbi_set_flip_vertically_on_load(1);//翻转纹理,OpenGL默认纹理坐标系是左下角为原点，stb_image的坐标系是左上角为原点
	m_LocalBuffer = stbi_load(path.c_str(), &m_Width, &m_Height, &m_BPP, 4);//加载纹理数据，4表示每个像素4个通道

	GLCall(glGenTextures(1, &m_RendererID));//param1表示生成纹理的数量，param2表示生成的纹理ID
	GLCall(glBindTexture(GL_TEXTURE_2D, m_RendererID));//绑定纹理，param1表示纹理类型，param2表示纹理ID
	
	//设置纹理参数
	GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR));
	GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR));
	GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,GL_CLAMP_TO_EDGE));
	GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,GL_CLAMP_TO_EDGE));

	//上传纹理数据
	GLCall(glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, m_Width, m_Height, 0, GL_RGBA, GL_UNSIGNED_BYTE, m_LocalBuffer));
	//Param1表示纹理类型，param2表示纹理级别，param3表示纹理格式，param4和param5表示纹理宽高，param6表示纹理边框宽度，param7表示纹理格式，param8表示数据类型，param9表示纹理数据
	GLCall(glBindTexture(GL_TEXTURE_2D, 0));//解绑纹理

	if (m_LocalBuffer)
	{
		stbi_image_free(m_LocalBuffer);//释放纹理数据
	}
}

Texture::~Texture()
{
	GLCall(glDeleteTextures(1, &m_RendererID));//删除纹理
}

void Texture::Bind(unsigned int slot) const
{
	GLCall(glActiveTexture(GL_TEXTURE0 + slot));//激活纹理单元，param表示纹理单元的索引
	GLCall(glBindTexture(GL_TEXTURE_2D, m_RendererID));
}

void Texture::Unbind() const
{
	GLCall(glBindTexture(GL_TEXTURE_2D, 0));//解绑纹理
}



```


### 3.shader中添加采样器槽位的Uniform变量

```cpp
//h
void SetUniform1i(const std::string& name, int value);

//cpp
void Shader::SetUniform1i(const std::string& name, int value)
{
	GLCall(glUniform1i(GetUniformLocation(name), value));
}
```

### 4.纹理坐标
因为采样纹理时需要uv
我们构造了一个长方形，可以将这个长方形映射到（0,1）的坐标系中
这里我们直接将uv存在了positions中
![261x259](assets/16.OpenGL中的Texture_image_1.png)
- （-0.5，-0.5）这个点对应uv的（0,0）
- （0.5，0.5）这个点对应uv的（1,1）
- （-0.5，0.5）这个点对应uv的（0,1）
- （0.5，-0.5）这个点对应uv的（1,0）
```cpp
//position
-0.5f,-0.5f,0.0f,0.0f,
 0.5f,-0.5f,1.0f,0.0f,
 0.5f, 0.5f,1.0f,1.0f,
-0.5f, 0.5f,0.0f,1.0f
```
对于后边对VertexBuffer的布局解释，我们将刚刚添加的uv加进去
```cpp
VertexBuffer vbo(positions, sizeof(positions));//如果直接sizeof不用修改，手动计算记得加上uv
layout.Push<float>(2);//push 2个float到布局的元素中,positon
layout.Push<float>(2);//push 2个float到布局的元素中,uv
```

### 5.Shader
接下来修改shader，使用纹理代替颜色输出到像素

```cpp
#shader vertex
#version 330 core
layout(location=0) in vec4 position;
layout(location=1) in vec2 texCoord;
out vec2 v_TexCoord;
void main()
{
	gl_Position = position;
	v_TexCoord = texCoord;
};

#shader fragment
#version 330 core
out vec4 color;
in vec2 v_TexCoord;
uniform vec4 u_Color;
uniform sample2D u_Texture;
void main()
{
	vec4 texColor = texture(u_Texture,v_TexCoord);
	color = texColor;
};
```


### 6.主程序中应用

```cpp
//Texture
//Texture
Texture texture("res/textures/OpenGLTexture.png");
texture.Bind();//默认bind到0号TextureUnit，也可以指定
shader.SetUniform1i("u_Texture", 0);//设置纹理单元为0,这里使用0号纹理单元，和上面绑定的纹理单元一致
```
![16.OpenGL中的Texture_image_2](assets/16.OpenGL中的Texture_image_2.png)

