上节的简单shader使用中，我们使用char编写了shader的源代码，形式实在是太糟糕了
这不是不可行，但你知道这不是一个长期可行的方式

所以这节我们来讲讲如何在OpenGL处理shader源代码

### 1.创建文件夹单独存放shader
在src的同级目录中创建res、shaders文件夹，并创建一个basic.shader的文件
```
#shader vertex
#version 330 core
layout(location=0) in vec4 position;
void main()
{
	gl_Position = position;
};

#shader fragment
#version 330 core
out vec4 color;
void main()
{
	color = vec4(0.5, 0.0, 0.0, 1.0);
};

```

### 2.处理shader文件

```cpp
#include <fstream>
#include <sstream>
#include <string>
//记得添加加载shader所需的头文件

//使用结构体存放ParseShader函数的返回值
struct ShaderProgramSource
{
	std::string VertexSource;
	std::string FragmentSource;
};

static ShaderProgramSource ParseShader(const std::string& filepath)
{
	//stream的意思是流
	//流是一个抽象的概念，表示数据的输入和输出
	//流可以是文件流、内存流、网络流等。这里我们使用ifstream类来创建一个文件输入流对象，用于读取文件内容

	std::ifstream stream(filepath);//这行代码打开了一个文件流，文件名为filepath

	enum class ShaderType
	{
		NONE = -1, VERTEX = 0, FRAGMENT = 1 
		//这里将vertex和Fragment分别设置为0和1，方便后边将源代码中的非标记行添加到对应的stringstream中
	};

	//读取文件内容，逐行检查
	std::string line;//用于存储每一行的内容
	std::stringstream ss[2];//用于存储顶点着色器和片段着色器的源代码
	ShaderType shaderType = ShaderType::NONE;//枚举变量shaderType，用于表示当前读取的着色器类型

	while (getline(stream,line))
	{
		if (line.find("shader") != std::string::npos) //查找有#shader关键字的那两行
		{

			if (line.find("vertex") != std::string::npos)//npos=没有找到
			{
				shaderType = ShaderType::VERTEX;
			}
			else if (line.find("fragment") != std::string::npos)
			{
				shaderType = ShaderType::FRAGMENT;
			}
		}
		else//其他行，shader 源代码
		{
			ss[(int)shaderType] << line << "\n";//当前行的内容添加到对应的stringstream中
		}
	}

	return { ss[0].str(), ss[1].str() };
	//返回一个ShaderProgramSource对象，包含顶点着色器和片段着色器的源代码
}
```

### 3.Attach Shader Source 

```cpp
//这里使用的是相对路径，设置在property中的Debugging中的Working Directory
//默认为Project的根目录
//打印出切分后的vs和fs用于Debug
ShaderProgramSource source = ParseShader("res/shaders/Basic.shader");
std::cout << "vertex source: " << std::endl << source.VertexSource << std::endl;
std::cout << "fragment source: " << std::endl << source.FragmentSource << std::endl;
unsigned int shader = CreateShader(source.VertexSource,source.FragmentSource);
glUseProgram(shader);

```


### 4.删除Program
在RenderLoop（while循环）结束后，使用glDeleteProgram将shaderProgram删除

```cpp
/* Loop until the user closes the window */
while (!glfwWindowShouldClose(window))
{
    //xxxxxx
}
glDeleteProgram(shader);
```
