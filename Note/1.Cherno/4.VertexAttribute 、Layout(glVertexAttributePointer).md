
## 0、回顾OpenGL的工作原理
OpenGL的工作原理：
- 向GPU提供数据，GPU存储着绘制需要的所有数据
- GPU通过shader读取这些数据，并根据shader做相关操作

通常，GPU绘制需要一个叫做VertexBuffer的东西，它基本上是GPU上的一段内存，里边存着上边说的绘制需要的数据。当GPU通过shader读取VertexBuffer的数据时，需要知道**这些数据是如何组织的（内存中都有什么？如何布局的？）**，这就是Layout

## 一、VertexAttribute-顶点属性
首先我们需要明白，顶点并不是vertexposition，**顶点是包含着一些信息的集合**，position只是信息中的一种

## 二、Layout-布局/数据组织方式
### glVertexAttributePointer
https://docs.gl/gl4/glVertexAttribPointer
**glVertexAttributePointer**是我们告诉OpenGL Layout的函数
参数如下：
- **index** 要修改的通用顶点索引（shader通过index系统读取信息，你甚至可以将它理解为一个枚举。比如：0=position，1=uv，2=normal，3=vertexcolor）
- **size** 通用顶点属性的数量（下个参数的size，比如二维顶点：下个参数type为GL_FLOAT，这个参数size为2）
- **type** 为VertexAttribute指定数据类型
- **normalized** 是否归一化为0~1（比如：颜色为0~255，需要归一化）
- **stride** 步长，连续VertexAttribute之间的字节偏移量。是指每个顶点之间的字节数（其实就是每个顶点属性的总字节数，比如：float3 position、float2 uv，float3 normal 那么stride = （3 + 2 + 3）x 4 = 32byte
- **pointer**，指定当前与 GL_ARRAY_BUFFER 目标绑定的缓冲区数据存储中的数组中第一个通用顶点属性的第一个分量的偏移

pointer的这个描述实在是令人困惑，实际上它是指：当前顶点属性开头离数组开头的偏移量。
拿上边stride的例子为例：
        - 如果是position，那么偏移量=0，因为它位于数组开头
        - 如果是uv，那么偏移量 = 3(float) x 4(byte) = 12，也就是说，从12开始就是uv的起点
//另外：对于stride 和 pointer，使用箭头操作符计算相对字节偏移会更好
```cpp
glEnableVertexAttribArray(0);// 启用顶点属性数组，0表示VertexBuffer的第一个属性
glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0);
// 0表示VertexBuffer的第一个属性
// 2表示这个属性的分量数,这里positions有3个顶点，每个顶点有2个分量,x和y坐标，
// GL_FLOAT表示数据类型是float
// GL_FALSE表示不需要归一化
// sizeof(float) * 2表示每个顶点占用的字节数
// 0表示数据在buffer中的偏移量
```



总代码

```cpp
#include <GL\glew.h>
#include "GLFW\glfw3.h"
#include <iostream>

int main(void)
{
	GLFWwindow* window;

	/* Initialize the library */
	if (!glfwInit())
		return -1;

	/* Create a windowed mode window and its OpenGL context */
	window = glfwCreateWindow(640, 480, "Hello World", NULL, NULL);
	if (!window)
	{
		glfwTerminate();
		return -1;
	}

	/* Make the window's context current */
	glfwMakeContextCurrent(window);
	
	float position[6] = 
	{
		-0.5f,-0.5f,
		 0.0f,0.5f,
		 0.5f,-0.5f
	};

	//Using glew
	if (glewInit() != GLEW_OK)
	{
		std::cout << "Error" << std::endl;
	}
	std::cout << glGetString(GL_VERSION) << std::endl;

	unsigned int buffer;// buffer id，任何OpenGL对象都可以用一个id来表示
	glGenBuffers(1, &buffer);// 生成一个buffer对象，返回的id存储在buffer中
	glBindBuffer(GL_ARRAY_BUFFER, buffer);// 绑定一个buffer对象到GL_ARRAY_BUFFER目标上
	glBufferData(GL_ARRAY_BUFFER, sizeof(position), position, GL_STATIC_DRAW);// 把数据传入到buffer对象中

	glEnableVertexAttribArray(0);// 启用顶点属性数组，0表示第一个属性
	glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0);
	//0表示第一个属性
	// 2表示每个顶点有两个分量
	// GL_FLOAT表示数据类型是float
	// GL_FALSE表示不需要归一化
	// sizeof(float) * 2表示每个顶点占用的字节数
	// 0表示数据在buffer中的偏移量
	glBindBuffer(GL_ARRAY_BUFFER, 0);// 解绑buffer对象

	/* Loop until the user closes the window */
	while (!glfwWindowShouldClose(window))
	{
		/* Render here */
		glClear(GL_COLOR_BUFFER_BIT);

		//use glew draw triangle
		glDrawArrays(GL_TRIANGLES, 0, 3);//paramters: draw mode, start index, number of vertices
		//glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_INT, 0);
		//和索引缓冲区结合使用
		// parameters: draw mode, number of vertices, index type, index buffer


		/* Swap front and back buffers */
		glfwSwapBuffers(window);

		/* Poll for and process events */
		glfwPollEvents();
	}

	glfwTerminate();
	return 0;
}

```
