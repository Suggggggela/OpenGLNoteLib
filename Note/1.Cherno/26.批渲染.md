
## 一、方法1：直接将批数据存在顶点属性中

这种方法实际上就是把多个渲染目标的数据存在一套数据中的做法，和单个渲染在本质上没有区别

比如：我们想绘制两个正方形，只需要将两个正方形需要的数据都存起来，进行一次绘制即可

### 静态批渲染
#### --使用两个独立pass绘制--
```cpp
#include "SandboxLayer.h"

#define STB_IMAGE_IMPLEMENTATION
#include <stb_image\stb_image.h>

using namespace GLCore;
using namespace GLCore::Utils;

SandboxLayer::SandboxLayer()
	: m_CameraController(16.0f / 9.0f)
{
}

SandboxLayer::~SandboxLayer()
{
}

static GLuint LoadTexture(const std::string& path)
{
	int w, h, bits;

	stbi_set_flip_vertically_on_load(1);
	auto* pixels = stbi_load(path.c_str(), &w, &h, &bits, STBI_rgb);
	GLuint textureID;
	glCreateTextures(GL_TEXTURE_2D, 1, &textureID);
	glBindTexture(GL_TEXTURE_2D, textureID);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB8, w, h, 0, GL_RGB, GL_UNSIGNED_BYTE, pixels);

	stbi_image_free(pixels);

	return textureID;
}

void SandboxLayer::OnAttach()
{
	EnableGLDebugging();

	m_Shader = std::unique_ptr<Shader>(Shader::FromGLSLTextFiles(
		"assets/shader.glsl.vert",
		"assets/shader.glsl.frag"
	));

	glClearColor(0.1f, 0.1f, 0.1f, 1.0f);

	float vertices[] = {
		-0.5f, -0.5f, 0.0f,
		 0.5f, -0.5f, 0.0f,
		 0.5f,  0.5f, 0.0f,
		-0.5f,  0.5f, 0.0f
	};

	glCreateVertexArrays(1, &m_QuadVA);
	glBindVertexArray(m_QuadVA);

	glCreateBuffers(1, &m_QuadVB);
	glBindBuffer(GL_ARRAY_BUFFER, m_QuadVB);
	glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

	glEnableVertexArrayAttrib(m_QuadVB, 0);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), 0);

	uint32_t indices[] = {
		0, 1, 2,
		2, 3, 0
	};

	glCreateBuffers(1, &m_QuadIB);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_QuadIB);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
}

void SandboxLayer::OnDetach()
{
	// Shutdown here
}

void SandboxLayer::OnEvent(Event& event)
{
	// Events here
	//CameraController
	m_CameraController.OnEvent(event);
}

static void SetUniformMat4(uint32_t shader, const char* name, const glm::mat4& matrix)
{
	int loc = glGetUniformLocation(shader, name);
	glUniformMatrix4fv(loc, 1, GL_FALSE, glm::value_ptr(matrix));
}

void SandboxLayer::OnUpdate(Timestep ts)
{
	// Render here
	m_CameraController.OnUpdate(ts);

	glClear(GL_COLOR_BUFFER_BIT);

	glUseProgram(m_Shader->GetRendererID());

	auto vp = m_CameraController.GetCamera().GetViewProjectionMatrix();
	SetUniformMat4(m_Shader->GetRendererID(), "u_ViewProj", vp);
	SetUniformMat4(m_Shader->GetRendererID(), "u_Transform", glm::translate(glm::mat4(1.0f), glm::vec3(-1.0f,0.0f,0.0f)));

	glBindVertexArray(m_QuadVA);
	glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr);

	SetUniformMat4(m_Shader->GetRendererID(), "u_Transform", glm::translate(glm::mat4(1.0f), glm::vec3(1.0f,0.0f,0.0f)));
	glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr);
}

void SandboxLayer::OnImGuiRender()
{
	// ImGui here
}

```


#### --合成1个pass绘制--

将两个Quad的数据填入一个vertices
```cpp
float vertices[] = {
	-1.5f, -0.5f, 0.0f,
	-0.5f, -0.5f, 0.0f,
	-0.5f,  0.5f, 0.0f,
	-1.5f,  0.5f, 0.0f，

	 0.5f, -0.5f, 0.0f,
	 1.5f, -0.5f, 0.0f,
	 1.5f,  0.5f, 0.0f,
	 0.5f,  0.5f, 0.0f
};
```

扩展index buffer
```cpp
uint32_t indices[] = {
	0, 1, 2,2, 3, 0,
	4, 5, 6, 6, 7,4
};
```

将transform归零，修改DrawElements的size
```cpp
glUseProgram(m_Shader->GetRendererID());

auto vp = m_CameraController.GetCamera().GetViewProjectionMatrix();
SetUniformMat4(m_Shader->GetRendererID(), "u_ViewProj", vp);
SetUniformMat4(m_Shader->GetRendererID(), "u_Transform", glm::translate(glm::mat4(1.0f), glm::vec3(0.0f,0.0f,0.0f)));

glBindVertexArray(m_QuadVA);
glDrawElements(GL_TRIANGLES, 12, GL_UNSIGNED_INT, nullptr);
```


### 批渲染-颜色
对于方法1，我们只调用一次DrawElement
在出现批量渲染，并且需要批量颜色的情况下，我们不能进行多次uniform4f的set操作

对于颜色，我们可以使用顶点色解决，既将需要绘制的颜色存在顶点色中
不过这个方式本质上还是使用顶点属性进行绘制
#### 1.扩充顶点数据
```cpp
	float vertices[] = {
    	//positon           vertexcolor
		-1.5f, -0.5f, 0.0f, 0.18f, 0.6f, 0.96f, 1.0f,
		-0.5f, -0.5f, 0.0f, 0.18f, 0.6f, 0.96f, 1.0f,
		-0.5f,  0.5f, 0.0f, 0.18f, 0.6f, 0.96f, 1.0f,
		-1.5f,  0.5f, 0.0f, 0.18f, 0.6f, 0.96f, 1.0f,
						    
		 0.5f, -0.5f, 0.0f, 1.0f, 0.93f, 0.24f, 1.0f,
		 1.5f, -0.5f, 0.0f, 1.0f, 0.93f, 0.24f, 1.0f,
		 1.5f,  0.5f, 0.0f, 1.0f, 0.93f, 0.24f, 1.0f,
		 0.5f,  0.5f, 0.0f, 1.0f, 0.93f, 0.24f, 1.0f
	};

```

#### 2.修改VertexBufferLayout
```cpp
//VertexBufferLayout
//Positon
glEnableVertexArrayAttrib(m_QuadVB, 0);
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 7 * sizeof(float), 0); //7=stirde
//Color
glEnableVertexArrayAttrib(m_QuadVB, 1);
glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, 7 * sizeof(float), (void*)12); //12=offset=3*float=12bytes
```

#### 3.Shader应用

```cpp
//#注意代码只有关键部分

//Vertex
layout (location = 1) in vec4 a_Color;
out vec4 v_Color;
void main()
{
	v_Color = a_Color;
}

//frag
in vec4 v_Color;
void main()
{
    o_Color = v_Color;
}
```


### 批渲染-纹理
对于纹理，我们并不能将它直接放在顶点属性中，那么该如何解决呢？
    -我们可以给顶点缓冲区的每个Object分配ID，然后通过ID绑定相应的纹理（GPU插槽支持绑定多个纹理，插槽数根据GPU有不同）
大体思路如下：
- 顶点属性中加入纹理相关的数据：uv，id
- 加载多个纹理
- 通过glBindTexture(Index，texture)绑定对应纹理
- 采样

#### 1.扩充顶点数据
```cpp
float vertices[] = {
	//positon            vertexcolor                TexCoord     TexIndex
	-1.5f, -0.5f, 0.0f,  0.18f, 0.6f, 0.96f, 1.0f,  0.0f, 0.0f,  0.0f,
	-0.5f, -0.5f, 0.0f,  0.18f, 0.6f, 0.96f, 1.0f,  1.0f, 0.0f,  0.0f,
	-0.5f,  0.5f, 0.0f,  0.18f, 0.6f, 0.96f, 1.0f,  1.0f, 1.0f,  0.0f,
	-1.5f,  0.5f, 0.0f,  0.18f, 0.6f, 0.96f, 1.0f,  0.0f, 1.0f,  0.0f,
					     
	 0.5f, -0.5f, 0.0f,  1.0f, 0.93f, 0.24f, 1.0f,  0.0f, 0.0f,  1.0f,
	 1.5f, -0.5f, 0.0f,  1.0f, 0.93f, 0.24f, 1.0f,	1.0f, 0.0f,  1.0f,
	 1.5f,  0.5f, 0.0f,  1.0f, 0.93f, 0.24f, 1.0f,	1.0f, 1.0f,  1.0f,
	 0.5f,  0.5f, 0.0f,  1.0f, 0.93f, 0.24f, 1.0f,	0.0f, 1.0f,  1.0f
};
```

#### 2.加载纹理
   添加加载Texture的函数
```cpp
//记得加头文件
#define STB_IMAGE_IMPLEMENTATION
#include <stb_image\stb_image.h>


static GLuint LoadTexture(const std::string& path)
{
	int w, h, bits;

	stbi_set_flip_vertically_on_load(1);
	auto* pixels = stbi_load(path.c_str(), &w, &h, &bits, STBI_rgb);
	GLuint textureID;
	glCreateTextures(GL_TEXTURE_2D, 1, &textureID);
	glBindTexture(GL_TEXTURE_2D, textureID);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB8, w, h, 0, GL_RGB, GL_UNSIGNED_BYTE, pixels);

	stbi_image_free(pixels);

	return textureID;
}
```

加载Texture
```cpp
//头文件中添加成员：
GLuint m_ChernoTex, m_HazelTex; 

//Cpp文件的OnAttach：
//VertexBufferLayout
....
//LoadTexture
m_ChernoTex = LoadTexture("assets/Cherno.png");
m_HazelTex = LoadTexture("assets/Hazel.png");
```

再渲染前BindTexture
```cpp
//OnUpdate
...
glUseProgram(m_Shader->GetRendererID());
//BindTextureBefroeRendering
glBindTextureUnit(0, m_ChernoTex);
glBindTextureUnit(1, m_HazelTex);
```
#### 3.修改BufferLayout
```cpp
//VertexBufferLayout
//Positon、Color
......
//TexCoord
glEnableVertexArrayAttrib(m_QuadVB, 2);
glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 9 * sizeof(float), (void*)28); //28 = (3+4)float = 28bytes
//TexIndex
glEnableVertexArrayAttrib(m_QuadVB, 3);
glVertexAttribPointer(3, 1, GL_FLOAT, GL_FALSE, 10 * sizeof(float), (void*)36); //(3+4+2)float = 36bytes
```

#### 4.采样纹理

设置TextureUniform
```cpp
//OnAttach
m_Shader = std::unique_ptr<Shader>(Shader::FromGLSLTextFiles(
	"assets/shader.glsl.vert",
	"assets/shader.glsl.frag"
));

//SetTextureUniform
glUseProgram(m_Shader->GetRendererID());
auto location = glGetUniformLocation(m_Shader->GetRendererID(), "u_Textures");
int samplers[2] = { 0, 1 };
glUniform1iv(location, 2, samplers);
```

Shader中采样
vertex:
```cpp
#version 450 core

layout (location = 0) in vec3 a_Position;
layout (location = 1) in vec4 a_Color;
layout (location = 2) in vec2 a_TexCoord;
layout (location = 3) in float a_TexIndex;

uniform mat4 u_ViewProj;
uniform mat4 u_Transform;

out vec4 v_Color;
out vec2 v_TexCoord;
out float v_TexIndex;

void main()
{
	v_Color = a_Color;
	v_TexCoord = a_TexCoord;
	v_TexIndex = a_TexIndex;
	gl_Position = u_ViewProj * u_Transform * vec4(a_Position, 1.0);
}
```

frag:
```cpp
#version 450 core

layout (location = 0) out vec4 o_Color;

in vec4 v_Color;
in vec2 v_TexCoord;
in float v_TexIndex;
//uniform vec4 u_Color;
uniform sampler2D u_Textures[2];

void main()
{
	int index = int(v_TexIndex);
	//o_Color = vec4(v_TexIndex,v_TexIndex,v_TexIndex,1.0f);
	//o_Color = vec4(1,1,1,1);
	o_Color = texture(u_Textures[index],v_TexCoord);
}
```

#### 4.绘制
相比上一个颜色的例子，并没有区别，还是绘制两个Quad
我们只是扩充了顶点属性、相关Layout的布局、设置TextureUniform、Shader中采样


## 二、方法2：动态批处理

方法1的数据都是预定义好的，无法进行更新，另一种方法是流式的更新缓冲区，这也是大部分说批处理代表的做法
核心思路是：将渲染目标分组，动态的组成一个批次


### 动态VertexBuffer

#### 1.Vertex
首先将顶点属性抽象为一个struct
```cpp
struct vec2
{
	float x, y;
};
struct vec3
{
	float x, y, z;
};
struct vec4
{
	float x, y, z, w;
};
struct Vertex
{
	vec3 Position;
	vec4 Color;
	vec2 TexCoord;
	float TexIndex;
};
```
#### 2.VertexBufferLayout
接下来根据Vertex的数据结构修改Buffer布局
```cpp
//#OnAttach

//float vertices[] = {.....};
//注释掉之前写的静态vertices


glCreateVertexArrays(1, &m_QuadVA);
glBindVertexArray(m_QuadVA);

//修改Buffer布局
glCreateBuffers(1, &m_QuadVB);
glBindBuffer(GL_ARRAY_BUFFER, m_QuadVB);
glBufferData(GL_ARRAY_BUFFER, sizeof(Vertex) * 1000, nullptr, GL_DYNAMIC_DRAW);//先给空指针，然后改为Dynamic

//VertexBufferLayout
//根据Vertex数据结构修改size、offset
//Positon
glEnableVertexArrayAttrib(m_QuadVB, 0);
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (const void*)offsetof(Vertex,Position));
//Color
glEnableVertexArrayAttrib(m_QuadVB, 1);
glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (const void*)offsetof(Vertex, Color));
//TexCoord										
glEnableVertexArrayAttrib(m_QuadVB, 2);			
glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (const void*)offsetof(Vertex, TexCoord));
//TexIndex										
glEnableVertexArrayAttrib(m_QuadVB, 3);			
glVertexAttribPointer(3, 1, GL_FLOAT, GL_FALSE, sizeof(Vertex), (const void*)offsetof(Vertex, TexIndex));
```

#### 3.动态设置VertexBuffer
将之前的vertices抽象为一个方法：
```cpp
static std::array<Vertex, 4> CreateQuad(float x, float y, float textureID)
{
	float size = 1.0f;

	Vertex v0;
	v0.Position = { x, y, 0.0f };
	v0.Color = { 0.18f, 0.6f, 0.96f, 1.0f };
	v0.TexCoord = { 0.0f, 0.0f };
	v0.TexIndex = textureID;
	
	Vertex v1;
	v1.Position = { x + size, y, 0.0f };
	v1.Color = { 0.18f, 0.6f, 0.96f, 1.0f };
	v1.TexCoord = { 1.0f, 0.0f };
	v1.TexIndex = textureID;

	Vertex v2;
	v2.Position = { x + size, y + size, 0.0f };
	v2.Color = { 0.18f, 0.6f, 0.96f, 1.0f };
	v2.TexCoord = { 1.0f, 1.0f };
	v2.TexIndex = textureID;

	Vertex v3;
	v3.Position = { x, y + size, 0.0f };
	v3.Color = { 0.18f, 0.6f, 0.96f, 1.0f };
	v3.TexCoord = { 0.0f, 1.0f };
	v3.TexIndex = textureID;

	return { v0,v1,v2,v3 };
}
```

在Update中动态设置VertexBuffer
```cpp
//#OnUpdate

//DynamicVertexBuffer
// CreatQuad
auto q0 = CreateQuad(-1.5f, -0.5f, 0.0f);
auto q1 = CreateQuad(0.5f, -0.5f, 1.0f);
Vertex vertices[8];
//将创建的Quad数据复制到vertices
memcpy(vertices,				q0.data(),	q0.size() * sizeof(Vertex)); 
memcpy(vertices + q0.size(),	q1.data(),	q1.size() * sizeof(Vertex));
```


### 动态IndexBuffer
以生成5x5的棋盘格为例

首先在OnAttach中生成indices
```cpp
const size_t MaxQuadCount = 1000;
const size_t MaxVertexCount = MaxQuadCount * 4;
const size_t MaxIndexCount = MaxQuadCount * 6;

uint32_t indices[MaxIndexCount];
uint32_t offset = 0;
for (size_t i = 0; i < MaxIndexCount; i += 6) //i+=6是因为每个Quad有6个索引
{
	indices[i + 0] = 0 + offset;//第一个顶点， 0代表索引，0+offset代表顶点位置
	indices[i + 1] = 1 + offset;//第二个顶点
	indices[i + 2] = 2 + offset;//第三个顶点
	indices[i + 3] = 2 + offset;//第四个顶点
	indices[i + 4] = 3 + offset;//第五个顶点
	indices[i + 5] = 0 + offset;//第六个顶点

	offset += 4; //每个Quad有4个顶点
}
```

修改CreateQuad函数
```cpp
static Vertex* CreateQuad(Vertex* target, float x, float y, float textureID)
{
	float size = 1.0f;

	//这里target是Vertex指针，所以使用->操作符访问成员
	target->Position = { x, y, 0.0f };
	target->Color = { 0.18f, 0.6f, 0.96f, 1.0f };
	target->TexCoord = { 0.0f, 0.0f };
	target->TexIndex = textureID;
	target++;//指针移动到下一个Vertex位置，这样做的目的是依次填充一组连续的 Vertex 数据

	target->Position = { x + size, y, 0.0f };
	target->Color = { 0.18f, 0.6f, 0.96f, 1.0f };
	target->TexCoord = { 1.0f, 0.0f };
	target->TexIndex = textureID;
	target++;

	target->Position = { x + size, y + size, 0.0f };
	target->Color = { 0.18f, 0.6f, 0.96f, 1.0f };
	target->TexCoord = { 1.0f, 1.0f };
	target->TexIndex = textureID;
	target++;
	
	target->Position = { x, y + size, 0.0f };
	target->Color = { 0.18f, 0.6f, 0.96f, 1.0f };
	target->TexCoord = { 0.0f, 1.0f };
	target->TexIndex = textureID;
	target++;

	return target;
}
```

在OnUpdate中生成VertexBufferData
```cpp
uint32_t indexCount = 0;
std::array<Vertex, 1000> vertices;
Vertex* buffer = vertices.data();//获取指向数组首元素的指针，方便后续以指针方式写入数据。这里vertices.data()返回指向数组首元素的指针
//生成5x5的Quad棋盘格
for (int y = 0; y < 5; y++)
{
	for (int x = 0; x < 5; x++)
	{
		buffer = CreateQuad(buffer, x, y, (x + y) % 2);//%2是为了让TexIndex在0和1之间交替
		indexCount += 6;//每个Quad有6个Index
	}
}
buffer = CreateQuad(buffer, m_Quad0Position[0], m_Quad0Position[1], 0.0f);//创建之前可以用ImGUI控制位置的Quad
indexCount += 6;

//↑以上buffer为指向vertices数组的指针，指向了最后一个写入的位置
//当进行buffer = CreateQuad(buffer, ...)时，buffer会指向下一个Quad的起始位置
//所以不会出现数据覆盖的问题

//修改SubData
glBufferSubData(GL_ARRAY_BUFFER, 0, vertices.size() * sizeof(Vertex), vertices.data());
//这里将vertices数组的数据写入到OpenGL的缓冲区中（CPU->GPU）

//DrawElement的index数量记得修改
glDrawElements(GL_TRIANGLES, indexCount, GL_UNSIGNED_INT, nullptr);
```

