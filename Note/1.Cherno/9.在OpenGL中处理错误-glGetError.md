## 1.glGetError
glGetError的工作原理：
    每当我们调用一个OpenGL函数时，内存内部会设置一个标志，这个标志代表着一种错误类型。
    直接输出这个标志是十进制的，我们可以将它转换为十六进制跳转查找错误类型，或者直接断点进行查找
## 2.glGetError的使用

```cpp
static void GLClearError()
{
	while (glGetError() != GL_NO_ERROR);//一直到没有错误为止
}

static void GLCheckError()
{
	while (GLenum error = glGetError())
	{
		std::cout << "[OpenGL Error] (" << error << ")" << std::endl;
	}
}

```
因为这个函数返回的是一个标志，所以每次调用OpenGL函数的时候都应该先清楚错误再get错误
例如：我们需要检查检查DrawElements这个函数，把枚举的类型故意错写为INT
```cpp
GLClearError();
//glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr);
glDrawElements(GL_TRIANGLES, 6, GL_INT, nullptr);
GLCheckError();
```
编译运行之后，控制太就会一直打印`[OpenGL Error] (1280)`转换为16进制为500，我们在glew头文件中搜索0x0500
得到的结果如下：
```cpp
#define GL_INVALID_ENUM 0x0500 //无效枚举
```

## 3.断点和宏简化
#### 使用断点
我们可以在CheckError这里，检查到出错的时候使用代码添加断点：

```cpp
#define ASSERT(x) if(!(x)) __debugbreak();//断言宏定义

static bool GLCheckError()
{
	while (GLenum error = glGetError())
	{
		std::cout << "[OpenGL Error] (" << error << ")" << std::endl;
		return false;
	}
	return true;
}

GLClearError();
//glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr);
glDrawElements(GL_TRIANGLES, 6, GL_INT, nullptr);
ASSERT(GLCheckError());

//这样一来，执行到这里，glGetError返回错误标志时，就会在这行手动添加断点
```

#### 使用宏自动化ClearError
 我们可以使用写个GLCall宏，包含Clear和Check两部，并且打印出出错的文件和行数
```cpp
#define ASSERT(x) if(!(x)) __debugbreak();//断言宏定义

#define GLCall(x) GLClearError();\
	x;\
	ASSERT(GLCheckError(#x,__FILE__,__LINE__));
//#x是一个字符串常量，表示函数名,__FILE__是一个预定义宏，表示当前文件名，__LINE__是一个预定义宏，表示当前行号

static void GLClearError()
{
	while (glGetError() != GL_NO_ERROR);//一直到没有错误为止
}

static bool GLCheckError(const char* function, const char*file, int line)
{
	while (GLenum error = glGetError())
	{
		std::cout << "[OpenGL Error] (" << error << "): " << function << " " << file << ":line" << line << std::endl;
		return false;
	}
	return true;
}


GLCall(glDrawElements(GL_TRIANGLES, 6, GL_INT, nullptr));

```

这样一来，一但你在Cpp中使用OpenGL的函数，都可以提用GLCall宏包含它们