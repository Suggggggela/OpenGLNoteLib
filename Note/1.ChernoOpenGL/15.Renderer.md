
## 一、Renderer的工作内容
Renderer的工作内容正如它的名字，我们想把数据交给它，给它发出绘制命令，它就进行绘制

## 二、Renderer Class
上边学习的内容中，我们已经把GLCall这个GLError的检查放在了Rendere的头文件
回顾内容，我们已经将vao，vbo，ebo，shader统统抽象为了class，主程序中直接使用OpenGL函数的，只剩下glDrawElement和GLCall的调用
接下来我们开始完善Renderer类，以让主程序完全的模板化
### 1.Renderer
```cpp
//Renderer.h
//增加一个RendererClass包含Draw函数
#pragma once
#include <GL/glew.h>
#include "VertexArray.h"
#include "IndexBuffer.h"
#include "Shader.h"
#define ASSERT(x) if(!(x)) __debugbreak();//断言宏定义

#define GLCall(x) GLClearError();\
	x;\
	ASSERT(GLCheckError(#x,__FILE__,__LINE__));
//#x是一个字符串常量，表示函数名,__FILE__是一个预定义宏，表示当前文件名，__LINE__是一个预定义宏，表示当前行号

void GLClearError();

bool GLCheckError(const char* function, const char* file, int line);

class Renderer
{
public:
	void Draw(const VertexArray& vao, const IndexBuffer& ibo, const Shader& shader) const;
	void Clear() const;
};

```

```cpp
//Renderer.cpp
//实现Draw函数
#include "Renderer.h"
#include <iostream>
#include "VertexArray.h"
#include "IndexBuffer.h"
#include "Shader.h"
void GLClearError()
{
	while (glGetError() != GL_NO_ERROR);//一直到没有错误为止
}

bool GLCheckError(const char* function, const char* file, int line)
{
	while (GLenum error = glGetError())
	{
		std::cout << "[OpenGL Error] (" << error << "): " << function << " " << file << ":line" << line << std::endl;
		return false;
	}
	return true;
}

void Renderer::Draw(const VertexArray& vao, const IndexBuffer& ibo, const Shader& shader) const
{
	shader.Bind();
	vao.Bind();
	ibo.Bind();
	GLCall(glDrawElements(GL_TRIANGLES,ibo.GetCount(), GL_UNSIGNED_INT, nullptr));
}

void Renderer::Clear() const
{
	GLCall(glClear(GL_COLOR_BUFFER_BIT));
}


```


### 2.修复循环引用头文件问题
上述代码直接编译会出现ASSERT宏报错，这是因为出现了循环引用头文件的问题：
- VertexBufferLayout中include了Renderer.h
- Renderer.h中include了VertexArray
- VertexArray.h中include了VertexBufferLayout

我们进行如下修复：
- 删除VertexArray.h中的include，改为直接声明Class：`Class VertexBufferLayout;`
- 在VertexArray.cpp中nclude VertexBufferLayout


### 3.主程序调用绘制

```cpp
//Renderer
Renderer renderer;

while (!glfwWindowShouldClose(window))
{
	/* Render here */
	//GLCall(glClear(GL_COLOR_BUFFER_BIT));
    renderer.Clear();

	shader.Bind();
	shader.SetUniform4f("u_Color", r, 0.3f, 0.8f, 1.0f);

	renderer.Draw(vao, ibo, shader);
	//#bindVAO
	//vao.Bind();
	//ibo.Bind();
	//
	//GLCall(glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr));
}
```


### 4.如何把shader SetUniform也优化到Class中？
使用材质，后续我们会提到
材质基本上可以理解为：shader+data，这些Uniforms就是data
