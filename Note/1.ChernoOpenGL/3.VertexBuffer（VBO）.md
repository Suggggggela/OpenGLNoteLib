
## 一、渲染一个三角形需要的东西
要使用现代OpenGL渲染一个三角形，我们需要两个东西
- VertexBuffer 顶点缓冲区
- Shader 

### 1.VertexBuffer
- VertexBuffer归根结底还是一个Buffer，一个字节数组，一段内存数据
- OpenGL的内存缓冲区意味着：这段内存位于GPU中（VRAM）


### 2.Shader
上边我们说了，OpenGL的Buffer意味着这段内存是在GPU中的
但是我们知道C++代码是运行在CPU上的，那么如何告诉GPU在这段GPU的内存上怎么做呢？
这就是Shader的作用，Shader是运行在GPU上的代码

## 二、在OpenGL绘制一个三角形
首先我们要知道，OpenGL更像一个**状态机**
所以让OpenGL绘制一个三角形，并不像我们想的那样：告诉OpenGL，hi，给我画个三角形，然后传入绘制三角形的一切
实际上OpenGL已经知道绘制一个三角形需要什么了，因为这是它**状态的一部分**
具体的，可以认为是：hi，你选择这个Buffer，根据这个shader，绘制三角形

### 0.OpenGL函数文档
Cherno提供了一个非常好用的文档
https://docs.gl/
### 1.申请缓冲区

```cpp
float position[6] = 
{
	-0.5f,-0.5f
	 0.0f,0.5f,
	 0.5f,-0.5f
};
//Using glew
if (glewInit() != GLEW_OK)
{
	std::cout << "Error" << std::endl;
}
std::cout << glGetString(GL_VERSION) << std::endl;

unsigned int buffer;// buffer id，任何OpenGL对象都可以用一个id来表示
glGenBuffers(1, &buffer);// 生成一个buffer对象，返回的id存储在buffer中
```

### 2.绑定数据到buff
```cpp
glBindBuffer(GL_ARRAY_BUFFER, buffer);// 绑定一个buffer对象到GL_ARRAY_BUFFER目标上
glBufferData(GL_ARRAY_BUFFER, sizeof(position), position, GL_STATIC_DRAW);// 把数据传入到buffer对象中
```


### 3.指定OpenGL Layout（布局/数据组织方式）

```cpp
glEnableVertexAttribArray(0);// 启用顶点属性数组，0表示VertexBuffer的第一个属性
glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0);
// 0表示VertexBuffer的第一个属性
// 2表示这个属性的分量数,这里positions有3个顶点，每个顶点有2个分量,x和y坐标，
// GL_FLOAT表示数据类型是float
// GL_FALSE表示不需要归一化
// sizeof(float) * 2表示每个顶点占用的字节数
// 0表示数据在buffer中的偏移量
```

### 4.绘制
```cpp
//use glew draw triangle
glDrawArrays(GL_TRIANGLES, 0, 3);//paramters: draw mode, start index, number of vertices

glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_INT, 0);
//和索引缓冲区结合使用
// parameters: draw mode, number of vertices, index type, index buffer
```

### 总体代码

```cpp
#include <GL\glew.h>
#include "GLFW\glfw3.h"
#include <iostream>

int main(void)
{
	GLFWwindow* window;

	/* Initialize the library */
	if (!glfwInit())
		return -1;

	/* Create a windowed mode window and its OpenGL context */
	window = glfwCreateWindow(640, 480, "Hello World", NULL, NULL);
	if (!window)
	{
		glfwTerminate();
		return -1;
	}

	/* Make the window's context current */
	glfwMakeContextCurrent(window);
	
	float position[6] = 
	{
		-0.5f,-0.5f,
		 0.0f,0.5f,
		 0.5f,-0.5f
	};

	//Using glew
	if (glewInit() != GLEW_OK)
	{
		std::cout << "Error" << std::endl;
	}
	std::cout << glGetString(GL_VERSION) << std::endl;

	unsigned int buffer;// buffer id，任何OpenGL对象都可以用一个id来表示
	glGenBuffers(1, &buffer);// 生成一个buffer对象，返回的id存储在buffer中
	glBindBuffer(GL_ARRAY_BUFFER, buffer);// 绑定一个buffer对象到GL_ARRAY_BUFFER目标上
	glBufferData(GL_ARRAY_BUFFER, sizeof(position), position, GL_STATIC_DRAW);// 把数据传入到buffer对象中
	

	/* Loop until the user closes the window */
	while (!glfwWindowShouldClose(window))
	{
		/* Render here */
		glClear(GL_COLOR_BUFFER_BIT);

		//use glew draw triangle
		glDrawArrays(GL_TRIANGLES, 0, 3);//paramters: draw mode, start index, number of vertices
		
		//glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_INT, 0);
		//和索引缓冲区结合使用
		// parameters: draw mode, number of vertices, index type, index buffer

		/* Swap front and back buffers */
		glfwSwapBuffers(window);

		/* Poll for and process events */
		glfwPollEvents();
	}

	glfwTerminate();
	return 0;
}

```
