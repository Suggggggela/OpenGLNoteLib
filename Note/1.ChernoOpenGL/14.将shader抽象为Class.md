
## 一、游戏引擎的着色器系统
游戏引擎一般会自定义一种语言，最后编译为源代码来解决多平台情况

## 二、shader系统需要什么
以前边的例子为例，我们需要：
1. 传入文件or字符串，编译为shader
2. bind 和 unbind ShaderProgram
3. 设置uniform

## 三、ShaderClass

```cpp
//Shader.h
#pragma once

#include<string>
#include<unordered_map>

struct ShaderProgramSource
{
	std::string VertexSource;
	std::string FragmentSource;
};

class Shader
{
private:
	std::string m_FilePath;
	unsigned int m_RendererID;
	std::unordered_map<std::string, int> m_UniformLocationCache;//缓存uniform变量，这样就不用每次都在Get中查找了
	//unordered_map是一个哈希表，存储键值对
public:
	Shader(const std::string& filepath);
	~Shader();

	void Bind() const;
	void UnBind() const;

	//Set Uniforms
	void SetUniform4f(const std::string& name, float v0, float v1, float v2, float v3);

	ShaderProgramSource ParseShader(const std::string& filepath);
	unsigned int CompilerShader(unsigned int shaderType, const std::string& source);
	unsigned int CreateShader(const std::string& vertexShader, const std::string& fragmentShader);
	int GetUniformLocation(const std::string& name);

};

```


```cpp
//Shader.cpp
#include "Shader.h"
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>

#include "Renderer.h"

Shader::Shader(const std::string& filepath)
	:m_FilePath(filepath), m_RendererID(0)
{
	ShaderProgramSource source = ParseShader(filepath);
	m_RendererID = CreateShader(source.VertexSource, source.FragmentSource);
	//std::cout << "vertex source: " << std::endl << source.VertexSource << std::endl;
	//std::cout << "fragment source: " << std::endl << source.FragmentSource << std::endl;
}

Shader::~Shader()
{
	GLCall(glDeleteProgram(m_RendererID));
}

void Shader::Bind() const
{
	GLCall(glUseProgram(m_RendererID));
}

void Shader::UnBind() const
{
	GLCall(glUseProgram(0));
}

ShaderProgramSource Shader::ParseShader(const std::string& filepath)
{
	//stream的意思是流
	//流是一个抽象的概念，表示数据的输入和输出
	//流可以是文件流、内存流、网络流等。这里我们使用ifstream类来创建一个文件输入流对象，用于读取文件内容

	std::ifstream stream(filepath);//这行代码打开了一个文件流，文件名为filepath

	enum class ShaderType
	{
		NONE = -1, VERTEX = 0, FRAGMENT = 1
		//这里将vertex和Fragment分别设置为0和1，方便后边将源代码中的非标记行添加到对应的stringstream中
	};

	//读取文件内容，逐行检查
	std::string line;//用于存储每一行的内容
	std::stringstream ss[2];//用于存储顶点着色器和片段着色器的源代码
	ShaderType shaderType = ShaderType::NONE;//枚举变量shaderType，用于表示当前读取的着色器类型

	while (getline(stream, line))
	{
		if (line.find("shader") != std::string::npos) //查找有#shader关键字的那两行
		{

			if (line.find("vertex") != std::string::npos)//npos=没有找到
			{
				shaderType = ShaderType::VERTEX;
			}
			else if (line.find("fragment") != std::string::npos)
			{
				shaderType = ShaderType::FRAGMENT;
			}
		}
		else//其他行，shader 源代码
		{
			ss[(int)shaderType] << line << "\n";//当前行的内容添加到对应的stringstream中
		}
	}

	return { ss[0].str(), ss[1].str() };
	//返回一个ShaderProgramSource对象，包含顶点着色器和片段着色器的源代码
}

unsigned int Shader::CompilerShader(unsigned int shaderType, const std::string& source)
{
	unsigned int id = glCreateShader(shaderType);//创建一个shader对象
	const char* src = source.c_str();
	// 获取shader的源代码
	//c_str()返回一个const char*指针，指向字符


	GLCall(glShaderSource(id, 1, &src, nullptr));
	//将源代码传递给shader对象
	//id是shader对象的id
	// glShaderSource函数的第二个参数是一个int类型的指针，表示源代码的数量
	// 这里我们只传递一个源代码，所以第二个参数是1
	// glShaderSource函数的第三个参数是一个const char*类型的指针，指向源代码的首地址
	// glShaderSource函数的第四个参数是一个int类型的指针，表示源代码的长度.这里我们传递nullptr，表示源代码的长度是自动计算的


	GLCall(glCompileShader(id));// 编译shader对象

	// 检查编译错误
	int result;
	GLCall(glGetShaderiv(id, GL_COMPILE_STATUS, &result));
	if (result == GL_FALSE)
	{
		int length;
		glGetShaderiv(id, GL_INFO_LOG_LENGTH, &length);
		char* message = (char*)alloca(length * sizeof(char));
		// 分配一个长度为length的字符数组
		// alloca函数在栈上分配内存，分配的内存会在函数返回时自动释放

		GLCall(glGetShaderInfoLog(id, length, &length, message));
		std::cout << "Failed to compile" << (shaderType == GL_VERTEX_SHADER ? "vertex" : "fragment")
			<< std::endl;
		std::cout << message << std::endl;
		glDeleteShader(id);
		return 0;
	}
	return id;
}

unsigned int Shader::CreateShader(const std::string& vertexShader, const std::string& fragmentShader)
{
	unsigned int program = glCreateProgram();// 创建一个程序对象
	unsigned int vs = CompilerShader(GL_VERTEX_SHADER, vertexShader);// 创建一个顶点着色器对象
	unsigned int fs = CompilerShader(GL_FRAGMENT_SHADER, fragmentShader);// 创建一个片段着色器对象

	// 将着色器对象附加到程序对象上
	glAttachShader(program, vs);
	glAttachShader(program, fs);
	glLinkProgram(program);
	glValidateProgram(program);


	//实际上shader不用删除，这样会导致缺少debug手段
	glDeleteShader(vs);
	glDeleteShader(fs);
	return program;
}

void Shader::SetUniform4f(const std::string& name, float v0, float v1, float v2, float v3)
{
	GLCall(glUniform4f(GetUniformLocation(name), v0, v1, v2, v3));
}


 int Shader::GetUniformLocation(const std::string& name)
 {
	 if (m_UniformLocationCache.find(name) != m_UniformLocationCache.end())
	 {
		 return m_UniformLocationCache[name];//如果缓存中有这个uniform变量，就直接返回
	 }

	 GLCall(int location = glGetUniformLocation(m_RendererID, name.c_str() ));
	 if (location == -1)//这里不直接断言，是因为有些时候uniform会被剥离掉，这种情况下shader没有这个uniform，但是我们依然想要shader正常工作，所以直接返回-1
		 std::cout << "Warning: uniform '" << name << "' doesn't exist!" << std::endl;
	 
	 return location;
 }

```
