到目前为止，我们已经可以用过VertexBuffer存储顶点数据，并通过glVertexAttributePointer告诉OpenGL我们的数据是如何布局的，最后通过glDrawElement绘制一个正方形
当然上边只是简单的概括，在实际的代码中，我们不得不涉及下边的操作，比如：
- bind VertexBuffer(VBO)到GL_ARRAY_BUFFER上
- 通过glVertexAttributePointer告诉OpenGL数据的布局(注意！这个布局并没有存在VertexBuffer)
- bind EBO到GL_ELEMENT_BUFFER上


当情况边的复杂起来，比如：我们有多个对象、多个网格、多个VertexBuffer时，按照上边的做法代码会是什么样的呢？
答案是：我们需要频繁的bind、指定布局、unbind......


## 0.频繁bind和unbind

```cpp

int main(void)
{
	GLFWwindow* window;

	/* Initialize the library */
	if (!glfwInit())
		return -1;

	/* Create a windowed mode window and its OpenGL context */
	window = glfwCreateWindow(640, 480, "Hello World", NULL, NULL);
	if (!window)
	{
		glfwTerminate();
		return -1;
	}

	glfwSwapInterval(1);//设置交换间隔为1，表示每帧交换一次缓冲区，和显示器的刷新率一致

	/* Make the window's context current */
	glfwMakeContextCurrent(window);

	float position[] =
	{
		-0.5f,-0.5f,
		 0.5f,-0.5f,
		 0.5f, 0.5f,
		-0.5f, 0.5f
	};

	//创建索引缓冲区
	unsigned int indices[] =
	{
		0,1,2,
		2,3,0
	};

	//Using glew
	if (glewInit() != GLEW_OK)
	{
		std::cout << "Error" << std::endl;
	}
	std::cout << glGetString(GL_VERSION) << std::endl;

	unsigned int buffer;// buffer id，任何OpenGL对象都可以用一个id来表示
	glGenBuffers(1, &buffer);// 生成一个buffer对象，返回的id存储在buffer中
	glBindBuffer(GL_ARRAY_BUFFER, buffer);// 绑定buffer对象到GL_ARRAY_BUFFER目标上
	glBufferData(GL_ARRAY_BUFFER, sizeof(position), position, GL_STATIC_DRAW);// 把数据传入到buffer对象中

	unsigned int ibo;// index buffer object id，LearnOpenGL中称为EBO：Element Buffer Object
	glGenBuffers(1, &ibo);// 生成ibo object
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);// 绑定iboObject到GL_ELEMENT_ARRAY_BUFFER目标上
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);// 把数据传入到ibo对象中


	glEnableVertexAttribArray(0);// 启用顶点属性数组，0表示第一个属性
	glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0);
	//0表示第一个属性
	// 2表示每个顶点有两个分量
	// GL_FLOAT表示数据类型是float
	// GL_FALSE表示不需要归一化
	// sizeof(float) * 2表示每个顶点占用的字节数 
	// 0表示数据在buffer中的偏移量
	glBindBuffer(GL_ARRAY_BUFFER, 0);// 解绑buffer对象
	
	//这里使用的是相对路径，设置在property中的Debugging中的Working Directory
	//默认为Project的根目录
	//打印出切分后的vs和fs用于Debug
	ShaderProgramSource source = ParseShader("res/shaders/Basic.shader");
	std::cout << "vertex source: " << std::endl << source.VertexSource << std::endl;
	std::cout << "fragment source: " << std::endl << source.FragmentSource << std::endl;
	unsigned int shader = CreateShader(source.VertexSource,source.FragmentSource);
	glUseProgram(shader);
	

	int location = glGetUniformLocation(shader, "u_Color");
	float r = 0.0f;
	float increament = 0.05f;

	//#unbind everything
	glUseProgram(0);//解绑shader
	glBindBuffer(GL_ARRAY_BUFFER, 0);//解绑buffer对象
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);//解绑ibo对象

	/* Loop until the user closes the window */
	while (!glfwWindowShouldClose(window))
	{
		/* Render here */
		glClear(GL_COLOR_BUFFER_BIT);

		//use glew draw triangle
		
		//glDrawArrays(GL_TRIANGLES, 0, 6);//paramters: draw mode, start index, number of vertices
		//glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_INT, 0);
		//和索引缓冲区结合使用
		// parameters: draw mode, number of vertices, index type, index buffer

		//#重新bind
		glBindBuffer(GL_ARRAY_BUFFER, buffer);//bind VBO
		glEnableVertexAttribArray(0);
		glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0);
		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);//bind IBO
		glUseProgram(shader);//bind shader program


		glUniform4f(location, r, 0.3f, 0.8f, 1.0f);
		//glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr);
		GLCall(glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr));
		
		if(r>1.0f)
		{
			increament = -0.05f;
		}
		else if (r < 0.0f)
		{
			increament = 0.05f;
		}
		r += increament;

		/* Swap front and back buffers */
		glfwSwapBuffers(window);

		/* Poll for and process events */
		glfwPollEvents();
	}

	glDeleteProgram(shader);
	glfwTerminate();
	return 0;
}
```

当然这不是我们想要的结果，所以这节我们看看有没有什么好的解决方法
## 一、VertexArrayObject
### 0.兼容模式和core模式
首先我们要知道一件事情：
- 上边的绘制是使用的兼容模式，兼容模式会自动为我们创建VAO以供我们使用
- 在OpenGL中，VAO是必须的

https://www.khronos.org/opengl/wiki/Vertex_Specification#Vertex_Array_Object
![[assets/11.VertexArray（VAO）_image_1.png]]

我们可以在glfw初始化成功之后，将OpenGL设置为core模式，例如这样：
```cpp
glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);//设置OpenGL的版本号
glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);//设置OpenGL的版本号
glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);//设置OpenGL的核心模式
//这样设置之后，我们之前的代码就无法正常绘制了
```

### 1.VertexArrayObject
VAO包含我们告诉OpenGL的数据组织方式，既布局
所以引入VAO之后，我们就不需要频繁的bind和unbind上边这些东西
VAO的创建方式如下：
```cpp
//VAO
unsigned int vao;
glGenVertexArrays(1, &vao);// 生成一个VAO对象，返回的id存储在vao中
glBindVertexArray(vao);// 绑定VAO对象到当前的OpenGL contex中
//在设置为core模式之后，添加上边VAO之后，又可以正常绘制了
```

到此为止，使用VAO的绘制代码就像下边这样:
```cpp

	//VAO
	unsigned int vao;
	glGenVertexArrays(1, &vao);// 生成一个VAO对象，返回的id存储在vao中
	glBindVertexArray(vao);// 绑定VAO对象到当前的OpenGL contex中

  //VBO
	unsigned int buffer;// buffer id，任何OpenGL对象都可以用一个id来表示
	glGenBuffers(1, &buffer);// 生成一个buffer对象，返回的id存储在buffer中
	glBindBuffer(GL_ARRAY_BUFFER, buffer);// 绑定buffer对象到GL_ARRAY_BUFFER目标上
	glBufferData(GL_ARRAY_BUFFER, sizeof(position), position, GL_STATIC_DRAW);// 把数据传入到buffer对象中

  //EBO
	unsigned int ibo;// index buffer object id，LearnOpenGL中称为EBO：Element Buffer Object
	glGenBuffers(1, &ibo);// 生成ibo object
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);// 绑定iboObject到GL_ELEMENT_ARRAY_BUFFER目标上
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);// 把数据传入到ibo对象中

  //Layout
	glEnableVertexAttribArray(0);// 启用顶点属性数组，0表示第一个属性
	glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0);


	glBindBuffer(GL_ARRAY_BUFFER, 0);// 解绑buffer对象
	
	ShaderProgramSource source = ParseShader("res/shaders/Basic.shader");
	std::cout << "vertex source: " << std::endl << source.VertexSource << std::endl;
	std::cout << "fragment source: " << std::endl << source.FragmentSource << std::endl;
	unsigned int shader = CreateShader(source.VertexSource, source.FragmentSource);
	glUseProgram(shader);


	
	int location = glGetUniformLocation(shader, "u_Color");
	float r = 0.0f;
	float increament = 0.05f;

	
	//#unbindVAO这里为了演示，解绑VAO
	glBindVertexArray(0);

	/* Loop until the user closes the window */
	while (!glfwWindowShouldClose(window))
	{
		/* Render here */
		glClear(GL_COLOR_BUFFER_BIT);

		//use glew draw triangle

		//#bindVAO,为了演示，我们只需要bindVAO就可以进行绘制，不用像之前那样繁琐的bind
		glBindVertexArray(vao);//bind VAO

		glUniform4f(location, r, 0.3f, 0.8f, 1.0f);
		
		GLCall(glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr));

		if (r > 1.0f)
		{
			increament = -0.05f;
		}
		else if (r < 0.0f)
		{
			increament = 0.05f;
		}
		r += increament;

```


### 2.使用VAO时解绑IndexBuffer(EBO)的注意事项
上边的例子中，我们直接解绑VAO，在RenderLoop中直接重新绑定VAO就可以正常绘制了

为了演示，我们不直接解绑VAO，而是像刚开始那样，unbind所有东西
```cpp
//#unbind everything
glUseProgram(0);//解绑shader
glBindBuffer(GL_ARRAY_BUFFER, 0);//解绑buffer对象
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);//解绑ibo对象
```

这时如果直接在RenderLoop中bindVAO，运行程序，你会发现无法正常绘制了
```cpp
//#bindVAO
glBindVertexArray(vao);//bind VAO
GLCall(glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr));
```
这是因为：
    **VAO中包含IndexBuffer(EBO)的bind状态**
    当你显示的单独解绑EBO，那么VAO中存的EBO状态也是解绑的。
    所以向上边这样，手动解绑VBO和EBO，再直接绑定VAO，这个时候的EBO是解绑状态


### 3.总结：VAO中包含什么？
一个VAO中存着以下数据：
- Calls to `glenable/DisableVertexAttribArray` 
	对enable/disableVertexAttributeArray函数的调用
	
- vertex attribute configurations(by `glVertexAttribPointer`)
通过glVertexAttributePoint设置顶点属性的配置

- vertex buffer objects associated with vertex attributes （by calls to `glVertexAttribPointer`）
    	通过调用glVertexAttributePointer告诉OpenGL的数据组织方式(布局)

## 二、实际中：全局VAO 还是 VAOs？
全局VAO指只有一个VAO，在使用时不断地改变它的布局
VAOs指创建多个VAO，每个VAO有不同的布局

这个问题不太好回答，如果要答案的话是：去实际工作环境测试一下哪个性能更好

但大部分情况下用多个VAO好一点