上节我们将VBO和EBO抽象成了类，简化了代码
这节我们将VAO和它包含的VBO布局抽象成一个类
## 一、VertexArray的真正用途
VAO的真正用途是将缓冲区和实际的数据布局绑定在一起
所以对于我们来说，抽象缓冲区布局为Class的真正原因是**我们希望定义某种布局**，并且是存在CPU端的

存在CPU端的好处是我们可以读取实际的VertexBuffer数据，这很有用，比如：
- 方便Debug
- CPU端读取模型中的三角形，查看是否与屏幕上发出的射线相交，确定我们的鼠标是否选中对象


## 二、抽象为Class
抽象时，我们会考虑两种思路：
- 使用一个全局VAO，使用是每次重新指定布局
- VAO中包含布局，使用时创建多个VAO


在这里我们选择第二种
//注意！我们并不打算在Class中包含布局这个成员，因为布局实际上已经存在VAO中了
### 1.VertexArray

头文件中定义VAO的类成员和函数头文件
```cpp
//VertexArray.h
#pragma once

#include "VertexBuffer.h"
#include "VertexBufferLayout.h"

class VertexArray
{
private:
	unsigned int m_RendererID;
public:
	VertexArray();
	~VertexArray();

	void AddBuffer(const VertexBuffer& vb, const VertexBufferLayout& layout);
	void Bind() const;
	void Unbind() const;
	
};


```

在VAO的Cpp文件中实现头文件的函数：
- 构造函数：创建VAO,bind
- 析构函数：删除对象
- Bind()：绑定VAO到contex
- Unbind()：解绑
- AddBuffer：bindVAO，bindVBO，指定布局
```cpp
//VertexArray.cpp
#include "VertexArray.h"
#include "Renderer.h"

VertexArray::VertexArray()
{
	GLCall(glGenVertexArrays(1, &m_RendererID));// 生成一个VAO对象，返回的id存储在vao中
	GLCall(glBindVertexArray(m_RendererID));
}

VertexArray::~VertexArray()
{
	GLCall(glDeleteVertexArrays(1, &m_RendererID));//parameters: number of buffers, buffer id
}

void VertexArray::Bind() const
{
	GLCall(glBindVertexArray(m_RendererID));// 绑定VAO对象到当前的OpenGL contex中
}

void VertexArray::Unbind() const
{
	GLCall(glBindVertexArray(0));//解绑VAO对象
}


void VertexArray::AddBuffer(const VertexBuffer& vb, const VertexBufferLayout& layout)
{
	Bind();		//bind VAO
	vb.Bind();	//bind VBO

	//设置布局，绑定VAO对象到当前的OpenGL contex中
	const auto& elements = layout.GetElements();
	unsigned int offset = 0;
	for (unsigned int i = 0; i < elements.size(); i++)
	{
		const auto& element = elements[i];
		GLCall(glEnableVertexAttribArray(i));
		GLCall(glVertexAttribPointer(i, element.count, element.type, element.normalized,
			layout.GetStride(), (const void*)offset));
		offset += element.count * VertexBufferElement::GetSizeOfType(element.type);
	}
	
}


```

### 2.VertexArrayLayout
我们通过这个类解释VBO
```cpp
//VertexArrayLayout.h
#pragma once
#include <vector>
#include <GL/glew.h>
#include "Renderer.h"

struct VertexBufferElement //对应VertexAttributePointer的参数
{
	unsigned int type;//数据类型
	unsigned int count;//数据数量，用于计算stride
	unsigned char normalized;//是否归一化

	static unsigned int GetSizeOfType(unsigned int type)//用于计算数据类型的大小
	{
		switch (type)
		{
			case GL_FLOAT: return sizeof(GLfloat);		//4
			case GL_UNSIGNED_INT: return sizeof(GLuint);//4
			case GL_UNSIGNED_BYTE: return sizeof(GLbyte);//1
		}
		ASSERT(false);
		return 0;
	}
};

class VertexBufferLayout
{
private:
	std::vector<VertexBufferElement> m_Elements;
	unsigned int m_Stride;
public:
	VertexBufferLayout()
		:m_Stride(0) {} //构造函数，初始化m_Stride为0

	//下边的Push函数是一个模板函数，表示可以接收任意类型的参数
	//push函数的意思是将数据添加到布局中，这里的数据是指顶点属性的类型和数量，数量对应VertexAttributePointer的第一个参数
	template<typename T> 
	void Push(unsigned int count)
	{
		static_assert(false);//编译时错误，表示不支持的类型
	}

	template<> //这一行是模板特化，表示对特定类型的实现
	void Push<float>(unsigned int count)
	{
		m_Elements.push_back({ GL_FLOAT, count, GL_FALSE });//float不需要归一化，先硬编码为 false
		m_Stride += count * VertexBufferElement::GetSizeOfType(GL_FLOAT);
	}

	template<>
	void Push<int>(unsigned int count)
	{
		m_Elements.push_back({ GL_UNSIGNED_INT, count, GL_FALSE });//unsigned int不需要归一化，先硬编码为 false
		m_Stride += count * VertexBufferElement::GetSizeOfType(GL_UNSIGNED_INT);
	}

	template<>
	void Push<char>(unsigned int count)
	{
		m_Elements.push_back({ GL_UNSIGNED_BYTE, count, GL_TRUE });//unsigned char需要归一化
		m_Stride += count * VertexBufferElement::GetSizeOfType(GL_UNSIGNED_BYTE);
	}
	
	inline const std::vector<VertexBufferElement> GetElements() const { return m_Elements; };
	inline unsigned int GetStride() const { return m_Stride; }
};

```


### 3.修改main程序

```cpp

#include <GL\glew.h>
#include "GLFW\glfw3.h"
#include <iostream>

#include <fstream>
#include <sstream>
#include <string>

#include "Renderer.h"
#include "VertexBuffer.h"
#include "IndexBuffer.h"
#include "VertexArray.h"


//使用结构体存放ParseShader函数的返回值
struct ShaderProgramSource
{
	std::string VertexSource;
	std::string FragmentSource;
};

static ShaderProgramSource ParseShader(const std::string& filepath)
{
	//stream的意思是流
	//流是一个抽象的概念，表示数据的输入和输出
	//流可以是文件流、内存流、网络流等。这里我们使用ifstream类来创建一个文件输入流对象，用于读取文件内容

	std::ifstream stream(filepath);//这行代码打开了一个文件流，文件名为filepath

	enum class ShaderType
	{
		NONE = -1, VERTEX = 0, FRAGMENT = 1
		//这里将vertex和Fragment分别设置为0和1，方便后边将源代码中的非标记行添加到对应的stringstream中
	};

	//读取文件内容，逐行检查
	std::string line;//用于存储每一行的内容
	std::stringstream ss[2];//用于存储顶点着色器和片段着色器的源代码
	ShaderType shaderType = ShaderType::NONE;//枚举变量shaderType，用于表示当前读取的着色器类型

	while (getline(stream, line))
	{
		if (line.find("shader") != std::string::npos) //查找有#shader关键字的那两行
		{

			if (line.find("vertex") != std::string::npos)//npos=没有找到
			{
				shaderType = ShaderType::VERTEX;
			}
			else if (line.find("fragment") != std::string::npos)
			{
				shaderType = ShaderType::FRAGMENT;
			}
		}
		else//其他行，shader 源代码
		{
			ss[(int)shaderType] << line << "\n";//当前行的内容添加到对应的stringstream中
		}
	}

	return { ss[0].str(), ss[1].str() };
	//返回一个ShaderProgramSource对象，包含顶点着色器和片段着色器的源代码
}

static unsigned int CompilerShader(unsigned int shaderType, const std::string& source)
{
	unsigned int id = glCreateShader(shaderType);//创建一个shader对象
	const char* src = source.c_str();
	// 获取shader的源代码
	//c_str()返回一个const char*指针，指向字符


	GLCall(glShaderSource(id, 1, &src, nullptr));
	//将源代码传递给shader对象
	//id是shader对象的id
	// glShaderSource函数的第二个参数是一个int类型的指针，表示源代码的数量
	// 这里我们只传递一个源代码，所以第二个参数是1
	// glShaderSource函数的第三个参数是一个const char*类型的指针，指向源代码的首地址
	// glShaderSource函数的第四个参数是一个int类型的指针，表示源代码的长度.这里我们传递nullptr，表示源代码的长度是自动计算的


	GLCall(glCompileShader(id));// 编译shader对象

	// 检查编译错误
	int result;
	GLCall(glGetShaderiv(id, GL_COMPILE_STATUS, &result));
	if (result == GL_FALSE)
	{
		int length;
		glGetShaderiv(id, GL_INFO_LOG_LENGTH, &length);
		char* message = (char*)alloca(length * sizeof(char));
		// 分配一个长度为length的字符数组
		// alloca函数在栈上分配内存，分配的内存会在函数返回时自动释放

		GLCall(glGetShaderInfoLog(id, length, &length, message));
		std::cout << "Failed to compile" << (shaderType == GL_VERTEX_SHADER ? "vertex" : "fragment")
			<< std::endl;
		std::cout << message << std::endl;
		glDeleteShader(id);
		return 0;
	}
	return id;
}

static unsigned int CreateShader(const std::string& vertexShader, const std::string& fragmentShader)
{
	unsigned int program = glCreateProgram();// 创建一个程序对象
	unsigned int vs = CompilerShader(GL_VERTEX_SHADER, vertexShader);// 创建一个顶点着色器对象
	unsigned int fs = CompilerShader(GL_FRAGMENT_SHADER, fragmentShader);// 创建一个片段着色器对象

	// 将着色器对象附加到程序对象上
	glAttachShader(program, vs);
	glAttachShader(program, fs);
	glLinkProgram(program);
	glValidateProgram(program);


	//实际上shader不用删除，这样会导致缺少debug手段
	glDeleteShader(vs);
	glDeleteShader(fs);
	return program;
}

int main(void)
{
	GLFWwindow* window;

	/* Initialize the library */
	if (!glfwInit())
		return -1;
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);//设置OpenGL的版本号
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);//设置OpenGL的版本号
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);//设置OpenGL的核心模式

	/* Create a windowed mode window and its OpenGL context */
	window = glfwCreateWindow(640, 480, "Hello World", NULL, NULL);
	if (!window)
	{
		glfwTerminate();
		return -1;
	}

	glfwSwapInterval(1);//设置交换间隔为1，表示每帧交换一次缓冲区，和显示器的刷新率一致

	/* Make the window's context current */
	glfwMakeContextCurrent(window);

	float positions[] =
	{
		-0.5f,-0.5f,
		 0.5f,-0.5f,
		 0.5f, 0.5f,
		-0.5f, 0.5f
	};

	//创建索引缓冲区
	unsigned int indices[] =
	{
		0,1,2,
		2,3,0
	};

	//Using glew
	if (glewInit() != GLEW_OK)
	{
		std::cout << "Error" << std::endl;
	}
	std::cout << glGetString(GL_VERSION) << std::endl;


	//VAO
	VertexArray vao;
	//VBO
	VertexBuffer vbo(positions, sizeof(positions));
	//Layout
	VertexBufferLayout layout;
	layout.Push<float>(2);//push 2个float到布局的元素中,2float
	vao.AddBuffer(vbo, layout);//将VBO和Layout绑定到VAO上
	//EBO
	IndexBuffer ibo(indices, 6);
	

	//这里使用的是相对路径，设置在property中的Debugging中的Working Directory
	//默认为Project的根目录
	//打印出切分后的vs和fs用于Debug
	ShaderProgramSource source = ParseShader("res/shaders/Basic.shader");
	std::cout << "vertex source: " << std::endl << source.VertexSource << std::endl;
	std::cout << "fragment source: " << std::endl << source.FragmentSource << std::endl;
	unsigned int shader = CreateShader(source.VertexSource, source.FragmentSource);
	glUseProgram(shader);


	

	int location = glGetUniformLocation(shader, "u_Color");
	ASSERT(location != -1);//检查uniform变量是否存在
	float r = 0.0f;
	float increament = 0.05f;

	//#unbind everything
	glBindVertexArray(0);//VAO
	glBindBuffer(GL_ARRAY_BUFFER, 0);//vbo
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);//ibo
	glUseProgram(0);//shader


	/* Loop until the user closes the window */
	while (!glfwWindowShouldClose(window))
	{
		/* Render here */
		glClear(GL_COLOR_BUFFER_BIT);

		GLCall(glUseProgram(shader));
		glUniform4f(location, r, 0.3f, 0.8f, 1.0f);

		//#bindVAO
		vao.Bind();
		ibo.Bind();
		GLCall(glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr));

		if (r > 1.0f)
		{
			increament = -0.05f;
		}
		else if (r < 0.0f)
		{
			increament = 0.05f;
		}
		r += increament;

		/* Swap front and back buffers */
		glfwSwapBuffers(window);

		/* Poll for and process events */
		glfwPollEvents();
	}

	glDeleteProgram(shader);
	glfwTerminate();
	return 0;
}

```
